{"ast":null,"code":"import { Plugin, PluginKey, TextSelection, Selection, NodeSelection, EditorState } from '@tiptap/pm/state';\nimport { EditorView } from '@tiptap/pm/view';\nimport { keymap } from '@tiptap/pm/keymap';\nimport { Schema, Fragment, DOMParser, DOMSerializer, Node as Node$1, Slice } from '@tiptap/pm/model';\nimport { liftTarget, ReplaceStep, ReplaceAroundStep, joinPoint, Transform, canSplit, canJoin, findWrapping } from '@tiptap/pm/transform';\nimport { createParagraphNear as createParagraphNear$1, deleteSelection as deleteSelection$1, exitCode as exitCode$1, joinUp as joinUp$1, joinDown as joinDown$1, joinBackward as joinBackward$1, joinForward as joinForward$1, lift as lift$1, liftEmptyBlock as liftEmptyBlock$1, newlineInCode as newlineInCode$1, selectNodeBackward as selectNodeBackward$1, selectNodeForward as selectNodeForward$1, selectParentNode as selectParentNode$1, selectTextblockEnd as selectTextblockEnd$1, selectTextblockStart as selectTextblockStart$1, setBlockType, wrapIn as wrapIn$1 } from '@tiptap/pm/commands';\nimport { liftListItem as liftListItem$1, sinkListItem as sinkListItem$1, wrapInList as wrapInList$1 } from '@tiptap/pm/schema-list';\nfunction createChainableState(config) {\n  const {\n    state,\n    transaction\n  } = config;\n  let {\n    selection\n  } = transaction;\n  let {\n    doc\n  } = transaction;\n  let {\n    storedMarks\n  } = transaction;\n  return {\n    ...state,\n    apply: state.apply.bind(state),\n    applyTransaction: state.applyTransaction.bind(state),\n    filterTransaction: state.filterTransaction,\n    plugins: state.plugins,\n    schema: state.schema,\n    reconfigure: state.reconfigure.bind(state),\n    toJSON: state.toJSON.bind(state),\n    get storedMarks() {\n      return storedMarks;\n    },\n    get selection() {\n      return selection;\n    },\n    get doc() {\n      return doc;\n    },\n    get tr() {\n      selection = transaction.selection;\n      doc = transaction.doc;\n      storedMarks = transaction.storedMarks;\n      return transaction;\n    }\n  };\n}\nclass CommandManager {\n  constructor(props) {\n    this.editor = props.editor;\n    this.rawCommands = this.editor.extensionManager.commands;\n    this.customState = props.state;\n  }\n  get hasCustomState() {\n    return !!this.customState;\n  }\n  get state() {\n    return this.customState || this.editor.state;\n  }\n  get commands() {\n    const {\n      rawCommands,\n      editor,\n      state\n    } = this;\n    const {\n      view\n    } = editor;\n    const {\n      tr\n    } = state;\n    const props = this.buildProps(tr);\n    return Object.fromEntries(Object.entries(rawCommands).map(([name, command]) => {\n      const method = (...args) => {\n        const callback = command(...args)(props);\n        if (!tr.getMeta('preventDispatch') && !this.hasCustomState) {\n          view.dispatch(tr);\n        }\n        return callback;\n      };\n      return [name, method];\n    }));\n  }\n  get chain() {\n    return () => this.createChain();\n  }\n  get can() {\n    return () => this.createCan();\n  }\n  createChain(startTr, shouldDispatch = true) {\n    const {\n      rawCommands,\n      editor,\n      state\n    } = this;\n    const {\n      view\n    } = editor;\n    const callbacks = [];\n    const hasStartTransaction = !!startTr;\n    const tr = startTr || state.tr;\n    const run = () => {\n      if (!hasStartTransaction && shouldDispatch && !tr.getMeta('preventDispatch') && !this.hasCustomState) {\n        view.dispatch(tr);\n      }\n      return callbacks.every(callback => callback === true);\n    };\n    const chain = {\n      ...Object.fromEntries(Object.entries(rawCommands).map(([name, command]) => {\n        const chainedCommand = (...args) => {\n          const props = this.buildProps(tr, shouldDispatch);\n          const callback = command(...args)(props);\n          callbacks.push(callback);\n          return chain;\n        };\n        return [name, chainedCommand];\n      })),\n      run\n    };\n    return chain;\n  }\n  createCan(startTr) {\n    const {\n      rawCommands,\n      state\n    } = this;\n    const dispatch = false;\n    const tr = startTr || state.tr;\n    const props = this.buildProps(tr, dispatch);\n    const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command]) => {\n      return [name, (...args) => command(...args)({\n        ...props,\n        dispatch: undefined\n      })];\n    }));\n    return {\n      ...formattedCommands,\n      chain: () => this.createChain(tr, dispatch)\n    };\n  }\n  buildProps(tr, shouldDispatch = true) {\n    const {\n      rawCommands,\n      editor,\n      state\n    } = this;\n    const {\n      view\n    } = editor;\n    const props = {\n      tr,\n      editor,\n      view,\n      state: createChainableState({\n        state,\n        transaction: tr\n      }),\n      dispatch: shouldDispatch ? () => undefined : undefined,\n      chain: () => this.createChain(tr, shouldDispatch),\n      can: () => this.createCan(tr),\n      get commands() {\n        return Object.fromEntries(Object.entries(rawCommands).map(([name, command]) => {\n          return [name, (...args) => command(...args)(props)];\n        }));\n      }\n    };\n    return props;\n  }\n}\nclass EventEmitter {\n  constructor() {\n    this.callbacks = {};\n  }\n  on(event, fn) {\n    if (!this.callbacks[event]) {\n      this.callbacks[event] = [];\n    }\n    this.callbacks[event].push(fn);\n    return this;\n  }\n  emit(event, ...args) {\n    const callbacks = this.callbacks[event];\n    if (callbacks) {\n      callbacks.forEach(callback => callback.apply(this, args));\n    }\n    return this;\n  }\n  off(event, fn) {\n    const callbacks = this.callbacks[event];\n    if (callbacks) {\n      if (fn) {\n        this.callbacks[event] = callbacks.filter(callback => callback !== fn);\n      } else {\n        delete this.callbacks[event];\n      }\n    }\n    return this;\n  }\n  removeAllListeners() {\n    this.callbacks = {};\n  }\n}\nfunction getExtensionField(extension, field, context) {\n  if (extension.config[field] === undefined && extension.parent) {\n    return getExtensionField(extension.parent, field, context);\n  }\n  if (typeof extension.config[field] === 'function') {\n    const value = extension.config[field].bind({\n      ...context,\n      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null\n    });\n    return value;\n  }\n  return extension.config[field];\n}\nfunction splitExtensions(extensions) {\n  const baseExtensions = extensions.filter(extension => extension.type === 'extension');\n  const nodeExtensions = extensions.filter(extension => extension.type === 'node');\n  const markExtensions = extensions.filter(extension => extension.type === 'mark');\n  return {\n    baseExtensions,\n    nodeExtensions,\n    markExtensions\n  };\n}\n\n/**\r\n * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.\r\n * @param extensions List of extensions\r\n */\nfunction getAttributesFromExtensions(extensions) {\n  const extensionAttributes = [];\n  const {\n    nodeExtensions,\n    markExtensions\n  } = splitExtensions(extensions);\n  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];\n  const defaultAttribute = {\n    default: null,\n    rendered: true,\n    renderHTML: null,\n    parseHTML: null,\n    keepOnSplit: true,\n    isRequired: false\n  };\n  extensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    const addGlobalAttributes = getExtensionField(extension, 'addGlobalAttributes', context);\n    if (!addGlobalAttributes) {\n      return;\n    }\n    // TODO: remove `as GlobalAttributes`\n    const globalAttributes = addGlobalAttributes();\n    globalAttributes.forEach(globalAttribute => {\n      globalAttribute.types.forEach(type => {\n        Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {\n          extensionAttributes.push({\n            type,\n            name,\n            attribute: {\n              ...defaultAttribute,\n              ...attribute\n            }\n          });\n        });\n      });\n    });\n  });\n  nodeAndMarkExtensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    const addAttributes = getExtensionField(extension, 'addAttributes', context);\n    if (!addAttributes) {\n      return;\n    }\n    // TODO: remove `as Attributes`\n    const attributes = addAttributes();\n    Object.entries(attributes).forEach(([name, attribute]) => {\n      const mergedAttr = {\n        ...defaultAttribute,\n        ...attribute\n      };\n      if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === 'function') {\n        mergedAttr.default = mergedAttr.default();\n      }\n      if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === undefined) {\n        delete mergedAttr.default;\n      }\n      extensionAttributes.push({\n        type: extension.name,\n        name,\n        attribute: mergedAttr\n      });\n    });\n  });\n  return extensionAttributes;\n}\nfunction getNodeType(nameOrType, schema) {\n  if (typeof nameOrType === 'string') {\n    if (!schema.nodes[nameOrType]) {\n      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n    }\n    return schema.nodes[nameOrType];\n  }\n  return nameOrType;\n}\nfunction mergeAttributes(...objects) {\n  return objects.filter(item => !!item).reduce((items, item) => {\n    const mergedAttributes = {\n      ...items\n    };\n    Object.entries(item).forEach(([key, value]) => {\n      const exists = mergedAttributes[key];\n      if (!exists) {\n        mergedAttributes[key] = value;\n        return;\n      }\n      if (key === 'class') {\n        const valueClasses = value ? value.split(' ') : [];\n        const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(' ') : [];\n        const insertClasses = valueClasses.filter(valueClass => !existingClasses.includes(valueClass));\n        mergedAttributes[key] = [...existingClasses, ...insertClasses].join(' ');\n      } else if (key === 'style') {\n        mergedAttributes[key] = [mergedAttributes[key], value].join('; ');\n      } else {\n        mergedAttributes[key] = value;\n      }\n    });\n    return mergedAttributes;\n  }, {});\n}\nfunction getRenderedAttributes(nodeOrMark, extensionAttributes) {\n  return extensionAttributes.filter(item => item.attribute.rendered).map(item => {\n    if (!item.attribute.renderHTML) {\n      return {\n        [item.name]: nodeOrMark.attrs[item.name]\n      };\n    }\n    return item.attribute.renderHTML(nodeOrMark.attrs) || {};\n  }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});\n}\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n\n/**\r\n * Optionally calls `value` as a function.\r\n * Otherwise it is returned directly.\r\n * @param value Function or any value.\r\n * @param context Optional context to bind to function.\r\n * @param props Optional props to pass to function.\r\n */\nfunction callOrReturn(value, context = undefined, ...props) {\n  if (isFunction(value)) {\n    if (context) {\n      return value.bind(context)(...props);\n    }\n    return value(...props);\n  }\n  return value;\n}\nfunction isEmptyObject(value = {}) {\n  return Object.keys(value).length === 0 && value.constructor === Object;\n}\nfunction fromString(value) {\n  if (typeof value !== 'string') {\n    return value;\n  }\n  if (value.match(/^[+-]?(?:\\d*\\.)?\\d+$/)) {\n    return Number(value);\n  }\n  if (value === 'true') {\n    return true;\n  }\n  if (value === 'false') {\n    return false;\n  }\n  return value;\n}\n\n/**\r\n * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).\r\n * Cancels when `getAttrs` returned `false`.\r\n * @param parseRule ProseMirror ParseRule\r\n * @param extensionAttributes List of attributes to inject\r\n */\nfunction injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {\n  if (parseRule.style) {\n    return parseRule;\n  }\n  return {\n    ...parseRule,\n    getAttrs: node => {\n      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;\n      if (oldAttributes === false) {\n        return false;\n      }\n      const newAttributes = extensionAttributes.reduce((items, item) => {\n        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));\n        if (value === null || value === undefined) {\n          return items;\n        }\n        return {\n          ...items,\n          [item.name]: value\n        };\n      }, {});\n      return {\n        ...oldAttributes,\n        ...newAttributes\n      };\n    }\n  };\n}\nfunction cleanUpSchemaItem(data) {\n  return Object.fromEntries(\n  // @ts-ignore\n  Object.entries(data).filter(([key, value]) => {\n    if (key === 'attrs' && isEmptyObject(value)) {\n      return false;\n    }\n    return value !== null && value !== undefined;\n  }));\n}\nfunction getSchemaByResolvedExtensions(extensions, editor) {\n  var _a;\n  const allAttributes = getAttributesFromExtensions(extensions);\n  const {\n    nodeExtensions,\n    markExtensions\n  } = splitExtensions(extensions);\n  const topNode = (_a = nodeExtensions.find(extension => getExtensionField(extension, 'topNode'))) === null || _a === void 0 ? void 0 : _a.name;\n  const nodes = Object.fromEntries(nodeExtensions.map(extension => {\n    const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name);\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n      editor\n    };\n    const extraNodeFields = extensions.reduce((fields, e) => {\n      const extendNodeSchema = getExtensionField(e, 'extendNodeSchema', context);\n      return {\n        ...fields,\n        ...(extendNodeSchema ? extendNodeSchema(extension) : {})\n      };\n    }, {});\n    const schema = cleanUpSchemaItem({\n      ...extraNodeFields,\n      content: callOrReturn(getExtensionField(extension, 'content', context)),\n      marks: callOrReturn(getExtensionField(extension, 'marks', context)),\n      group: callOrReturn(getExtensionField(extension, 'group', context)),\n      inline: callOrReturn(getExtensionField(extension, 'inline', context)),\n      atom: callOrReturn(getExtensionField(extension, 'atom', context)),\n      selectable: callOrReturn(getExtensionField(extension, 'selectable', context)),\n      draggable: callOrReturn(getExtensionField(extension, 'draggable', context)),\n      code: callOrReturn(getExtensionField(extension, 'code', context)),\n      defining: callOrReturn(getExtensionField(extension, 'defining', context)),\n      isolating: callOrReturn(getExtensionField(extension, 'isolating', context)),\n      attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\n        var _a;\n        return [extensionAttribute.name, {\n          default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default\n        }];\n      }))\n    });\n    const parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));\n    if (parseHTML) {\n      schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\n    }\n    const renderHTML = getExtensionField(extension, 'renderHTML', context);\n    if (renderHTML) {\n      schema.toDOM = node => renderHTML({\n        node,\n        HTMLAttributes: getRenderedAttributes(node, extensionAttributes)\n      });\n    }\n    const renderText = getExtensionField(extension, 'renderText', context);\n    if (renderText) {\n      schema.toText = renderText;\n    }\n    return [extension.name, schema];\n  }));\n  const marks = Object.fromEntries(markExtensions.map(extension => {\n    const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name);\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n      editor\n    };\n    const extraMarkFields = extensions.reduce((fields, e) => {\n      const extendMarkSchema = getExtensionField(e, 'extendMarkSchema', context);\n      return {\n        ...fields,\n        ...(extendMarkSchema ? extendMarkSchema(extension) : {})\n      };\n    }, {});\n    const schema = cleanUpSchemaItem({\n      ...extraMarkFields,\n      inclusive: callOrReturn(getExtensionField(extension, 'inclusive', context)),\n      excludes: callOrReturn(getExtensionField(extension, 'excludes', context)),\n      group: callOrReturn(getExtensionField(extension, 'group', context)),\n      spanning: callOrReturn(getExtensionField(extension, 'spanning', context)),\n      code: callOrReturn(getExtensionField(extension, 'code', context)),\n      attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\n        var _a;\n        return [extensionAttribute.name, {\n          default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default\n        }];\n      }))\n    });\n    const parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));\n    if (parseHTML) {\n      schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\n    }\n    const renderHTML = getExtensionField(extension, 'renderHTML', context);\n    if (renderHTML) {\n      schema.toDOM = mark => renderHTML({\n        mark,\n        HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)\n      });\n    }\n    return [extension.name, schema];\n  }));\n  return new Schema({\n    topNode,\n    nodes,\n    marks\n  });\n}\nfunction getSchemaTypeByName(name, schema) {\n  return schema.nodes[name] || schema.marks[name] || null;\n}\nfunction isExtensionRulesEnabled(extension, enabled) {\n  if (Array.isArray(enabled)) {\n    return enabled.some(enabledExtension => {\n      const name = typeof enabledExtension === 'string' ? enabledExtension : enabledExtension.name;\n      return name === extension.name;\n    });\n  }\n  return enabled;\n}\nconst getTextContentFromNodes = ($from, maxMatch = 500) => {\n  let textBefore = '';\n  const sliceEndPos = $from.parentOffset;\n  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index) => {\n    var _a, _b;\n    const chunk = ((_b = (_a = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a, {\n      node,\n      pos,\n      parent,\n      index\n    })) || node.textContent || '%leaf%';\n    textBefore += chunk.slice(0, Math.max(0, sliceEndPos - pos));\n  });\n  return textBefore;\n};\nfunction isRegExp(value) {\n  return Object.prototype.toString.call(value) === '[object RegExp]';\n}\nclass InputRule {\n  constructor(config) {\n    this.find = config.find;\n    this.handler = config.handler;\n  }\n}\nconst inputRuleMatcherHandler = (text, find) => {\n  if (isRegExp(find)) {\n    return find.exec(text);\n  }\n  const inputRuleMatch = find(text);\n  if (!inputRuleMatch) {\n    return null;\n  }\n  const result = [inputRuleMatch.text];\n  result.index = inputRuleMatch.index;\n  result.input = text;\n  result.data = inputRuleMatch.data;\n  if (inputRuleMatch.replaceWith) {\n    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {\n      console.warn('[tiptap warn]: \"inputRuleMatch.replaceWith\" must be part of \"inputRuleMatch.text\".');\n    }\n    result.push(inputRuleMatch.replaceWith);\n  }\n  return result;\n};\nfunction run$1(config) {\n  var _a;\n  const {\n    editor,\n    from,\n    to,\n    text,\n    rules,\n    plugin\n  } = config;\n  const {\n    view\n  } = editor;\n  if (view.composing) {\n    return false;\n  }\n  const $from = view.state.doc.resolve(from);\n  if (\n  // check for code node\n  $from.parent.type.spec.code\n  // check for code mark\n  || !!((_a = $from.nodeBefore || $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.marks.find(mark => mark.type.spec.code))) {\n    return false;\n  }\n  let matched = false;\n  const textBefore = getTextContentFromNodes($from) + text;\n  rules.forEach(rule => {\n    if (matched) {\n      return;\n    }\n    const match = inputRuleMatcherHandler(textBefore, rule.find);\n    if (!match) {\n      return;\n    }\n    const tr = view.state.tr;\n    const state = createChainableState({\n      state: view.state,\n      transaction: tr\n    });\n    const range = {\n      from: from - (match[0].length - text.length),\n      to\n    };\n    const {\n      commands,\n      chain,\n      can\n    } = new CommandManager({\n      editor,\n      state\n    });\n    const handler = rule.handler({\n      state,\n      range,\n      match,\n      commands,\n      chain,\n      can\n    });\n    // stop if there are no changes\n    if (handler === null || !tr.steps.length) {\n      return;\n    }\n    // store transform as meta data\n    // so we can undo input rules within the `undoInputRules` command\n    tr.setMeta(plugin, {\n      transform: tr,\n      from,\n      to,\n      text\n    });\n    view.dispatch(tr);\n    matched = true;\n  });\n  return matched;\n}\n/**\r\n * Create an input rules plugin. When enabled, it will cause text\r\n * input that matches any of the given rules to trigger the rule’s\r\n * action.\r\n */\nfunction inputRulesPlugin(props) {\n  const {\n    editor,\n    rules\n  } = props;\n  const plugin = new Plugin({\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, prev) {\n        const stored = tr.getMeta(plugin);\n        if (stored) {\n          return stored;\n        }\n        return tr.selectionSet || tr.docChanged ? null : prev;\n      }\n    },\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run$1({\n          editor,\n          from,\n          to,\n          text,\n          rules,\n          plugin\n        });\n      },\n      handleDOMEvents: {\n        compositionend: view => {\n          setTimeout(() => {\n            const {\n              $cursor\n            } = view.state.selection;\n            if ($cursor) {\n              run$1({\n                editor,\n                from: $cursor.pos,\n                to: $cursor.pos,\n                text: '',\n                rules,\n                plugin\n              });\n            }\n          });\n          return false;\n        }\n      },\n      // add support for input rules to trigger on enter\n      // this is useful for example for code blocks\n      handleKeyDown(view, event) {\n        if (event.key !== 'Enter') {\n          return false;\n        }\n        const {\n          $cursor\n        } = view.state.selection;\n        if ($cursor) {\n          return run$1({\n            editor,\n            from: $cursor.pos,\n            to: $cursor.pos,\n            text: '\\n',\n            rules,\n            plugin\n          });\n        }\n        return false;\n      }\n    },\n    // @ts-ignore\n    isInputRules: true\n  });\n  return plugin;\n}\nfunction isNumber(value) {\n  return typeof value === 'number';\n}\nclass PasteRule {\n  constructor(config) {\n    this.find = config.find;\n    this.handler = config.handler;\n  }\n}\nconst pasteRuleMatcherHandler = (text, find) => {\n  if (isRegExp(find)) {\n    return [...text.matchAll(find)];\n  }\n  const matches = find(text);\n  if (!matches) {\n    return [];\n  }\n  return matches.map(pasteRuleMatch => {\n    const result = [pasteRuleMatch.text];\n    result.index = pasteRuleMatch.index;\n    result.input = text;\n    result.data = pasteRuleMatch.data;\n    if (pasteRuleMatch.replaceWith) {\n      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {\n        console.warn('[tiptap warn]: \"pasteRuleMatch.replaceWith\" must be part of \"pasteRuleMatch.text\".');\n      }\n      result.push(pasteRuleMatch.replaceWith);\n    }\n    return result;\n  });\n};\nfunction run(config) {\n  const {\n    editor,\n    state,\n    from,\n    to,\n    rule,\n    pasteEvent,\n    dropEvent\n  } = config;\n  const {\n    commands,\n    chain,\n    can\n  } = new CommandManager({\n    editor,\n    state\n  });\n  const handlers = [];\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isTextblock || node.type.spec.code) {\n      return;\n    }\n    const resolvedFrom = Math.max(from, pos);\n    const resolvedTo = Math.min(to, pos + node.content.size);\n    const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, undefined, '\\ufffc');\n    const matches = pasteRuleMatcherHandler(textToMatch, rule.find);\n    matches.forEach(match => {\n      if (match.index === undefined) {\n        return;\n      }\n      const start = resolvedFrom + match.index + 1;\n      const end = start + match[0].length;\n      const range = {\n        from: state.tr.mapping.map(start),\n        to: state.tr.mapping.map(end)\n      };\n      const handler = rule.handler({\n        state,\n        range,\n        match,\n        commands,\n        chain,\n        can,\n        pasteEvent,\n        dropEvent\n      });\n      handlers.push(handler);\n    });\n  });\n  const success = handlers.every(handler => handler !== null);\n  return success;\n}\n/**\r\n * Create an paste rules plugin. When enabled, it will cause pasted\r\n * text that matches any of the given rules to trigger the rule’s\r\n * action.\r\n */\nfunction pasteRulesPlugin(props) {\n  const {\n    editor,\n    rules\n  } = props;\n  let dragSourceElement = null;\n  let isPastedFromProseMirror = false;\n  let isDroppedFromProseMirror = false;\n  let pasteEvent = new ClipboardEvent('paste');\n  let dropEvent = new DragEvent('drop');\n  const plugins = rules.map(rule => {\n    return new Plugin({\n      // we register a global drag handler to track the current drag source element\n      view(view) {\n        const handleDragstart = event => {\n          var _a;\n          dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;\n        };\n        window.addEventListener('dragstart', handleDragstart);\n        return {\n          destroy() {\n            window.removeEventListener('dragstart', handleDragstart);\n          }\n        };\n      },\n      props: {\n        handleDOMEvents: {\n          drop: (view, event) => {\n            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;\n            dropEvent = event;\n            return false;\n          },\n          paste: (_view, event) => {\n            var _a;\n            const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData('text/html');\n            pasteEvent = event;\n            isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes('data-pm-slice'));\n            return false;\n          }\n        }\n      },\n      appendTransaction: (transactions, oldState, state) => {\n        const transaction = transactions[0];\n        const isPaste = transaction.getMeta('uiEvent') === 'paste' && !isPastedFromProseMirror;\n        const isDrop = transaction.getMeta('uiEvent') === 'drop' && !isDroppedFromProseMirror;\n        if (!isPaste && !isDrop) {\n          return;\n        }\n        // stop if there is no changed range\n        const from = oldState.doc.content.findDiffStart(state.doc.content);\n        const to = oldState.doc.content.findDiffEnd(state.doc.content);\n        if (!isNumber(from) || !to || from === to.b) {\n          return;\n        }\n        // build a chainable state\n        // so we can use a single transaction for all paste rules\n        const tr = state.tr;\n        const chainableState = createChainableState({\n          state,\n          transaction: tr\n        });\n        const handler = run({\n          editor,\n          state: chainableState,\n          from: Math.max(from - 1, 0),\n          to: to.b - 1,\n          rule,\n          pasteEvent,\n          dropEvent\n        });\n        // stop if there are no changes\n        if (!handler || !tr.steps.length) {\n          return;\n        }\n        dropEvent = new DragEvent('drop');\n        pasteEvent = new ClipboardEvent('paste');\n        return tr;\n      }\n    });\n  });\n  return plugins;\n}\nfunction findDuplicates(items) {\n  const filtered = items.filter((el, index) => items.indexOf(el) !== index);\n  return [...new Set(filtered)];\n}\nclass ExtensionManager {\n  constructor(extensions, editor) {\n    this.splittableMarks = [];\n    this.editor = editor;\n    this.extensions = ExtensionManager.resolve(extensions);\n    this.schema = getSchemaByResolvedExtensions(this.extensions, editor);\n    this.extensions.forEach(extension => {\n      var _a;\n      // store extension storage in editor\n      this.editor.extensionStorage[extension.name] = extension.storage;\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      if (extension.type === 'mark') {\n        const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, 'keepOnSplit', context))) !== null && _a !== void 0 ? _a : true;\n        if (keepOnSplit) {\n          this.splittableMarks.push(extension.name);\n        }\n      }\n      const onBeforeCreate = getExtensionField(extension, 'onBeforeCreate', context);\n      if (onBeforeCreate) {\n        this.editor.on('beforeCreate', onBeforeCreate);\n      }\n      const onCreate = getExtensionField(extension, 'onCreate', context);\n      if (onCreate) {\n        this.editor.on('create', onCreate);\n      }\n      const onUpdate = getExtensionField(extension, 'onUpdate', context);\n      if (onUpdate) {\n        this.editor.on('update', onUpdate);\n      }\n      const onSelectionUpdate = getExtensionField(extension, 'onSelectionUpdate', context);\n      if (onSelectionUpdate) {\n        this.editor.on('selectionUpdate', onSelectionUpdate);\n      }\n      const onTransaction = getExtensionField(extension, 'onTransaction', context);\n      if (onTransaction) {\n        this.editor.on('transaction', onTransaction);\n      }\n      const onFocus = getExtensionField(extension, 'onFocus', context);\n      if (onFocus) {\n        this.editor.on('focus', onFocus);\n      }\n      const onBlur = getExtensionField(extension, 'onBlur', context);\n      if (onBlur) {\n        this.editor.on('blur', onBlur);\n      }\n      const onDestroy = getExtensionField(extension, 'onDestroy', context);\n      if (onDestroy) {\n        this.editor.on('destroy', onDestroy);\n      }\n    });\n  }\n  static resolve(extensions) {\n    const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions));\n    const duplicatedNames = findDuplicates(resolvedExtensions.map(extension => extension.name));\n    if (duplicatedNames.length) {\n      console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map(item => `'${item}'`).join(', ')}]. This can lead to issues.`);\n    }\n    return resolvedExtensions;\n  }\n  static flatten(extensions) {\n    return extensions.map(extension => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage\n      };\n      const addExtensions = getExtensionField(extension, 'addExtensions', context);\n      if (addExtensions) {\n        return [extension, ...this.flatten(addExtensions())];\n      }\n      return extension;\n    })\n    // `Infinity` will break TypeScript so we set a number that is probably high enough\n    .flat(10);\n  }\n  static sort(extensions) {\n    const defaultPriority = 100;\n    return extensions.sort((a, b) => {\n      const priorityA = getExtensionField(a, 'priority') || defaultPriority;\n      const priorityB = getExtensionField(b, 'priority') || defaultPriority;\n      if (priorityA > priorityB) {\n        return -1;\n      }\n      if (priorityA < priorityB) {\n        return 1;\n      }\n      return 0;\n    });\n  }\n  get commands() {\n    return this.extensions.reduce((commands, extension) => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      const addCommands = getExtensionField(extension, 'addCommands', context);\n      if (!addCommands) {\n        return commands;\n      }\n      return {\n        ...commands,\n        ...addCommands()\n      };\n    }, {});\n  }\n  get plugins() {\n    const {\n      editor\n    } = this;\n    // With ProseMirror, first plugins within an array are executed first.\n    // In Tiptap, we provide the ability to override plugins,\n    // so it feels more natural to run plugins at the end of an array first.\n    // That’s why we have to reverse the `extensions` array and sort again\n    // based on the `priority` option.\n    const extensions = ExtensionManager.sort([...this.extensions].reverse());\n    const inputRules = [];\n    const pasteRules = [];\n    const allPlugins = extensions.map(extension => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      const plugins = [];\n      const addKeyboardShortcuts = getExtensionField(extension, 'addKeyboardShortcuts', context);\n      let defaultBindings = {};\n      // bind exit handling\n      if (extension.type === 'mark' && extension.config.exitable) {\n        defaultBindings.ArrowRight = () => Mark.handleExit({\n          editor,\n          mark: extension\n        });\n      }\n      if (addKeyboardShortcuts) {\n        const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {\n          return [shortcut, () => method({\n            editor\n          })];\n        }));\n        defaultBindings = {\n          ...defaultBindings,\n          ...bindings\n        };\n      }\n      const keyMapPlugin = keymap(defaultBindings);\n      plugins.push(keyMapPlugin);\n      const addInputRules = getExtensionField(extension, 'addInputRules', context);\n      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {\n        inputRules.push(...addInputRules());\n      }\n      const addPasteRules = getExtensionField(extension, 'addPasteRules', context);\n      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {\n        pasteRules.push(...addPasteRules());\n      }\n      const addProseMirrorPlugins = getExtensionField(extension, 'addProseMirrorPlugins', context);\n      if (addProseMirrorPlugins) {\n        const proseMirrorPlugins = addProseMirrorPlugins();\n        plugins.push(...proseMirrorPlugins);\n      }\n      return plugins;\n    }).flat();\n    return [inputRulesPlugin({\n      editor,\n      rules: inputRules\n    }), ...pasteRulesPlugin({\n      editor,\n      rules: pasteRules\n    }), ...allPlugins];\n  }\n  get attributes() {\n    return getAttributesFromExtensions(this.extensions);\n  }\n  get nodeViews() {\n    const {\n      editor\n    } = this;\n    const {\n      nodeExtensions\n    } = splitExtensions(this.extensions);\n    return Object.fromEntries(nodeExtensions.filter(extension => !!getExtensionField(extension, 'addNodeView')).map(extension => {\n      const extensionAttributes = this.attributes.filter(attribute => attribute.type === extension.name);\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor,\n        type: getNodeType(extension.name, this.schema)\n      };\n      const addNodeView = getExtensionField(extension, 'addNodeView', context);\n      if (!addNodeView) {\n        return [];\n      }\n      const nodeview = (node, view, getPos, decorations) => {\n        const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);\n        return addNodeView()({\n          editor,\n          node,\n          getPos,\n          decorations,\n          HTMLAttributes,\n          extension\n        });\n      };\n      return [extension.name, nodeview];\n    }));\n  }\n}\n\n// see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts\nfunction getType(value) {\n  return Object.prototype.toString.call(value).slice(8, -1);\n}\nfunction isPlainObject(value) {\n  if (getType(value) !== 'Object') {\n    return false;\n  }\n  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;\n}\nfunction mergeDeep(target, source) {\n  const output = {\n    ...target\n  };\n  if (isPlainObject(target) && isPlainObject(source)) {\n    Object.keys(source).forEach(key => {\n      if (isPlainObject(source[key])) {\n        if (!(key in target)) {\n          Object.assign(output, {\n            [key]: source[key]\n          });\n        } else {\n          output[key] = mergeDeep(target[key], source[key]);\n        }\n      } else {\n        Object.assign(output, {\n          [key]: source[key]\n        });\n      }\n    });\n  }\n  return output;\n}\nclass Extension {\n  constructor(config = {}) {\n    this.type = 'extension';\n    this.name = 'extension';\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = {\n      ...this.config,\n      ...config\n    };\n    this.name = this.config.name;\n    if (config.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n    }\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions;\n    if (this.config.addOptions) {\n      this.options = callOrReturn(getExtensionField(this, 'addOptions', {\n        name: this.name\n      }));\n    }\n    this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\n      name: this.name,\n      options: this.options\n    })) || {};\n  }\n  static create(config = {}) {\n    return new Extension(config);\n  }\n  configure(options = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend();\n    extension.options = mergeDeep(this.options, options);\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n  extend(extendedConfig = {}) {\n    const extension = new Extension(extendedConfig);\n    extension.parent = this;\n    this.child = extension;\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n    if (extendedConfig.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n    }\n    extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\n      name: extension.name\n    }));\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n}\nfunction getTextBetween(startNode, range, options) {\n  const {\n    from,\n    to\n  } = range;\n  const {\n    blockSeparator = '\\n\\n',\n    textSerializers = {}\n  } = options || {};\n  let text = '';\n  let separated = true;\n  startNode.nodesBetween(from, to, (node, pos, parent, index) => {\n    var _a;\n    const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];\n    if (textSerializer) {\n      if (node.isBlock && !separated) {\n        text += blockSeparator;\n        separated = true;\n      }\n      if (parent) {\n        text += textSerializer({\n          node,\n          pos,\n          parent,\n          index,\n          range\n        });\n      }\n    } else if (node.isText) {\n      text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from, pos) - pos, to - pos); // eslint-disable-line\n      separated = false;\n    } else if (node.isBlock && !separated) {\n      text += blockSeparator;\n      separated = true;\n    }\n  });\n  return text;\n}\nfunction getTextSerializersFromSchema(schema) {\n  return Object.fromEntries(Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText]));\n}\nconst ClipboardTextSerializer = Extension.create({\n  name: 'clipboardTextSerializer',\n  addProseMirrorPlugins() {\n    return [new Plugin({\n      key: new PluginKey('clipboardTextSerializer'),\n      props: {\n        clipboardTextSerializer: () => {\n          const {\n            editor\n          } = this;\n          const {\n            state,\n            schema\n          } = editor;\n          const {\n            doc,\n            selection\n          } = state;\n          const {\n            ranges\n          } = selection;\n          const from = Math.min(...ranges.map(range => range.$from.pos));\n          const to = Math.max(...ranges.map(range => range.$to.pos));\n          const textSerializers = getTextSerializersFromSchema(schema);\n          const range = {\n            from,\n            to\n          };\n          return getTextBetween(doc, range, {\n            textSerializers\n          });\n        }\n      }\n    })];\n  }\n});\nconst blur = () => ({\n  editor,\n  view\n}) => {\n  requestAnimationFrame(() => {\n    var _a;\n    if (!editor.isDestroyed) {\n      view.dom.blur();\n      // Browsers should remove the caret on blur but safari does not.\n      // See: https://github.com/ueberdosis/tiptap/issues/2405\n      (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();\n    }\n  });\n  return true;\n};\nconst clearContent = (emitUpdate = false) => ({\n  commands\n}) => {\n  return commands.setContent('', emitUpdate);\n};\nconst clearNodes = () => ({\n  state,\n  tr,\n  dispatch\n}) => {\n  const {\n    selection\n  } = tr;\n  const {\n    ranges\n  } = selection;\n  if (!dispatch) {\n    return true;\n  }\n  ranges.forEach(({\n    $from,\n    $to\n  }) => {\n    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n      if (node.type.isText) {\n        return;\n      }\n      const {\n        doc,\n        mapping\n      } = tr;\n      const $mappedFrom = doc.resolve(mapping.map(pos));\n      const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize));\n      const nodeRange = $mappedFrom.blockRange($mappedTo);\n      if (!nodeRange) {\n        return;\n      }\n      const targetLiftDepth = liftTarget(nodeRange);\n      if (node.type.isTextblock) {\n        const {\n          defaultType\n        } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());\n        tr.setNodeMarkup(nodeRange.start, defaultType);\n      }\n      if (targetLiftDepth || targetLiftDepth === 0) {\n        tr.lift(nodeRange, targetLiftDepth);\n      }\n    });\n  });\n  return true;\n};\nconst command = fn => props => {\n  return fn(props);\n};\nconst createParagraphNear = () => ({\n  state,\n  dispatch\n}) => {\n  return createParagraphNear$1(state, dispatch);\n};\nconst cut = (originRange, targetPos) => ({\n  editor,\n  tr\n}) => {\n  const {\n    state\n  } = editor;\n  const contentSlice = state.doc.slice(originRange.from, originRange.to);\n  tr.deleteRange(originRange.from, originRange.to);\n  const newPos = tr.mapping.map(targetPos);\n  tr.insert(newPos, contentSlice.content);\n  tr.setSelection(new TextSelection(tr.doc.resolve(newPos - 1)));\n  return true;\n};\nconst deleteCurrentNode = () => ({\n  tr,\n  dispatch\n}) => {\n  const {\n    selection\n  } = tr;\n  const currentNode = selection.$anchor.node();\n  // if there is content inside the current node, break out of this command\n  if (currentNode.content.size > 0) {\n    return false;\n  }\n  const $pos = tr.selection.$anchor;\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth);\n    if (node.type === currentNode.type) {\n      if (dispatch) {\n        const from = $pos.before(depth);\n        const to = $pos.after(depth);\n        tr.delete(from, to).scrollIntoView();\n      }\n      return true;\n    }\n  }\n  return false;\n};\nconst deleteNode = typeOrName => ({\n  tr,\n  state,\n  dispatch\n}) => {\n  const type = getNodeType(typeOrName, state.schema);\n  const $pos = tr.selection.$anchor;\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth);\n    if (node.type === type) {\n      if (dispatch) {\n        const from = $pos.before(depth);\n        const to = $pos.after(depth);\n        tr.delete(from, to).scrollIntoView();\n      }\n      return true;\n    }\n  }\n  return false;\n};\nconst deleteRange = range => ({\n  tr,\n  dispatch\n}) => {\n  const {\n    from,\n    to\n  } = range;\n  if (dispatch) {\n    tr.delete(from, to);\n  }\n  return true;\n};\nconst deleteSelection = () => ({\n  state,\n  dispatch\n}) => {\n  return deleteSelection$1(state, dispatch);\n};\nconst enter = () => ({\n  commands\n}) => {\n  return commands.keyboardShortcut('Enter');\n};\nconst exitCode = () => ({\n  state,\n  dispatch\n}) => {\n  return exitCode$1(state, dispatch);\n};\n\n/**\r\n * Check if object1 includes object2\r\n * @param object1 Object\r\n * @param object2 Object\r\n */\nfunction objectIncludes(object1, object2, options = {\n  strict: true\n}) {\n  const keys = Object.keys(object2);\n  if (!keys.length) {\n    return true;\n  }\n  return keys.every(key => {\n    if (options.strict) {\n      return object2[key] === object1[key];\n    }\n    if (isRegExp(object2[key])) {\n      return object2[key].test(object1[key]);\n    }\n    return object2[key] === object1[key];\n  });\n}\nfunction findMarkInSet(marks, type, attributes = {}) {\n  return marks.find(item => {\n    return item.type === type && objectIncludes(item.attrs, attributes);\n  });\n}\nfunction isMarkInSet(marks, type, attributes = {}) {\n  return !!findMarkInSet(marks, type, attributes);\n}\nfunction getMarkRange($pos, type, attributes = {}) {\n  if (!$pos || !type) {\n    return;\n  }\n  let start = $pos.parent.childAfter($pos.parentOffset);\n  if ($pos.parentOffset === start.offset && start.offset !== 0) {\n    start = $pos.parent.childBefore($pos.parentOffset);\n  }\n  if (!start.node) {\n    return;\n  }\n  const mark = findMarkInSet([...start.node.marks], type, attributes);\n  if (!mark) {\n    return;\n  }\n  let startIndex = start.index;\n  let startPos = $pos.start() + start.offset;\n  let endIndex = startIndex + 1;\n  let endPos = startPos + start.node.nodeSize;\n  findMarkInSet([...start.node.marks], type, attributes);\n  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {\n    startIndex -= 1;\n    startPos -= $pos.parent.child(startIndex).nodeSize;\n  }\n  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {\n    endPos += $pos.parent.child(endIndex).nodeSize;\n    endIndex += 1;\n  }\n  return {\n    from: startPos,\n    to: endPos\n  };\n}\nfunction getMarkType(nameOrType, schema) {\n  if (typeof nameOrType === 'string') {\n    if (!schema.marks[nameOrType]) {\n      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n    }\n    return schema.marks[nameOrType];\n  }\n  return nameOrType;\n}\nconst extendMarkRange = (typeOrName, attributes = {}) => ({\n  tr,\n  state,\n  dispatch\n}) => {\n  const type = getMarkType(typeOrName, state.schema);\n  const {\n    doc,\n    selection\n  } = tr;\n  const {\n    $from,\n    from,\n    to\n  } = selection;\n  if (dispatch) {\n    const range = getMarkRange($from, type, attributes);\n    if (range && range.from <= from && range.to >= to) {\n      const newSelection = TextSelection.create(doc, range.from, range.to);\n      tr.setSelection(newSelection);\n    }\n  }\n  return true;\n};\nconst first = commands => props => {\n  const items = typeof commands === 'function' ? commands(props) : commands;\n  for (let i = 0; i < items.length; i += 1) {\n    if (items[i](props)) {\n      return true;\n    }\n  }\n  return false;\n};\nfunction isTextSelection(value) {\n  return value instanceof TextSelection;\n}\nfunction minMax(value = 0, min = 0, max = 0) {\n  return Math.min(Math.max(value, min), max);\n}\nfunction resolveFocusPosition(doc, position = null) {\n  if (!position) {\n    return null;\n  }\n  const selectionAtStart = Selection.atStart(doc);\n  const selectionAtEnd = Selection.atEnd(doc);\n  if (position === 'start' || position === true) {\n    return selectionAtStart;\n  }\n  if (position === 'end') {\n    return selectionAtEnd;\n  }\n  const minPos = selectionAtStart.from;\n  const maxPos = selectionAtEnd.to;\n  if (position === 'all') {\n    return TextSelection.create(doc, minMax(0, minPos, maxPos), minMax(doc.content.size, minPos, maxPos));\n  }\n  return TextSelection.create(doc, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));\n}\nfunction isiOS() {\n  return ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].includes(navigator.platform)\n  // iPad on iOS 13 detection\n  || navigator.userAgent.includes('Mac') && 'ontouchend' in document;\n}\nconst focus = (position = null, options = {}) => ({\n  editor,\n  view,\n  tr,\n  dispatch\n}) => {\n  options = {\n    scrollIntoView: true,\n    ...options\n  };\n  const delayedFocus = () => {\n    // focus within `requestAnimationFrame` breaks focus on iOS\n    // so we have to call this\n    if (isiOS()) {\n      view.dom.focus();\n    }\n    // For React we have to focus asynchronously. Otherwise wild things happen.\n    // see: https://github.com/ueberdosis/tiptap/issues/1520\n    requestAnimationFrame(() => {\n      if (!editor.isDestroyed) {\n        view.focus();\n        if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {\n          editor.commands.scrollIntoView();\n        }\n      }\n    });\n  };\n  if (view.hasFocus() && position === null || position === false) {\n    return true;\n  }\n  // we don’t try to resolve a NodeSelection or CellSelection\n  if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\n    delayedFocus();\n    return true;\n  }\n  // pass through tr.doc instead of editor.state.doc\n  // since transactions could change the editors state before this command has been run\n  const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;\n  const isSameSelection = editor.state.selection.eq(selection);\n  if (dispatch) {\n    if (!isSameSelection) {\n      tr.setSelection(selection);\n    }\n    // `tr.setSelection` resets the stored marks\n    // so we’ll restore them if the selection is the same as before\n    if (isSameSelection && tr.storedMarks) {\n      tr.setStoredMarks(tr.storedMarks);\n    }\n    delayedFocus();\n  }\n  return true;\n};\nconst forEach = (items, fn) => props => {\n  return items.every((item, index) => fn(item, {\n    ...props,\n    index\n  }));\n};\nconst insertContent = (value, options) => ({\n  tr,\n  commands\n}) => {\n  return commands.insertContentAt({\n    from: tr.selection.from,\n    to: tr.selection.to\n  }, value, options);\n};\nfunction elementFromString(value) {\n  // add a wrapper to preserve leading and trailing whitespace\n  const wrappedValue = `<body>${value}</body>`;\n  return new window.DOMParser().parseFromString(wrappedValue, 'text/html').body;\n}\nfunction createNodeFromContent(content, schema, options) {\n  options = {\n    slice: true,\n    parseOptions: {},\n    ...options\n  };\n  if (typeof content === 'object' && content !== null) {\n    try {\n      if (Array.isArray(content) && content.length > 0) {\n        return Fragment.fromArray(content.map(item => schema.nodeFromJSON(item)));\n      }\n      return schema.nodeFromJSON(content);\n    } catch (error) {\n      console.warn('[tiptap warn]: Invalid content.', 'Passed value:', content, 'Error:', error);\n      return createNodeFromContent('', schema, options);\n    }\n  }\n  if (typeof content === 'string') {\n    const parser = DOMParser.fromSchema(schema);\n    return options.slice ? parser.parseSlice(elementFromString(content), options.parseOptions).content : parser.parse(elementFromString(content), options.parseOptions);\n  }\n  return createNodeFromContent('', schema, options);\n}\n\n// source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  const last = tr.steps.length - 1;\n  if (last < startLen) {\n    return;\n  }\n  const step = tr.steps[last];\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {\n    return;\n  }\n  const map = tr.mapping.maps[last];\n  let end = 0;\n  map.forEach((_from, _to, _newFrom, newTo) => {\n    if (end === 0) {\n      end = newTo;\n    }\n  });\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n}\nconst isFragment = nodeOrFragment => {\n  return nodeOrFragment.toString().startsWith('<');\n};\nconst insertContentAt = (position, value, options) => ({\n  tr,\n  dispatch,\n  editor\n}) => {\n  if (dispatch) {\n    options = {\n      parseOptions: {},\n      updateSelection: true,\n      ...options\n    };\n    const content = createNodeFromContent(value, editor.schema, {\n      parseOptions: {\n        preserveWhitespace: 'full',\n        ...options.parseOptions\n      }\n    });\n    // don’t dispatch an empty fragment because this can lead to strange errors\n    if (content.toString() === '<>') {\n      return true;\n    }\n    let {\n      from,\n      to\n    } = typeof position === 'number' ? {\n      from: position,\n      to: position\n    } : {\n      from: position.from,\n      to: position.to\n    };\n    let isOnlyTextContent = true;\n    let isOnlyBlockContent = true;\n    const nodes = isFragment(content) ? content : [content];\n    nodes.forEach(node => {\n      // check if added node is valid\n      node.check();\n      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;\n      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;\n    });\n    // check if we can replace the wrapping node by\n    // the newly inserted content\n    // example:\n    // replace an empty paragraph by an inserted image\n    // instead of inserting the image below the paragraph\n    if (from === to && isOnlyBlockContent) {\n      const {\n        parent\n      } = tr.doc.resolve(from);\n      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;\n      if (isEmptyTextBlock) {\n        from -= 1;\n        to += 1;\n      }\n    }\n    // if there is only plain text we have to use `insertText`\n    // because this will keep the current marks\n    if (isOnlyTextContent) {\n      // if value is string, we can use it directly\n      // otherwise if it is an array, we have to join it\n      if (Array.isArray(value)) {\n        tr.insertText(value.map(v => v.text || '').join(''), from, to);\n      } else if (typeof value === 'object' && !!value && !!value.text) {\n        tr.insertText(value.text, from, to);\n      } else {\n        tr.insertText(value, from, to);\n      }\n    } else {\n      tr.replaceWith(from, to, content);\n    }\n    // set cursor at end of inserted content\n    if (options.updateSelection) {\n      selectionToInsertionEnd(tr, tr.steps.length - 1, -1);\n    }\n  }\n  return true;\n};\nconst joinUp = () => ({\n  state,\n  dispatch\n}) => {\n  return joinUp$1(state, dispatch);\n};\nconst joinDown = () => ({\n  state,\n  dispatch\n}) => {\n  return joinDown$1(state, dispatch);\n};\nconst joinBackward = () => ({\n  state,\n  dispatch\n}) => {\n  return joinBackward$1(state, dispatch);\n};\nconst joinForward = () => ({\n  state,\n  dispatch\n}) => {\n  return joinForward$1(state, dispatch);\n};\nconst joinItemBackward = () => ({\n  tr,\n  state,\n  dispatch\n}) => {\n  try {\n    const point = joinPoint(state.doc, state.selection.$from.pos, -1);\n    if (point === null || point === undefined) {\n      return false;\n    }\n    tr.join(point, 2);\n    if (dispatch) {\n      dispatch(tr);\n    }\n    return true;\n  } catch {\n    return false;\n  }\n};\nconst joinItemForward = () => ({\n  state,\n  dispatch,\n  tr\n}) => {\n  try {\n    const point = joinPoint(state.doc, state.selection.$from.pos, +1);\n    if (point === null || point === undefined) {\n      return false;\n    }\n    tr.join(point, 2);\n    if (dispatch) {\n      dispatch(tr);\n    }\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\nfunction isMacOS() {\n  return typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;\n}\nfunction normalizeKeyName(name) {\n  const parts = name.split(/-(?!$)/);\n  let result = parts[parts.length - 1];\n  if (result === 'Space') {\n    result = ' ';\n  }\n  let alt;\n  let ctrl;\n  let shift;\n  let meta;\n  for (let i = 0; i < parts.length - 1; i += 1) {\n    const mod = parts[i];\n    if (/^(cmd|meta|m)$/i.test(mod)) {\n      meta = true;\n    } else if (/^a(lt)?$/i.test(mod)) {\n      alt = true;\n    } else if (/^(c|ctrl|control)$/i.test(mod)) {\n      ctrl = true;\n    } else if (/^s(hift)?$/i.test(mod)) {\n      shift = true;\n    } else if (/^mod$/i.test(mod)) {\n      if (isiOS() || isMacOS()) {\n        meta = true;\n      } else {\n        ctrl = true;\n      }\n    } else {\n      throw new Error(`Unrecognized modifier name: ${mod}`);\n    }\n  }\n  if (alt) {\n    result = `Alt-${result}`;\n  }\n  if (ctrl) {\n    result = `Ctrl-${result}`;\n  }\n  if (meta) {\n    result = `Meta-${result}`;\n  }\n  if (shift) {\n    result = `Shift-${result}`;\n  }\n  return result;\n}\nconst keyboardShortcut = name => ({\n  editor,\n  view,\n  tr,\n  dispatch\n}) => {\n  const keys = normalizeKeyName(name).split(/-(?!$)/);\n  const key = keys.find(item => !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(item));\n  const event = new KeyboardEvent('keydown', {\n    key: key === 'Space' ? ' ' : key,\n    altKey: keys.includes('Alt'),\n    ctrlKey: keys.includes('Ctrl'),\n    metaKey: keys.includes('Meta'),\n    shiftKey: keys.includes('Shift'),\n    bubbles: true,\n    cancelable: true\n  });\n  const capturedTransaction = editor.captureTransaction(() => {\n    view.someProp('handleKeyDown', f => f(view, event));\n  });\n  capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach(step => {\n    const newStep = step.map(tr.mapping);\n    if (newStep && dispatch) {\n      tr.maybeStep(newStep);\n    }\n  });\n  return true;\n};\nfunction isNodeActive(state, typeOrName, attributes = {}) {\n  const {\n    from,\n    to,\n    empty\n  } = state.selection;\n  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;\n  const nodeRanges = [];\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isText) {\n      return;\n    }\n    const relativeFrom = Math.max(from, pos);\n    const relativeTo = Math.min(to, pos + node.nodeSize);\n    nodeRanges.push({\n      node,\n      from: relativeFrom,\n      to: relativeTo\n    });\n  });\n  const selectionRange = to - from;\n  const matchedNodeRanges = nodeRanges.filter(nodeRange => {\n    if (!type) {\n      return true;\n    }\n    return type.name === nodeRange.node.type.name;\n  }).filter(nodeRange => objectIncludes(nodeRange.node.attrs, attributes, {\n    strict: false\n  }));\n  if (empty) {\n    return !!matchedNodeRanges.length;\n  }\n  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);\n  return range >= selectionRange;\n}\nconst lift = (typeOrName, attributes = {}) => ({\n  state,\n  dispatch\n}) => {\n  const type = getNodeType(typeOrName, state.schema);\n  const isActive = isNodeActive(state, type, attributes);\n  if (!isActive) {\n    return false;\n  }\n  return lift$1(state, dispatch);\n};\nconst liftEmptyBlock = () => ({\n  state,\n  dispatch\n}) => {\n  return liftEmptyBlock$1(state, dispatch);\n};\nconst liftListItem = typeOrName => ({\n  state,\n  dispatch\n}) => {\n  const type = getNodeType(typeOrName, state.schema);\n  return liftListItem$1(type)(state, dispatch);\n};\nconst newlineInCode = () => ({\n  state,\n  dispatch\n}) => {\n  return newlineInCode$1(state, dispatch);\n};\nfunction getSchemaTypeNameByName(name, schema) {\n  if (schema.nodes[name]) {\n    return 'node';\n  }\n  if (schema.marks[name]) {\n    return 'mark';\n  }\n  return null;\n}\n\n/**\r\n * Remove a property or an array of properties from an object\r\n * @param obj Object\r\n * @param key Key to remove\r\n */\nfunction deleteProps(obj, propOrProps) {\n  const props = typeof propOrProps === 'string' ? [propOrProps] : propOrProps;\n  return Object.keys(obj).reduce((newObj, prop) => {\n    if (!props.includes(prop)) {\n      newObj[prop] = obj[prop];\n    }\n    return newObj;\n  }, {});\n}\nconst resetAttributes = (typeOrName, attributes) => ({\n  tr,\n  state,\n  dispatch\n}) => {\n  let nodeType = null;\n  let markType = null;\n  const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n  if (!schemaType) {\n    return false;\n  }\n  if (schemaType === 'node') {\n    nodeType = getNodeType(typeOrName, state.schema);\n  }\n  if (schemaType === 'mark') {\n    markType = getMarkType(typeOrName, state.schema);\n  }\n  if (dispatch) {\n    tr.selection.ranges.forEach(range => {\n      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes));\n        }\n        if (markType && node.marks.length) {\n          node.marks.forEach(mark => {\n            if (markType === mark.type) {\n              tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));\n            }\n          });\n        }\n      });\n    });\n  }\n  return true;\n};\nconst scrollIntoView = () => ({\n  tr,\n  dispatch\n}) => {\n  if (dispatch) {\n    tr.scrollIntoView();\n  }\n  return true;\n};\nconst selectAll = () => ({\n  tr,\n  commands\n}) => {\n  return commands.setTextSelection({\n    from: 0,\n    to: tr.doc.content.size\n  });\n};\nconst selectNodeBackward = () => ({\n  state,\n  dispatch\n}) => {\n  return selectNodeBackward$1(state, dispatch);\n};\nconst selectNodeForward = () => ({\n  state,\n  dispatch\n}) => {\n  return selectNodeForward$1(state, dispatch);\n};\nconst selectParentNode = () => ({\n  state,\n  dispatch\n}) => {\n  return selectParentNode$1(state, dispatch);\n};\n\n// @ts-ignore\nconst selectTextblockEnd = () => ({\n  state,\n  dispatch\n}) => {\n  return selectTextblockEnd$1(state, dispatch);\n};\n\n// @ts-ignore\nconst selectTextblockStart = () => ({\n  state,\n  dispatch\n}) => {\n  return selectTextblockStart$1(state, dispatch);\n};\nfunction createDocument(content, schema, parseOptions = {}) {\n  return createNodeFromContent(content, schema, {\n    slice: false,\n    parseOptions\n  });\n}\nconst setContent = (content, emitUpdate = false, parseOptions = {}) => ({\n  tr,\n  editor,\n  dispatch\n}) => {\n  const {\n    doc\n  } = tr;\n  const document = createDocument(content, editor.schema, parseOptions);\n  if (dispatch) {\n    tr.replaceWith(0, doc.content.size, document).setMeta('preventUpdate', !emitUpdate);\n  }\n  return true;\n};\nfunction getMarkAttributes(state, typeOrName) {\n  const type = getMarkType(typeOrName, state.schema);\n  const {\n    from,\n    to,\n    empty\n  } = state.selection;\n  const marks = [];\n  if (empty) {\n    if (state.storedMarks) {\n      marks.push(...state.storedMarks);\n    }\n    marks.push(...state.selection.$head.marks());\n  } else {\n    state.doc.nodesBetween(from, to, node => {\n      marks.push(...node.marks);\n    });\n  }\n  const mark = marks.find(markItem => markItem.type.name === type.name);\n  if (!mark) {\n    return {};\n  }\n  return {\n    ...mark.attrs\n  };\n}\n\n/**\r\n * Returns a new `Transform` based on all steps of the passed transactions.\r\n */\nfunction combineTransactionSteps(oldDoc, transactions) {\n  const transform = new Transform(oldDoc);\n  transactions.forEach(transaction => {\n    transaction.steps.forEach(step => {\n      transform.step(step);\n    });\n  });\n  return transform;\n}\nfunction defaultBlockAt(match) {\n  for (let i = 0; i < match.edgeCount; i += 1) {\n    const {\n      type\n    } = match.edge(i);\n    if (type.isTextblock && !type.hasRequiredAttrs()) {\n      return type;\n    }\n  }\n  return null;\n}\nfunction findChildren(node, predicate) {\n  const nodesWithPos = [];\n  node.descendants((child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos\n      });\n    }\n  });\n  return nodesWithPos;\n}\n\n/**\r\n * Same as `findChildren` but searches only within a `range`.\r\n */\nfunction findChildrenInRange(node, range, predicate) {\n  const nodesWithPos = [];\n  // if (range.from === range.to) {\n  //   const nodeAt = node.nodeAt(range.from)\n  //   if (nodeAt) {\n  //     nodesWithPos.push({\n  //       node: nodeAt,\n  //       pos: range.from,\n  //     })\n  //   }\n  // }\n  node.nodesBetween(range.from, range.to, (child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos\n      });\n    }\n  });\n  return nodesWithPos;\n}\nfunction findParentNodeClosestToPos($pos, predicate) {\n  for (let i = $pos.depth; i > 0; i -= 1) {\n    const node = $pos.node(i);\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node\n      };\n    }\n  }\n}\nfunction findParentNode(predicate) {\n  return selection => findParentNodeClosestToPos(selection.$from, predicate);\n}\nfunction getHTMLFromFragment(fragment, schema) {\n  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);\n  const temporaryDocument = document.implementation.createHTMLDocument();\n  const container = temporaryDocument.createElement('div');\n  container.appendChild(documentFragment);\n  return container.innerHTML;\n}\nfunction getSchema(extensions, editor) {\n  const resolvedExtensions = ExtensionManager.resolve(extensions);\n  return getSchemaByResolvedExtensions(resolvedExtensions, editor);\n}\nfunction generateHTML(doc, extensions) {\n  const schema = getSchema(extensions);\n  const contentNode = Node$1.fromJSON(schema, doc);\n  return getHTMLFromFragment(contentNode.content, schema);\n}\nfunction generateJSON(html, extensions) {\n  const schema = getSchema(extensions);\n  const dom = elementFromString(html);\n  return DOMParser.fromSchema(schema).parse(dom).toJSON();\n}\nfunction getText(node, options) {\n  const range = {\n    from: 0,\n    to: node.content.size\n  };\n  return getTextBetween(node, range, options);\n}\nfunction generateText(doc, extensions, options) {\n  const {\n    blockSeparator = '\\n\\n',\n    textSerializers = {}\n  } = options || {};\n  const schema = getSchema(extensions);\n  const contentNode = Node$1.fromJSON(schema, doc);\n  return getText(contentNode, {\n    blockSeparator,\n    textSerializers: {\n      ...getTextSerializersFromSchema(schema),\n      ...textSerializers\n    }\n  });\n}\nfunction getNodeAttributes(state, typeOrName) {\n  const type = getNodeType(typeOrName, state.schema);\n  const {\n    from,\n    to\n  } = state.selection;\n  const nodes = [];\n  state.doc.nodesBetween(from, to, node => {\n    nodes.push(node);\n  });\n  const node = nodes.reverse().find(nodeItem => nodeItem.type.name === type.name);\n  if (!node) {\n    return {};\n  }\n  return {\n    ...node.attrs\n  };\n}\nfunction getAttributes(state, typeOrName) {\n  const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n  if (schemaType === 'node') {\n    return getNodeAttributes(state, typeOrName);\n  }\n  if (schemaType === 'mark') {\n    return getMarkAttributes(state, typeOrName);\n  }\n  return {};\n}\n\n/**\r\n * Removes duplicated values within an array.\r\n * Supports numbers, strings and objects.\r\n */\nfunction removeDuplicates(array, by = JSON.stringify) {\n  const seen = {};\n  return array.filter(item => {\n    const key = by(item);\n    return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;\n  });\n}\n\n/**\r\n * Removes duplicated ranges and ranges that are\r\n * fully captured by other ranges.\r\n */\nfunction simplifyChangedRanges(changes) {\n  const uniqueChanges = removeDuplicates(changes);\n  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index) => {\n    const rest = uniqueChanges.filter((_, i) => i !== index);\n    return !rest.some(otherChange => {\n      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;\n    });\n  });\n}\n/**\r\n * Returns a list of changed ranges\r\n * based on the first and last state of all steps.\r\n */\nfunction getChangedRanges(transform) {\n  const {\n    mapping,\n    steps\n  } = transform;\n  const changes = [];\n  mapping.maps.forEach((stepMap, index) => {\n    const ranges = [];\n    // This accounts for step changes where no range was actually altered\n    // e.g. when setting a mark, node attribute, etc.\n    // @ts-ignore\n    if (!stepMap.ranges.length) {\n      const {\n        from,\n        to\n      } = steps[index];\n      if (from === undefined || to === undefined) {\n        return;\n      }\n      ranges.push({\n        from,\n        to\n      });\n    } else {\n      stepMap.forEach((from, to) => {\n        ranges.push({\n          from,\n          to\n        });\n      });\n    }\n    ranges.forEach(({\n      from,\n      to\n    }) => {\n      const newStart = mapping.slice(index).map(from, -1);\n      const newEnd = mapping.slice(index).map(to);\n      const oldStart = mapping.invert().map(newStart, -1);\n      const oldEnd = mapping.invert().map(newEnd);\n      changes.push({\n        oldRange: {\n          from: oldStart,\n          to: oldEnd\n        },\n        newRange: {\n          from: newStart,\n          to: newEnd\n        }\n      });\n    });\n  });\n  return simplifyChangedRanges(changes);\n}\nfunction getDebugJSON(node, startOffset = 0) {\n  const isTopNode = node.type === node.type.schema.topNodeType;\n  const increment = isTopNode ? 0 : 1;\n  const from = startOffset;\n  const to = from + node.nodeSize;\n  const marks = node.marks.map(mark => {\n    const output = {\n      type: mark.type.name\n    };\n    if (Object.keys(mark.attrs).length) {\n      output.attrs = {\n        ...mark.attrs\n      };\n    }\n    return output;\n  });\n  const attrs = {\n    ...node.attrs\n  };\n  const output = {\n    type: node.type.name,\n    from,\n    to\n  };\n  if (Object.keys(attrs).length) {\n    output.attrs = attrs;\n  }\n  if (marks.length) {\n    output.marks = marks;\n  }\n  if (node.content.childCount) {\n    output.content = [];\n    node.forEach((child, offset) => {\n      var _a;\n      (_a = output.content) === null || _a === void 0 ? void 0 : _a.push(getDebugJSON(child, startOffset + offset + increment));\n    });\n  }\n  if (node.text) {\n    output.text = node.text;\n  }\n  return output;\n}\nfunction getMarksBetween(from, to, doc) {\n  const marks = [];\n  // get all inclusive marks on empty selection\n  if (from === to) {\n    doc.resolve(from).marks().forEach(mark => {\n      const $pos = doc.resolve(from - 1);\n      const range = getMarkRange($pos, mark.type);\n      if (!range) {\n        return;\n      }\n      marks.push({\n        mark,\n        ...range\n      });\n    });\n  } else {\n    doc.nodesBetween(from, to, (node, pos) => {\n      marks.push(...node.marks.map(mark => ({\n        from: pos,\n        to: pos + node.nodeSize,\n        mark\n      })));\n    });\n  }\n  return marks;\n}\n\n/**\r\n * Finds the first node of a given type or name in the current selection.\r\n * @param state The editor state.\r\n * @param typeOrName The node type or name.\r\n * @param pos The position to start searching from.\r\n * @param maxDepth The maximum depth to search.\r\n * @returns The node and the depth as an array.\r\n */\nconst getNodeAtPosition = (state, typeOrName, pos, maxDepth = 20) => {\n  const $pos = state.doc.resolve(pos);\n  let currentDepth = maxDepth;\n  let node = null;\n  while (currentDepth > 0 && node === null) {\n    const currentNode = $pos.node(currentDepth);\n    if ((currentNode === null || currentNode === void 0 ? void 0 : currentNode.type.name) === typeOrName) {\n      node = currentNode;\n    } else {\n      currentDepth -= 1;\n    }\n  }\n  return [node, currentDepth];\n};\nfunction getSplittedAttributes(extensionAttributes, typeName, attributes) {\n  return Object.fromEntries(Object.entries(attributes).filter(([name]) => {\n    const extensionAttribute = extensionAttributes.find(item => {\n      return item.type === typeName && item.name === name;\n    });\n    if (!extensionAttribute) {\n      return false;\n    }\n    return extensionAttribute.attribute.keepOnSplit;\n  }));\n}\nfunction isMarkActive(state, typeOrName, attributes = {}) {\n  const {\n    empty,\n    ranges\n  } = state.selection;\n  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;\n  if (empty) {\n    return !!(state.storedMarks || state.selection.$from.marks()).filter(mark => {\n      if (!type) {\n        return true;\n      }\n      return type.name === mark.type.name;\n    }).find(mark => objectIncludes(mark.attrs, attributes, {\n      strict: false\n    }));\n  }\n  let selectionRange = 0;\n  const markRanges = [];\n  ranges.forEach(({\n    $from,\n    $to\n  }) => {\n    const from = $from.pos;\n    const to = $to.pos;\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (!node.isText && !node.marks.length) {\n        return;\n      }\n      const relativeFrom = Math.max(from, pos);\n      const relativeTo = Math.min(to, pos + node.nodeSize);\n      const range = relativeTo - relativeFrom;\n      selectionRange += range;\n      markRanges.push(...node.marks.map(mark => ({\n        mark,\n        from: relativeFrom,\n        to: relativeTo\n      })));\n    });\n  });\n  if (selectionRange === 0) {\n    return false;\n  }\n  // calculate range of matched mark\n  const matchedRange = markRanges.filter(markRange => {\n    if (!type) {\n      return true;\n    }\n    return type.name === markRange.mark.type.name;\n  }).filter(markRange => objectIncludes(markRange.mark.attrs, attributes, {\n    strict: false\n  })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);\n  // calculate range of marks that excludes the searched mark\n  // for example `code` doesn’t allow any other marks\n  const excludedRange = markRanges.filter(markRange => {\n    if (!type) {\n      return true;\n    }\n    return markRange.mark.type !== type && markRange.mark.type.excludes(type);\n  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);\n  // we only include the result of `excludedRange`\n  // if there is a match at all\n  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;\n  return range >= selectionRange;\n}\nfunction isActive(state, name, attributes = {}) {\n  if (!name) {\n    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);\n  }\n  const schemaType = getSchemaTypeNameByName(name, state.schema);\n  if (schemaType === 'node') {\n    return isNodeActive(state, name, attributes);\n  }\n  if (schemaType === 'mark') {\n    return isMarkActive(state, name, attributes);\n  }\n  return false;\n}\nconst isAtEndOfNode = (state, nodeType) => {\n  const {\n    $from,\n    $to,\n    $anchor\n  } = state.selection;\n  if (nodeType) {\n    const parentNode = findParentNode(node => node.type.name === nodeType)(state.selection);\n    if (!parentNode) {\n      return false;\n    }\n    const $parentPos = state.doc.resolve(parentNode.pos + 1);\n    if ($anchor.pos + 1 === $parentPos.end()) {\n      return true;\n    }\n    return false;\n  }\n  if ($to.parentOffset < $to.parent.nodeSize - 2 || $from.pos !== $to.pos) {\n    return false;\n  }\n  return true;\n};\nconst isAtStartOfNode = state => {\n  const {\n    $from,\n    $to\n  } = state.selection;\n  if ($from.parentOffset > 0 || $from.pos !== $to.pos) {\n    return false;\n  }\n  return true;\n};\nfunction isList(name, extensions) {\n  const {\n    nodeExtensions\n  } = splitExtensions(extensions);\n  const extension = nodeExtensions.find(item => item.name === name);\n  if (!extension) {\n    return false;\n  }\n  const context = {\n    name: extension.name,\n    options: extension.options,\n    storage: extension.storage\n  };\n  const group = callOrReturn(getExtensionField(extension, 'group', context));\n  if (typeof group !== 'string') {\n    return false;\n  }\n  return group.split(' ').includes('list');\n}\nfunction isNodeEmpty(node) {\n  var _a;\n  const defaultContent = (_a = node.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();\n  const content = node.toJSON();\n  return JSON.stringify(defaultContent) === JSON.stringify(content);\n}\nfunction isNodeSelection(value) {\n  return value instanceof NodeSelection;\n}\nfunction posToDOMRect(view, from, to) {\n  const minPos = 0;\n  const maxPos = view.state.doc.content.size;\n  const resolvedFrom = minMax(from, minPos, maxPos);\n  const resolvedEnd = minMax(to, minPos, maxPos);\n  const start = view.coordsAtPos(resolvedFrom);\n  const end = view.coordsAtPos(resolvedEnd, -1);\n  const top = Math.min(start.top, end.top);\n  const bottom = Math.max(start.bottom, end.bottom);\n  const left = Math.min(start.left, end.left);\n  const right = Math.max(start.right, end.right);\n  const width = right - left;\n  const height = bottom - top;\n  const x = left;\n  const y = top;\n  const data = {\n    top,\n    bottom,\n    left,\n    right,\n    width,\n    height,\n    x,\n    y\n  };\n  return {\n    ...data,\n    toJSON: () => data\n  };\n}\nfunction canSetMark(state, tr, newMarkType) {\n  var _a;\n  const {\n    selection\n  } = tr;\n  let cursor = null;\n  if (isTextSelection(selection)) {\n    cursor = selection.$cursor;\n  }\n  if (cursor) {\n    const currentMarks = (_a = state.storedMarks) !== null && _a !== void 0 ? _a : cursor.marks();\n    // There can be no current marks that exclude the new mark\n    return !!newMarkType.isInSet(currentMarks) || !currentMarks.some(mark => mark.type.excludes(newMarkType));\n  }\n  const {\n    ranges\n  } = selection;\n  return ranges.some(({\n    $from,\n    $to\n  }) => {\n    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;\n    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {\n      // If we already found a mark that we can enable, return false to bypass the remaining search\n      if (someNodeSupportsMark) {\n        return false;\n      }\n      if (node.isInline) {\n        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);\n        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some(otherMark => otherMark.type.excludes(newMarkType));\n        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;\n      }\n      return !someNodeSupportsMark;\n    });\n    return someNodeSupportsMark;\n  });\n}\nconst setMark = (typeOrName, attributes = {}) => ({\n  tr,\n  state,\n  dispatch\n}) => {\n  const {\n    selection\n  } = tr;\n  const {\n    empty,\n    ranges\n  } = selection;\n  const type = getMarkType(typeOrName, state.schema);\n  if (dispatch) {\n    if (empty) {\n      const oldAttributes = getMarkAttributes(state, type);\n      tr.addStoredMark(type.create({\n        ...oldAttributes,\n        ...attributes\n      }));\n    } else {\n      ranges.forEach(range => {\n        const from = range.$from.pos;\n        const to = range.$to.pos;\n        state.doc.nodesBetween(from, to, (node, pos) => {\n          const trimmedFrom = Math.max(pos, from);\n          const trimmedTo = Math.min(pos + node.nodeSize, to);\n          const someHasMark = node.marks.find(mark => mark.type === type);\n          // if there is already a mark of this type\n          // we know that we have to merge its attributes\n          // otherwise we add a fresh new mark\n          if (someHasMark) {\n            node.marks.forEach(mark => {\n              if (type === mark.type) {\n                tr.addMark(trimmedFrom, trimmedTo, type.create({\n                  ...mark.attrs,\n                  ...attributes\n                }));\n              }\n            });\n          } else {\n            tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));\n          }\n        });\n      });\n    }\n  }\n  return canSetMark(state, tr, type);\n};\nconst setMeta = (key, value) => ({\n  tr\n}) => {\n  tr.setMeta(key, value);\n  return true;\n};\nconst setNode = (typeOrName, attributes = {}) => ({\n  state,\n  dispatch,\n  chain\n}) => {\n  const type = getNodeType(typeOrName, state.schema);\n  // TODO: use a fallback like insertContent?\n  if (!type.isTextblock) {\n    console.warn('[tiptap warn]: Currently \"setNode()\" only supports text block nodes.');\n    return false;\n  }\n  return chain()\n  // try to convert node to default node if needed\n  .command(({\n    commands\n  }) => {\n    const canSetBlock = setBlockType(type, attributes)(state);\n    if (canSetBlock) {\n      return true;\n    }\n    return commands.clearNodes();\n  }).command(({\n    state: updatedState\n  }) => {\n    return setBlockType(type, attributes)(updatedState, dispatch);\n  }).run();\n};\nconst setNodeSelection = position => ({\n  tr,\n  dispatch\n}) => {\n  if (dispatch) {\n    const {\n      doc\n    } = tr;\n    const from = minMax(position, 0, doc.content.size);\n    const selection = NodeSelection.create(doc, from);\n    tr.setSelection(selection);\n  }\n  return true;\n};\nconst setTextSelection = position => ({\n  tr,\n  dispatch\n}) => {\n  if (dispatch) {\n    const {\n      doc\n    } = tr;\n    const {\n      from,\n      to\n    } = typeof position === 'number' ? {\n      from: position,\n      to: position\n    } : position;\n    const minPos = TextSelection.atStart(doc).from;\n    const maxPos = TextSelection.atEnd(doc).to;\n    const resolvedFrom = minMax(from, minPos, maxPos);\n    const resolvedEnd = minMax(to, minPos, maxPos);\n    const selection = TextSelection.create(doc, resolvedFrom, resolvedEnd);\n    tr.setSelection(selection);\n  }\n  return true;\n};\nconst sinkListItem = typeOrName => ({\n  state,\n  dispatch\n}) => {\n  const type = getNodeType(typeOrName, state.schema);\n  return sinkListItem$1(type)(state, dispatch);\n};\nfunction ensureMarks(state, splittableMarks) {\n  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n  if (marks) {\n    const filteredMarks = marks.filter(mark => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));\n    state.tr.ensureMarks(filteredMarks);\n  }\n}\nconst splitBlock = ({\n  keepMarks = true\n} = {}) => ({\n  tr,\n  state,\n  dispatch,\n  editor\n}) => {\n  const {\n    selection,\n    doc\n  } = tr;\n  const {\n    $from,\n    $to\n  } = selection;\n  const extensionAttributes = editor.extensionManager.attributes;\n  const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n  if (selection instanceof NodeSelection && selection.node.isBlock) {\n    if (!$from.parentOffset || !canSplit(doc, $from.pos)) {\n      return false;\n    }\n    if (dispatch) {\n      if (keepMarks) {\n        ensureMarks(state, editor.extensionManager.splittableMarks);\n      }\n      tr.split($from.pos).scrollIntoView();\n    }\n    return true;\n  }\n  if (!$from.parent.isBlock) {\n    return false;\n  }\n  if (dispatch) {\n    const atEnd = $to.parentOffset === $to.parent.content.size;\n    if (selection instanceof TextSelection) {\n      tr.deleteSelection();\n    }\n    const deflt = $from.depth === 0 ? undefined : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n    let types = atEnd && deflt ? [{\n      type: deflt,\n      attrs: newAttributes\n    }] : undefined;\n    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);\n    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{\n      type: deflt\n    }] : undefined)) {\n      can = true;\n      types = deflt ? [{\n        type: deflt,\n        attrs: newAttributes\n      }] : undefined;\n    }\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types);\n      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {\n        const first = tr.mapping.map($from.before());\n        const $first = tr.doc.resolve(first);\n        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {\n          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n        }\n      }\n    }\n    if (keepMarks) {\n      ensureMarks(state, editor.extensionManager.splittableMarks);\n    }\n    tr.scrollIntoView();\n  }\n  return true;\n};\nconst splitListItem = typeOrName => ({\n  tr,\n  state,\n  dispatch,\n  editor\n}) => {\n  var _a;\n  const type = getNodeType(typeOrName, state.schema);\n  const {\n    $from,\n    $to\n  } = state.selection;\n  // @ts-ignore\n  // eslint-disable-next-line\n  const node = state.selection.node;\n  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {\n    return false;\n  }\n  const grandParent = $from.node(-1);\n  if (grandParent.type !== type) {\n    return false;\n  }\n  const extensionAttributes = editor.extensionManager.attributes;\n  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n    // In an empty block. If this is a nested list, the wrapping\n    // list item should be split. Otherwise, bail out and let next\n    // command handle lifting.\n    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {\n      return false;\n    }\n    if (dispatch) {\n      let wrap = Fragment.empty;\n      // eslint-disable-next-line\n      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n      // Build a fragment containing empty versions of the structure\n      // from the outer list item to the parent node of the cursor\n      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {\n        wrap = Fragment.from($from.node(d).copy(wrap));\n      }\n      // eslint-disable-next-line\n      const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n      // Add a second list item with an empty default start node\n      const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n      const nextType = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes)) || undefined;\n      wrap = wrap.append(Fragment.from(type.createAndFill(null, nextType) || undefined));\n      const start = $from.before($from.depth - (depthBefore - 1));\n      tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0));\n      let sel = -1;\n      tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {\n        if (sel > -1) {\n          return false;\n        }\n        if (n.isTextblock && n.content.size === 0) {\n          sel = pos + 1;\n        }\n      });\n      if (sel > -1) {\n        tr.setSelection(TextSelection.near(tr.doc.resolve(sel)));\n      }\n      tr.scrollIntoView();\n    }\n    return true;\n  }\n  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n  const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);\n  const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n  tr.delete($from.pos, $to.pos);\n  const types = nextType ? [{\n    type,\n    attrs: newTypeAttributes\n  }, {\n    type: nextType,\n    attrs: newNextTypeAttributes\n  }] : [{\n    type,\n    attrs: newTypeAttributes\n  }];\n  if (!canSplit(tr.doc, $from.pos, 2)) {\n    return false;\n  }\n  if (dispatch) {\n    const {\n      selection,\n      storedMarks\n    } = state;\n    const {\n      splittableMarks\n    } = editor.extensionManager;\n    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n    tr.split($from.pos, 2, types).scrollIntoView();\n    if (!marks || !dispatch) {\n      return true;\n    }\n    const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name));\n    tr.ensureMarks(filteredMarks);\n  }\n  return true;\n};\nconst joinListBackwards = (tr, listType) => {\n  const list = findParentNode(node => node.type === listType)(tr.selection);\n  if (!list) {\n    return true;\n  }\n  const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);\n  if (before === undefined) {\n    return true;\n  }\n  const nodeBefore = tr.doc.nodeAt(before);\n  const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr.doc, list.pos);\n  if (!canJoinBackwards) {\n    return true;\n  }\n  tr.join(list.pos);\n  return true;\n};\nconst joinListForwards = (tr, listType) => {\n  const list = findParentNode(node => node.type === listType)(tr.selection);\n  if (!list) {\n    return true;\n  }\n  const after = tr.doc.resolve(list.start).after(list.depth);\n  if (after === undefined) {\n    return true;\n  }\n  const nodeAfter = tr.doc.nodeAt(after);\n  const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr.doc, after);\n  if (!canJoinForwards) {\n    return true;\n  }\n  tr.join(after);\n  return true;\n};\nconst toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({\n  editor,\n  tr,\n  state,\n  dispatch,\n  chain,\n  commands,\n  can\n}) => {\n  const {\n    extensions,\n    splittableMarks\n  } = editor.extensionManager;\n  const listType = getNodeType(listTypeOrName, state.schema);\n  const itemType = getNodeType(itemTypeOrName, state.schema);\n  const {\n    selection,\n    storedMarks\n  } = state;\n  const {\n    $from,\n    $to\n  } = selection;\n  const range = $from.blockRange($to);\n  const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n  if (!range) {\n    return false;\n  }\n  const parentList = findParentNode(node => isList(node.type.name, extensions))(selection);\n  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n    // remove list\n    if (parentList.node.type === listType) {\n      return commands.liftListItem(itemType);\n    }\n    // change list type\n    if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {\n      return chain().command(() => {\n        tr.setNodeMarkup(parentList.pos, listType);\n        return true;\n      }).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();\n    }\n  }\n  if (!keepMarks || !marks || !dispatch) {\n    return chain()\n    // try to convert node to default node if needed\n    .command(() => {\n      const canWrapInList = can().wrapInList(listType, attributes);\n      if (canWrapInList) {\n        return true;\n      }\n      return commands.clearNodes();\n    }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();\n  }\n  return chain()\n  // try to convert node to default node if needed\n  .command(() => {\n    const canWrapInList = can().wrapInList(listType, attributes);\n    const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name));\n    tr.ensureMarks(filteredMarks);\n    if (canWrapInList) {\n      return true;\n    }\n    return commands.clearNodes();\n  }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();\n};\nconst toggleMark = (typeOrName, attributes = {}, options = {}) => ({\n  state,\n  commands\n}) => {\n  const {\n    extendEmptyMarkRange = false\n  } = options;\n  const type = getMarkType(typeOrName, state.schema);\n  const isActive = isMarkActive(state, type, attributes);\n  if (isActive) {\n    return commands.unsetMark(type, {\n      extendEmptyMarkRange\n    });\n  }\n  return commands.setMark(type, attributes);\n};\nconst toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({\n  state,\n  commands\n}) => {\n  const type = getNodeType(typeOrName, state.schema);\n  const toggleType = getNodeType(toggleTypeOrName, state.schema);\n  const isActive = isNodeActive(state, type, attributes);\n  if (isActive) {\n    return commands.setNode(toggleType);\n  }\n  return commands.setNode(type, attributes);\n};\nconst toggleWrap = (typeOrName, attributes = {}) => ({\n  state,\n  commands\n}) => {\n  const type = getNodeType(typeOrName, state.schema);\n  const isActive = isNodeActive(state, type, attributes);\n  if (isActive) {\n    return commands.lift(type);\n  }\n  return commands.wrapIn(type, attributes);\n};\nconst undoInputRule = () => ({\n  state,\n  dispatch\n}) => {\n  const plugins = state.plugins;\n  for (let i = 0; i < plugins.length; i += 1) {\n    const plugin = plugins[i];\n    let undoable;\n    // @ts-ignore\n    // eslint-disable-next-line\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        const tr = state.tr;\n        const toUndo = undoable.transform;\n        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {\n          tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n        }\n        if (undoable.text) {\n          const marks = tr.doc.resolve(undoable.from).marks();\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n        } else {\n          tr.delete(undoable.from, undoable.to);\n        }\n      }\n      return true;\n    }\n  }\n  return false;\n};\nconst unsetAllMarks = () => ({\n  tr,\n  dispatch\n}) => {\n  const {\n    selection\n  } = tr;\n  const {\n    empty,\n    ranges\n  } = selection;\n  if (empty) {\n    return true;\n  }\n  if (dispatch) {\n    ranges.forEach(range => {\n      tr.removeMark(range.$from.pos, range.$to.pos);\n    });\n  }\n  return true;\n};\nconst unsetMark = (typeOrName, options = {}) => ({\n  tr,\n  state,\n  dispatch\n}) => {\n  var _a;\n  const {\n    extendEmptyMarkRange = false\n  } = options;\n  const {\n    selection\n  } = tr;\n  const type = getMarkType(typeOrName, state.schema);\n  const {\n    $from,\n    empty,\n    ranges\n  } = selection;\n  if (!dispatch) {\n    return true;\n  }\n  if (empty && extendEmptyMarkRange) {\n    let {\n      from,\n      to\n    } = selection;\n    const attrs = (_a = $from.marks().find(mark => mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;\n    const range = getMarkRange($from, type, attrs);\n    if (range) {\n      from = range.from;\n      to = range.to;\n    }\n    tr.removeMark(from, to, type);\n  } else {\n    ranges.forEach(range => {\n      tr.removeMark(range.$from.pos, range.$to.pos, type);\n    });\n  }\n  tr.removeStoredMark(type);\n  return true;\n};\nconst updateAttributes = (typeOrName, attributes = {}) => ({\n  tr,\n  state,\n  dispatch\n}) => {\n  let nodeType = null;\n  let markType = null;\n  const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n  if (!schemaType) {\n    return false;\n  }\n  if (schemaType === 'node') {\n    nodeType = getNodeType(typeOrName, state.schema);\n  }\n  if (schemaType === 'mark') {\n    markType = getMarkType(typeOrName, state.schema);\n  }\n  if (dispatch) {\n    tr.selection.ranges.forEach(range => {\n      const from = range.$from.pos;\n      const to = range.$to.pos;\n      state.doc.nodesBetween(from, to, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, undefined, {\n            ...node.attrs,\n            ...attributes\n          });\n        }\n        if (markType && node.marks.length) {\n          node.marks.forEach(mark => {\n            if (markType === mark.type) {\n              const trimmedFrom = Math.max(pos, from);\n              const trimmedTo = Math.min(pos + node.nodeSize, to);\n              tr.addMark(trimmedFrom, trimmedTo, markType.create({\n                ...mark.attrs,\n                ...attributes\n              }));\n            }\n          });\n        }\n      });\n    });\n  }\n  return true;\n};\nconst wrapIn = (typeOrName, attributes = {}) => ({\n  state,\n  dispatch\n}) => {\n  const type = getNodeType(typeOrName, state.schema);\n  return wrapIn$1(type, attributes)(state, dispatch);\n};\nconst wrapInList = (typeOrName, attributes = {}) => ({\n  state,\n  dispatch\n}) => {\n  const type = getNodeType(typeOrName, state.schema);\n  return wrapInList$1(type, attributes)(state, dispatch);\n};\nvar commands = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  blur: blur,\n  clearContent: clearContent,\n  clearNodes: clearNodes,\n  command: command,\n  createParagraphNear: createParagraphNear,\n  cut: cut,\n  deleteCurrentNode: deleteCurrentNode,\n  deleteNode: deleteNode,\n  deleteRange: deleteRange,\n  deleteSelection: deleteSelection,\n  enter: enter,\n  exitCode: exitCode,\n  extendMarkRange: extendMarkRange,\n  first: first,\n  focus: focus,\n  forEach: forEach,\n  insertContent: insertContent,\n  insertContentAt: insertContentAt,\n  joinUp: joinUp,\n  joinDown: joinDown,\n  joinBackward: joinBackward,\n  joinForward: joinForward,\n  joinItemBackward: joinItemBackward,\n  joinItemForward: joinItemForward,\n  keyboardShortcut: keyboardShortcut,\n  lift: lift,\n  liftEmptyBlock: liftEmptyBlock,\n  liftListItem: liftListItem,\n  newlineInCode: newlineInCode,\n  resetAttributes: resetAttributes,\n  scrollIntoView: scrollIntoView,\n  selectAll: selectAll,\n  selectNodeBackward: selectNodeBackward,\n  selectNodeForward: selectNodeForward,\n  selectParentNode: selectParentNode,\n  selectTextblockEnd: selectTextblockEnd,\n  selectTextblockStart: selectTextblockStart,\n  setContent: setContent,\n  setMark: setMark,\n  setMeta: setMeta,\n  setNode: setNode,\n  setNodeSelection: setNodeSelection,\n  setTextSelection: setTextSelection,\n  sinkListItem: sinkListItem,\n  splitBlock: splitBlock,\n  splitListItem: splitListItem,\n  toggleList: toggleList,\n  toggleMark: toggleMark,\n  toggleNode: toggleNode,\n  toggleWrap: toggleWrap,\n  undoInputRule: undoInputRule,\n  unsetAllMarks: unsetAllMarks,\n  unsetMark: unsetMark,\n  updateAttributes: updateAttributes,\n  wrapIn: wrapIn,\n  wrapInList: wrapInList\n});\nconst Commands = Extension.create({\n  name: 'commands',\n  addCommands() {\n    return {\n      ...commands\n    };\n  }\n});\nconst Editable = Extension.create({\n  name: 'editable',\n  addProseMirrorPlugins() {\n    return [new Plugin({\n      key: new PluginKey('editable'),\n      props: {\n        editable: () => this.editor.options.editable\n      }\n    })];\n  }\n});\nconst FocusEvents = Extension.create({\n  name: 'focusEvents',\n  addProseMirrorPlugins() {\n    const {\n      editor\n    } = this;\n    return [new Plugin({\n      key: new PluginKey('focusEvents'),\n      props: {\n        handleDOMEvents: {\n          focus: (view, event) => {\n            editor.isFocused = true;\n            const transaction = editor.state.tr.setMeta('focus', {\n              event\n            }).setMeta('addToHistory', false);\n            view.dispatch(transaction);\n            return false;\n          },\n          blur: (view, event) => {\n            editor.isFocused = false;\n            const transaction = editor.state.tr.setMeta('blur', {\n              event\n            }).setMeta('addToHistory', false);\n            view.dispatch(transaction);\n            return false;\n          }\n        }\n      }\n    })];\n  }\n});\nconst Keymap = Extension.create({\n  name: 'keymap',\n  addKeyboardShortcuts() {\n    const handleBackspace = () => this.editor.commands.first(({\n      commands\n    }) => [() => commands.undoInputRule(),\n    // maybe convert first text block node to default node\n    () => commands.command(({\n      tr\n    }) => {\n      const {\n        selection,\n        doc\n      } = tr;\n      const {\n        empty,\n        $anchor\n      } = selection;\n      const {\n        pos,\n        parent\n      } = $anchor;\n      const $parentPos = $anchor.parent.isTextblock ? tr.doc.resolve(pos - 1) : $anchor;\n      const parentIsIsolating = $parentPos.parent.type.spec.isolating;\n      const parentPos = $anchor.pos - $anchor.parentOffset;\n      const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc).from === pos;\n      if (!empty || !isAtStart || !parent.type.isTextblock || parent.textContent.length) {\n        return false;\n      }\n      return commands.clearNodes();\n    }), () => commands.deleteSelection(), () => commands.joinBackward(), () => commands.selectNodeBackward()]);\n    const handleDelete = () => this.editor.commands.first(({\n      commands\n    }) => [() => commands.deleteSelection(), () => commands.deleteCurrentNode(), () => commands.joinForward(), () => commands.selectNodeForward()]);\n    const handleEnter = () => this.editor.commands.first(({\n      commands\n    }) => [() => commands.newlineInCode(), () => commands.createParagraphNear(), () => commands.liftEmptyBlock(), () => commands.splitBlock()]);\n    const baseKeymap = {\n      Enter: handleEnter,\n      'Mod-Enter': () => this.editor.commands.exitCode(),\n      Backspace: handleBackspace,\n      'Mod-Backspace': handleBackspace,\n      'Shift-Backspace': handleBackspace,\n      Delete: handleDelete,\n      'Mod-Delete': handleDelete,\n      'Mod-a': () => this.editor.commands.selectAll()\n    };\n    const pcKeymap = {\n      ...baseKeymap\n    };\n    const macKeymap = {\n      ...baseKeymap,\n      'Ctrl-h': handleBackspace,\n      'Alt-Backspace': handleBackspace,\n      'Ctrl-d': handleDelete,\n      'Ctrl-Alt-Backspace': handleDelete,\n      'Alt-Delete': handleDelete,\n      'Alt-d': handleDelete,\n      'Ctrl-a': () => this.editor.commands.selectTextblockStart(),\n      'Ctrl-e': () => this.editor.commands.selectTextblockEnd()\n    };\n    if (isiOS() || isMacOS()) {\n      return macKeymap;\n    }\n    return pcKeymap;\n  },\n  addProseMirrorPlugins() {\n    return [\n    // With this plugin we check if the whole document was selected and deleted.\n    // In this case we will additionally call `clearNodes()` to convert e.g. a heading\n    // to a paragraph if necessary.\n    // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well\n    // with many other commands.\n    new Plugin({\n      key: new PluginKey('clearDocument'),\n      appendTransaction: (transactions, oldState, newState) => {\n        const docChanges = transactions.some(transaction => transaction.docChanged) && !oldState.doc.eq(newState.doc);\n        if (!docChanges) {\n          return;\n        }\n        const {\n          empty,\n          from,\n          to\n        } = oldState.selection;\n        const allFrom = Selection.atStart(oldState.doc).from;\n        const allEnd = Selection.atEnd(oldState.doc).to;\n        const allWasSelected = from === allFrom && to === allEnd;\n        if (empty || !allWasSelected) {\n          return;\n        }\n        const isEmpty = newState.doc.textBetween(0, newState.doc.content.size, ' ', ' ').length === 0;\n        if (!isEmpty) {\n          return;\n        }\n        const tr = newState.tr;\n        const state = createChainableState({\n          state: newState,\n          transaction: tr\n        });\n        const {\n          commands\n        } = new CommandManager({\n          editor: this.editor,\n          state\n        });\n        commands.clearNodes();\n        if (!tr.steps.length) {\n          return;\n        }\n        return tr;\n      }\n    })];\n  }\n});\nconst Tabindex = Extension.create({\n  name: 'tabindex',\n  addProseMirrorPlugins() {\n    return [new Plugin({\n      key: new PluginKey('tabindex'),\n      props: {\n        attributes: this.editor.isEditable ? {\n          tabindex: '0'\n        } : {}\n      }\n    })];\n  }\n});\nvar extensions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ClipboardTextSerializer: ClipboardTextSerializer,\n  Commands: Commands,\n  Editable: Editable,\n  FocusEvents: FocusEvents,\n  Keymap: Keymap,\n  Tabindex: Tabindex\n});\nconst style = `.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: \"liga\" 0; /* the above doesn't seem to work in Edge */\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 1px !important;\n  height: 1px !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}`;\nfunction createStyleTag(style, nonce, suffix) {\n  const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : ''}]`);\n  if (tiptapStyleTag !== null) {\n    return tiptapStyleTag;\n  }\n  const styleNode = document.createElement('style');\n  if (nonce) {\n    styleNode.setAttribute('nonce', nonce);\n  }\n  styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : ''}`, '');\n  styleNode.innerHTML = style;\n  document.getElementsByTagName('head')[0].appendChild(styleNode);\n  return styleNode;\n}\nclass Editor extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    this.isFocused = false;\n    this.extensionStorage = {};\n    this.options = {\n      element: document.createElement('div'),\n      content: '',\n      injectCSS: true,\n      injectNonce: undefined,\n      extensions: [],\n      autofocus: false,\n      editable: true,\n      editorProps: {},\n      parseOptions: {},\n      enableInputRules: true,\n      enablePasteRules: true,\n      enableCoreExtensions: true,\n      onBeforeCreate: () => null,\n      onCreate: () => null,\n      onUpdate: () => null,\n      onSelectionUpdate: () => null,\n      onTransaction: () => null,\n      onFocus: () => null,\n      onBlur: () => null,\n      onDestroy: () => null\n    };\n    this.isCapturingTransaction = false;\n    this.capturedTransaction = null;\n    this.setOptions(options);\n    this.createExtensionManager();\n    this.createCommandManager();\n    this.createSchema();\n    this.on('beforeCreate', this.options.onBeforeCreate);\n    this.emit('beforeCreate', {\n      editor: this\n    });\n    this.createView();\n    this.injectCSS();\n    this.on('create', this.options.onCreate);\n    this.on('update', this.options.onUpdate);\n    this.on('selectionUpdate', this.options.onSelectionUpdate);\n    this.on('transaction', this.options.onTransaction);\n    this.on('focus', this.options.onFocus);\n    this.on('blur', this.options.onBlur);\n    this.on('destroy', this.options.onDestroy);\n    window.setTimeout(() => {\n      if (this.isDestroyed) {\n        return;\n      }\n      this.commands.focus(this.options.autofocus);\n      this.emit('create', {\n        editor: this\n      });\n    }, 0);\n  }\n  /**\r\n   * Returns the editor storage.\r\n   */\n  get storage() {\n    return this.extensionStorage;\n  }\n  /**\r\n   * An object of all registered commands.\r\n   */\n  get commands() {\n    return this.commandManager.commands;\n  }\n  /**\r\n   * Create a command chain to call multiple commands at once.\r\n   */\n  chain() {\n    return this.commandManager.chain();\n  }\n  /**\r\n   * Check if a command or a command chain can be executed. Without executing it.\r\n   */\n  can() {\n    return this.commandManager.can();\n  }\n  /**\r\n   * Inject CSS styles.\r\n   */\n  injectCSS() {\n    if (this.options.injectCSS && document) {\n      this.css = createStyleTag(style, this.options.injectNonce);\n    }\n  }\n  /**\r\n   * Update editor options.\r\n   *\r\n   * @param options A list of options\r\n   */\n  setOptions(options = {}) {\n    this.options = {\n      ...this.options,\n      ...options\n    };\n    if (!this.view || !this.state || this.isDestroyed) {\n      return;\n    }\n    if (this.options.editorProps) {\n      this.view.setProps(this.options.editorProps);\n    }\n    this.view.updateState(this.state);\n  }\n  /**\r\n   * Update editable state of the editor.\r\n   */\n  setEditable(editable, emitUpdate = true) {\n    this.setOptions({\n      editable\n    });\n    if (emitUpdate) {\n      this.emit('update', {\n        editor: this,\n        transaction: this.state.tr\n      });\n    }\n  }\n  /**\r\n   * Returns whether the editor is editable.\r\n   */\n  get isEditable() {\n    // since plugins are applied after creating the view\n    // `editable` is always `true` for one tick.\n    // that’s why we also have to check for `options.editable`\n    return this.options.editable && this.view && this.view.editable;\n  }\n  /**\r\n   * Returns the editor state.\r\n   */\n  get state() {\n    return this.view.state;\n  }\n  /**\r\n   * Register a ProseMirror plugin.\r\n   *\r\n   * @param plugin A ProseMirror plugin\r\n   * @param handlePlugins Control how to merge the plugin into the existing plugins.\r\n   */\n  registerPlugin(plugin, handlePlugins) {\n    const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];\n    const state = this.state.reconfigure({\n      plugins\n    });\n    this.view.updateState(state);\n  }\n  /**\r\n   * Unregister a ProseMirror plugin.\r\n   *\r\n   * @param nameOrPluginKey The plugins name\r\n   */\n  unregisterPlugin(nameOrPluginKey) {\n    if (this.isDestroyed) {\n      return;\n    }\n    // @ts-ignore\n    const name = typeof nameOrPluginKey === 'string' ? `${nameOrPluginKey}$` : nameOrPluginKey.key;\n    const state = this.state.reconfigure({\n      // @ts-ignore\n      plugins: this.state.plugins.filter(plugin => !plugin.key.startsWith(name))\n    });\n    this.view.updateState(state);\n  }\n  /**\r\n   * Creates an extension manager.\r\n   */\n  createExtensionManager() {\n    const coreExtensions = this.options.enableCoreExtensions ? Object.values(extensions) : [];\n    const allExtensions = [...coreExtensions, ...this.options.extensions].filter(extension => {\n      return ['extension', 'node', 'mark'].includes(extension === null || extension === void 0 ? void 0 : extension.type);\n    });\n    this.extensionManager = new ExtensionManager(allExtensions, this);\n  }\n  /**\r\n   * Creates an command manager.\r\n   */\n  createCommandManager() {\n    this.commandManager = new CommandManager({\n      editor: this\n    });\n  }\n  /**\r\n   * Creates a ProseMirror schema.\r\n   */\n  createSchema() {\n    this.schema = this.extensionManager.schema;\n  }\n  /**\r\n   * Creates a ProseMirror view.\r\n   */\n  createView() {\n    const doc = createDocument(this.options.content, this.schema, this.options.parseOptions);\n    const selection = resolveFocusPosition(doc, this.options.autofocus);\n    this.view = new EditorView(this.options.element, {\n      ...this.options.editorProps,\n      dispatchTransaction: this.dispatchTransaction.bind(this),\n      state: EditorState.create({\n        doc,\n        selection: selection || undefined\n      })\n    });\n    // `editor.view` is not yet available at this time.\n    // Therefore we will add all plugins and node views directly afterwards.\n    const newState = this.state.reconfigure({\n      plugins: this.extensionManager.plugins\n    });\n    this.view.updateState(newState);\n    this.createNodeViews();\n    this.prependClass();\n    // Let’s store the editor instance in the DOM element.\n    // So we’ll have access to it for tests.\n    const dom = this.view.dom;\n    dom.editor = this;\n  }\n  /**\r\n   * Creates all node views.\r\n   */\n  createNodeViews() {\n    this.view.setProps({\n      nodeViews: this.extensionManager.nodeViews\n    });\n  }\n  /**\r\n   * Prepend class name to element.\r\n   */\n  prependClass() {\n    this.view.dom.className = `tiptap ${this.view.dom.className}`;\n  }\n  captureTransaction(fn) {\n    this.isCapturingTransaction = true;\n    fn();\n    this.isCapturingTransaction = false;\n    const tr = this.capturedTransaction;\n    this.capturedTransaction = null;\n    return tr;\n  }\n  /**\r\n   * The callback over which to send transactions (state updates) produced by the view.\r\n   *\r\n   * @param transaction An editor state transaction\r\n   */\n  dispatchTransaction(transaction) {\n    // if the editor / the view of the editor was destroyed\n    // the transaction should not be dispatched as there is no view anymore.\n    if (this.view.isDestroyed) {\n      return;\n    }\n    if (this.isCapturingTransaction) {\n      if (!this.capturedTransaction) {\n        this.capturedTransaction = transaction;\n        return;\n      }\n      transaction.steps.forEach(step => {\n        var _a;\n        return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step);\n      });\n      return;\n    }\n    const state = this.state.apply(transaction);\n    const selectionHasChanged = !this.state.selection.eq(state.selection);\n    this.view.updateState(state);\n    this.emit('transaction', {\n      editor: this,\n      transaction\n    });\n    if (selectionHasChanged) {\n      this.emit('selectionUpdate', {\n        editor: this,\n        transaction\n      });\n    }\n    const focus = transaction.getMeta('focus');\n    const blur = transaction.getMeta('blur');\n    if (focus) {\n      this.emit('focus', {\n        editor: this,\n        event: focus.event,\n        transaction\n      });\n    }\n    if (blur) {\n      this.emit('blur', {\n        editor: this,\n        event: blur.event,\n        transaction\n      });\n    }\n    if (!transaction.docChanged || transaction.getMeta('preventUpdate')) {\n      return;\n    }\n    this.emit('update', {\n      editor: this,\n      transaction\n    });\n  }\n  /**\r\n   * Get attributes of the currently selected node or mark.\r\n   */\n  getAttributes(nameOrType) {\n    return getAttributes(this.state, nameOrType);\n  }\n  isActive(nameOrAttributes, attributesOrUndefined) {\n    const name = typeof nameOrAttributes === 'string' ? nameOrAttributes : null;\n    const attributes = typeof nameOrAttributes === 'string' ? attributesOrUndefined : nameOrAttributes;\n    return isActive(this.state, name, attributes);\n  }\n  /**\r\n   * Get the document as JSON.\r\n   */\n  getJSON() {\n    return this.state.doc.toJSON();\n  }\n  /**\r\n   * Get the document as HTML.\r\n   */\n  getHTML() {\n    return getHTMLFromFragment(this.state.doc.content, this.schema);\n  }\n  /**\r\n   * Get the document as text.\r\n   */\n  getText(options) {\n    const {\n      blockSeparator = '\\n\\n',\n      textSerializers = {}\n    } = options || {};\n    return getText(this.state.doc, {\n      blockSeparator,\n      textSerializers: {\n        ...getTextSerializersFromSchema(this.schema),\n        ...textSerializers\n      }\n    });\n  }\n  /**\r\n   * Check if there is no content.\r\n   */\n  get isEmpty() {\n    return isNodeEmpty(this.state.doc);\n  }\n  /**\r\n   * Get the number of characters for the current document.\r\n   *\r\n   * @deprecated\r\n   */\n  getCharacterCount() {\n    console.warn('[tiptap warn]: \"editor.getCharacterCount()\" is deprecated. Please use \"editor.storage.characterCount.characters()\" instead.');\n    return this.state.doc.content.size - 2;\n  }\n  /**\r\n   * Destroy the editor.\r\n   */\n  destroy() {\n    this.emit('destroy');\n    if (this.view) {\n      this.view.destroy();\n    }\n    this.removeAllListeners();\n  }\n  /**\r\n   * Check if the editor is already destroyed.\r\n   */\n  get isDestroyed() {\n    var _a;\n    // @ts-ignore\n    return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);\n  }\n}\n\n/**\r\n * Build an input rule that adds a mark when the\r\n * matched text is typed into it.\r\n */\nfunction markInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({\n      state,\n      range,\n      match\n    }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match);\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n      const {\n        tr\n      } = state;\n      const captureGroup = match[match.length - 1];\n      const fullMatch = match[0];\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/);\n        const textStart = range.from + fullMatch.indexOf(captureGroup);\n        const textEnd = textStart + captureGroup.length;\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter(item => {\n          // @ts-ignore\n          const excluded = item.mark.type.excluded;\n          return excluded.find(type => type === config.type && type !== item.mark.type);\n        }).filter(item => item.to > textStart);\n        if (excludedMarks.length) {\n          return null;\n        }\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to);\n        }\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart);\n        }\n        const markEnd = range.from + startSpaces + captureGroup.length;\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n        tr.removeStoredMark(config.type);\n      }\n    }\n  });\n}\n\n/**\r\n * Build an input rule that adds a node when the\r\n * matched text is typed into it.\r\n */\nfunction nodeInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({\n      state,\n      range,\n      match\n    }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n      const {\n        tr\n      } = state;\n      const start = range.from;\n      let end = range.to;\n      const newNode = config.type.create(attributes);\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        let matchStart = start + offset;\n        if (matchStart > end) {\n          matchStart = end;\n        } else {\n          end = matchStart + match[1].length;\n        }\n        // insert last typed character\n        const lastChar = match[0][match[0].length - 1];\n        tr.insertText(lastChar, start + match[0].length - 1);\n        // insert node from input rule\n        tr.replaceWith(matchStart, end, newNode);\n      } else if (match[0]) {\n        tr.insert(start - 1, config.type.create(attributes)).delete(tr.mapping.map(start), tr.mapping.map(end));\n      }\n      tr.scrollIntoView();\n    }\n  });\n}\n\n/**\r\n * Build an input rule that changes the type of a textblock when the\r\n * matched text is typed into it. When using a regular expresion you’ll\r\n * probably want the regexp to start with `^`, so that the pattern can\r\n * only occur at the start of a textblock.\r\n */\nfunction textblockTypeInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({\n      state,\n      range,\n      match\n    }) => {\n      const $start = state.doc.resolve(range.from);\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {\n        return null;\n      }\n      state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);\n    }\n  });\n}\n\n/**\r\n * Build an input rule that replaces text when the\r\n * matched text is typed into it.\r\n */\nfunction textInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({\n      state,\n      range,\n      match\n    }) => {\n      let insert = config.replace;\n      let start = range.from;\n      const end = range.to;\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        insert += match[0].slice(offset + match[1].length);\n        start += offset;\n        const cutOff = start - end;\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert;\n          start = end;\n        }\n      }\n      state.tr.insertText(insert, start, end);\n    }\n  });\n}\n\n/**\r\n * Build an input rule for automatically wrapping a textblock when a\r\n * given string is typed. When using a regular expresion you’ll\r\n * probably want the regexp to start with `^`, so that the pattern can\r\n * only occur at the start of a textblock.\r\n *\r\n * `type` is the type of node to wrap in.\r\n *\r\n * By default, if there’s a node with the same type above the newly\r\n * wrapped node, the rule will try to join those\r\n * two nodes. You can pass a join predicate, which takes a regular\r\n * expression match and the node before the wrapped node, and can\r\n * return a boolean to indicate whether a join should happen.\r\n */\nfunction wrappingInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({\n      state,\n      range,\n      match,\n      chain\n    }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n      const tr = state.tr.delete(range.from, range.to);\n      const $start = tr.doc.resolve(range.from);\n      const blockRange = $start.blockRange();\n      const wrapping = blockRange && findWrapping(blockRange, config.type, attributes);\n      if (!wrapping) {\n        return null;\n      }\n      tr.wrap(blockRange, wrapping);\n      if (config.keepMarks && config.editor) {\n        const {\n          selection,\n          storedMarks\n        } = state;\n        const {\n          splittableMarks\n        } = config.editor.extensionManager;\n        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n        if (marks) {\n          const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name));\n          tr.ensureMarks(filteredMarks);\n        }\n      }\n      if (config.keepAttributes) {\n        /** If the nodeType is `bulletList` or `orderedList` set the `nodeType` as `listItem` */\n        const nodeType = config.type.name === 'bulletList' || config.type.name === 'orderedList' ? 'listItem' : 'taskList';\n        chain().updateAttributes(nodeType, attributes).run();\n      }\n      const before = tr.doc.resolve(range.from - 1).nodeBefore;\n      if (before && before.type === config.type && canJoin(tr.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {\n        tr.join(range.from - 1);\n      }\n    }\n  });\n}\nclass Mark {\n  constructor(config = {}) {\n    this.type = 'mark';\n    this.name = 'mark';\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = {\n      ...this.config,\n      ...config\n    };\n    this.name = this.config.name;\n    if (config.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n    }\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions;\n    if (this.config.addOptions) {\n      this.options = callOrReturn(getExtensionField(this, 'addOptions', {\n        name: this.name\n      }));\n    }\n    this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\n      name: this.name,\n      options: this.options\n    })) || {};\n  }\n  static create(config = {}) {\n    return new Mark(config);\n  }\n  configure(options = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend();\n    extension.options = mergeDeep(this.options, options);\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n  extend(extendedConfig = {}) {\n    const extension = new Mark(extendedConfig);\n    extension.parent = this;\n    this.child = extension;\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n    if (extendedConfig.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n    }\n    extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\n      name: extension.name\n    }));\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n  static handleExit({\n    editor,\n    mark\n  }) {\n    const {\n      tr\n    } = editor.state;\n    const currentPos = editor.state.selection.$from;\n    const isAtEnd = currentPos.pos === currentPos.end();\n    if (isAtEnd) {\n      const currentMarks = currentPos.marks();\n      const isInMark = !!currentMarks.find(m => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);\n      if (!isInMark) {\n        return false;\n      }\n      const removeMark = currentMarks.find(m => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);\n      if (removeMark) {\n        tr.removeStoredMark(removeMark);\n      }\n      tr.insertText(' ', currentPos.pos);\n      editor.view.dispatch(tr);\n      return true;\n    }\n    return false;\n  }\n}\nclass Node {\n  constructor(config = {}) {\n    this.type = 'node';\n    this.name = 'node';\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = {\n      ...this.config,\n      ...config\n    };\n    this.name = this.config.name;\n    if (config.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n    }\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions;\n    if (this.config.addOptions) {\n      this.options = callOrReturn(getExtensionField(this, 'addOptions', {\n        name: this.name\n      }));\n    }\n    this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\n      name: this.name,\n      options: this.options\n    })) || {};\n  }\n  static create(config = {}) {\n    return new Node(config);\n  }\n  configure(options = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend();\n    extension.options = mergeDeep(this.options, options);\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n  extend(extendedConfig = {}) {\n    const extension = new Node(extendedConfig);\n    extension.parent = this;\n    this.child = extension;\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n    if (extendedConfig.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n    }\n    extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\n      name: extension.name\n    }));\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n}\nfunction isAndroid() {\n  return navigator.platform === 'Android' || /android/i.test(navigator.userAgent);\n}\nclass NodeView {\n  constructor(component, props, options) {\n    this.isDragging = false;\n    this.component = component;\n    this.editor = props.editor;\n    this.options = {\n      stopEvent: null,\n      ignoreMutation: null,\n      ...options\n    };\n    this.extension = props.extension;\n    this.node = props.node;\n    this.decorations = props.decorations;\n    this.getPos = props.getPos;\n    this.mount();\n  }\n  mount() {\n    // eslint-disable-next-line\n    return;\n  }\n  get dom() {\n    return this.editor.view.dom;\n  }\n  get contentDOM() {\n    return null;\n  }\n  onDragStart(event) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const {\n      view\n    } = this.editor;\n    const target = event.target;\n    // get the drag handle element\n    // `closest` is not available for text nodes so we may have to use its parent\n    const dragHandle = target.nodeType === 3 ? (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.closest('[data-drag-handle]') : target.closest('[data-drag-handle]');\n    if (!this.dom || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target)) || !dragHandle) {\n      return;\n    }\n    let x = 0;\n    let y = 0;\n    // calculate offset for drag element if we use a different drag handle element\n    if (this.dom !== dragHandle) {\n      const domBox = this.dom.getBoundingClientRect();\n      const handleBox = dragHandle.getBoundingClientRect();\n      // In React, we have to go through nativeEvent to reach offsetX/offsetY.\n      const offsetX = (_c = event.offsetX) !== null && _c !== void 0 ? _c : (_d = event.nativeEvent) === null || _d === void 0 ? void 0 : _d.offsetX;\n      const offsetY = (_e = event.offsetY) !== null && _e !== void 0 ? _e : (_f = event.nativeEvent) === null || _f === void 0 ? void 0 : _f.offsetY;\n      x = handleBox.x - domBox.x + offsetX;\n      y = handleBox.y - domBox.y + offsetY;\n    }\n    (_g = event.dataTransfer) === null || _g === void 0 ? void 0 : _g.setDragImage(this.dom, x, y);\n    // we need to tell ProseMirror that we want to move the whole node\n    // so we create a NodeSelection\n    const selection = NodeSelection.create(view.state.doc, this.getPos());\n    const transaction = view.state.tr.setSelection(selection);\n    view.dispatch(transaction);\n  }\n  stopEvent(event) {\n    var _a;\n    if (!this.dom) {\n      return false;\n    }\n    if (typeof this.options.stopEvent === 'function') {\n      return this.options.stopEvent({\n        event\n      });\n    }\n    const target = event.target;\n    const isInElement = this.dom.contains(target) && !((_a = this.contentDOM) === null || _a === void 0 ? void 0 : _a.contains(target));\n    // any event from child nodes should be handled by ProseMirror\n    if (!isInElement) {\n      return false;\n    }\n    const isDragEvent = event.type.startsWith('drag');\n    const isDropEvent = event.type === 'drop';\n    const isInput = ['INPUT', 'BUTTON', 'SELECT', 'TEXTAREA'].includes(target.tagName) || target.isContentEditable;\n    // any input event within node views should be ignored by ProseMirror\n    if (isInput && !isDropEvent && !isDragEvent) {\n      return true;\n    }\n    const {\n      isEditable\n    } = this.editor;\n    const {\n      isDragging\n    } = this;\n    const isDraggable = !!this.node.type.spec.draggable;\n    const isSelectable = NodeSelection.isSelectable(this.node);\n    const isCopyEvent = event.type === 'copy';\n    const isPasteEvent = event.type === 'paste';\n    const isCutEvent = event.type === 'cut';\n    const isClickEvent = event.type === 'mousedown';\n    // ProseMirror tries to drag selectable nodes\n    // even if `draggable` is set to `false`\n    // this fix prevents that\n    if (!isDraggable && isSelectable && isDragEvent) {\n      event.preventDefault();\n    }\n    if (isDraggable && isDragEvent && !isDragging) {\n      event.preventDefault();\n      return false;\n    }\n    // we have to store that dragging started\n    if (isDraggable && isEditable && !isDragging && isClickEvent) {\n      const dragHandle = target.closest('[data-drag-handle]');\n      const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));\n      if (isValidDragHandle) {\n        this.isDragging = true;\n        document.addEventListener('dragend', () => {\n          this.isDragging = false;\n        }, {\n          once: true\n        });\n        document.addEventListener('drop', () => {\n          this.isDragging = false;\n        }, {\n          once: true\n        });\n        document.addEventListener('mouseup', () => {\n          this.isDragging = false;\n        }, {\n          once: true\n        });\n      }\n    }\n    // these events are handled by prosemirror\n    if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {\n      return false;\n    }\n    return true;\n  }\n  ignoreMutation(mutation) {\n    if (!this.dom || !this.contentDOM) {\n      return true;\n    }\n    if (typeof this.options.ignoreMutation === 'function') {\n      return this.options.ignoreMutation({\n        mutation\n      });\n    }\n    // a leaf/atom node is like a black box for ProseMirror\n    // and should be fully handled by the node view\n    if (this.node.isLeaf || this.node.isAtom) {\n      return true;\n    }\n    // ProseMirror should handle any selections\n    if (mutation.type === 'selection') {\n      return false;\n    }\n    // try to prevent a bug on iOS and Android that will break node views on enter\n    // this is because ProseMirror can’t preventDispatch on enter\n    // this will lead to a re-render of the node view on enter\n    // see: https://github.com/ueberdosis/tiptap/issues/1214\n    // see: https://github.com/ueberdosis/tiptap/issues/2534\n    if (this.dom.contains(mutation.target) && mutation.type === 'childList' && (isiOS() || isAndroid()) && this.editor.isFocused) {\n      const changedNodes = [...Array.from(mutation.addedNodes), ...Array.from(mutation.removedNodes)];\n      // we’ll check if every changed node is contentEditable\n      // to make sure it’s probably mutated by ProseMirror\n      if (changedNodes.every(node => node.isContentEditable)) {\n        return false;\n      }\n    }\n    // we will allow mutation contentDOM with attributes\n    // so we can for example adding classes within our node view\n    if (this.contentDOM === mutation.target && mutation.type === 'attributes') {\n      return true;\n    }\n    // ProseMirror should handle any changes within contentDOM\n    if (this.contentDOM.contains(mutation.target)) {\n      return false;\n    }\n    return true;\n  }\n  updateAttributes(attributes) {\n    this.editor.commands.command(({\n      tr\n    }) => {\n      const pos = this.getPos();\n      tr.setNodeMarkup(pos, undefined, {\n        ...this.node.attrs,\n        ...attributes\n      });\n      return true;\n    });\n  }\n  deleteNode() {\n    const from = this.getPos();\n    const to = from + this.node.nodeSize;\n    this.editor.commands.deleteRange({\n      from,\n      to\n    });\n  }\n}\n\n/**\r\n * Build an paste rule that adds a mark when the\r\n * matched text is pasted into it.\r\n */\nfunction markPasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler: ({\n      state,\n      range,\n      match,\n      pasteEvent\n    }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match, pasteEvent);\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n      const {\n        tr\n      } = state;\n      const captureGroup = match[match.length - 1];\n      const fullMatch = match[0];\n      let markEnd = range.to;\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/);\n        const textStart = range.from + fullMatch.indexOf(captureGroup);\n        const textEnd = textStart + captureGroup.length;\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter(item => {\n          // @ts-ignore\n          const excluded = item.mark.type.excluded;\n          return excluded.find(type => type === config.type && type !== item.mark.type);\n        }).filter(item => item.to > textStart);\n        if (excludedMarks.length) {\n          return null;\n        }\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to);\n        }\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart);\n        }\n        markEnd = range.from + startSpaces + captureGroup.length;\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n        tr.removeStoredMark(config.type);\n      }\n    }\n  });\n}\n\n// source: https://stackoverflow.com/a/6969486\nfunction escapeForRegEx(string) {\n  return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\n/**\r\n * Build an paste rule that adds a node when the\r\n * matched text is pasted into it.\r\n */\nfunction nodePasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler({\n      match,\n      chain,\n      range,\n      pasteEvent\n    }) {\n      const attributes = callOrReturn(config.getAttributes, undefined, match, pasteEvent);\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n      if (match.input) {\n        chain().deleteRange(range).insertContentAt(range.from, {\n          type: config.type.name,\n          attrs: attributes\n        });\n      }\n    }\n  });\n}\n\n/**\r\n * Build an paste rule that replaces text when the\r\n * matched text is pasted into it.\r\n */\nfunction textPasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler: ({\n      state,\n      range,\n      match\n    }) => {\n      let insert = config.replace;\n      let start = range.from;\n      const end = range.to;\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        insert += match[0].slice(offset + match[1].length);\n        start += offset;\n        const cutOff = start - end;\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert;\n          start = end;\n        }\n      }\n      state.tr.insertText(insert, start, end);\n    }\n  });\n}\nclass Tracker {\n  constructor(transaction) {\n    this.transaction = transaction;\n    this.currentStep = this.transaction.steps.length;\n  }\n  map(position) {\n    let deleted = false;\n    const mappedPosition = this.transaction.steps.slice(this.currentStep).reduce((newPosition, step) => {\n      const mapResult = step.getMap().mapResult(newPosition);\n      if (mapResult.deleted) {\n        deleted = true;\n      }\n      return mapResult.pos;\n    }, position);\n    return {\n      position: mappedPosition,\n      deleted\n    };\n  }\n}\nexport { CommandManager, Editor, Extension, InputRule, Mark, Node, NodeView, PasteRule, Tracker, callOrReturn, combineTransactionSteps, createChainableState, createDocument, createNodeFromContent, createStyleTag, defaultBlockAt, deleteProps, elementFromString, escapeForRegEx, extensions, findChildren, findChildrenInRange, findDuplicates, findParentNode, findParentNodeClosestToPos, fromString, generateHTML, generateJSON, generateText, getAttributes, getAttributesFromExtensions, getChangedRanges, getDebugJSON, getExtensionField, getHTMLFromFragment, getMarkAttributes, getMarkRange, getMarkType, getMarksBetween, getNodeAtPosition, getNodeAttributes, getNodeType, getRenderedAttributes, getSchema, getSchemaByResolvedExtensions, getSchemaTypeByName, getSchemaTypeNameByName, getSplittedAttributes, getText, getTextBetween, getTextContentFromNodes, getTextSerializersFromSchema, injectExtensionAttributesToParseRule, inputRulesPlugin, isActive, isAtEndOfNode, isAtStartOfNode, isEmptyObject, isExtensionRulesEnabled, isFunction, isList, isMacOS, isMarkActive, isNodeActive, isNodeEmpty, isNodeSelection, isNumber, isPlainObject, isRegExp, isString, isTextSelection, isiOS, markInputRule, markPasteRule, mergeAttributes, mergeDeep, minMax, nodeInputRule, nodePasteRule, objectIncludes, pasteRulesPlugin, posToDOMRect, removeDuplicates, resolveFocusPosition, selectionToInsertionEnd, splitExtensions, textInputRule, textPasteRule, textblockTypeInputRule, wrappingInputRule };","map":{"version":3,"names":["createChainableState","config","state","transaction","selection","doc","storedMarks","apply","bind","applyTransaction","filterTransaction","plugins","schema","reconfigure","toJSON","tr","CommandManager","constructor","props","editor","rawCommands","extensionManager","commands","customState","hasCustomState","view","buildProps","Object","fromEntries","entries","map","name","command","method","args","callback","getMeta","dispatch","chain","createChain","can","createCan","startTr","shouldDispatch","callbacks","hasStartTransaction","run","every","chainedCommand","push","formattedCommands","undefined","EventEmitter","on","event","fn","emit","forEach","off","filter","removeAllListeners","getExtensionField","extension","field","context","parent","value","splitExtensions","extensions","baseExtensions","type","nodeExtensions","markExtensions","getAttributesFromExtensions","extensionAttributes","nodeAndMarkExtensions","defaultAttribute","default","rendered","renderHTML","parseHTML","keepOnSplit","isRequired","options","storage","addGlobalAttributes","globalAttributes","globalAttribute","types","attributes","attribute","addAttributes","mergedAttr","getNodeType","nameOrType","nodes","Error","mergeAttributes","objects","item","reduce","items","mergedAttributes","key","exists","valueClasses","split","existingClasses","insertClasses","valueClass","includes","join","getRenderedAttributes","nodeOrMark","attrs","isFunction","callOrReturn","isEmptyObject","keys","length","fromString","match","Number","injectExtensionAttributesToParseRule","parseRule","style","getAttrs","node","oldAttributes","newAttributes","getAttribute","cleanUpSchemaItem","data","getSchemaByResolvedExtensions","allAttributes","topNode","_a","find","extraNodeFields","fields","e","extendNodeSchema","content","marks","group","inline","atom","selectable","draggable","code","defining","isolating","extensionAttribute","parseDOM","toDOM","HTMLAttributes","renderText","toText","extraMarkFields","extendMarkSchema","inclusive","excludes","spanning","mark","Schema","getSchemaTypeByName","isExtensionRulesEnabled","enabled","Array","isArray","some","enabledExtension","getTextContentFromNodes","$from","maxMatch","textBefore","sliceEndPos","parentOffset","nodesBetween","Math","max","pos","index","chunk","_b","spec","call","textContent","slice","isRegExp","prototype","toString","InputRule","handler","inputRuleMatcherHandler","text","exec","inputRuleMatch","result","input","replaceWith","console","warn","run$1","from","to","rules","plugin","composing","resolve","nodeBefore","nodeAfter","matched","rule","range","steps","setMeta","transform","inputRulesPlugin","Plugin","init","prev","stored","selectionSet","docChanged","handleTextInput","handleDOMEvents","compositionend","setTimeout","$cursor","handleKeyDown","isInputRules","isNumber","PasteRule","pasteRuleMatcherHandler","matchAll","matches","pasteRuleMatch","pasteEvent","dropEvent","handlers","isTextblock","resolvedFrom","resolvedTo","min","size","textToMatch","textBetween","start","end","mapping","success","pasteRulesPlugin","dragSourceElement","isPastedFromProseMirror","isDroppedFromProseMirror","ClipboardEvent","DragEvent","handleDragstart","dom","parentElement","contains","target","window","addEventListener","destroy","removeEventListener","drop","paste","_view","html","clipboardData","getData","appendTransaction","transactions","oldState","isPaste","isDrop","findDiffStart","findDiffEnd","b","chainableState","findDuplicates","filtered","el","indexOf","Set","ExtensionManager","splittableMarks","extensionStorage","onBeforeCreate","onCreate","onUpdate","onSelectionUpdate","onTransaction","onFocus","onBlur","onDestroy","resolvedExtensions","sort","flatten","duplicatedNames","addExtensions","flat","defaultPriority","a","priorityA","priorityB","addCommands","reverse","inputRules","pasteRules","allPlugins","addKeyboardShortcuts","defaultBindings","exitable","ArrowRight","Mark","handleExit","bindings","shortcut","keyMapPlugin","keymap","addInputRules","enableInputRules","addPasteRules","enablePasteRules","addProseMirrorPlugins","proseMirrorPlugins","nodeViews","addNodeView","nodeview","getPos","decorations","getType","isPlainObject","getPrototypeOf","mergeDeep","source","output","assign","Extension","child","defaultOptions","addOptions","create","configure","extend","extendedConfig","getTextBetween","startNode","blockSeparator","textSerializers","separated","textSerializer","isBlock","isText","getTextSerializersFromSchema","ClipboardTextSerializer","PluginKey","clipboardTextSerializer","ranges","$to","blur","requestAnimationFrame","isDestroyed","getSelection","removeAllRanges","clearContent","emitUpdate","setContent","clearNodes","$mappedFrom","$mappedTo","nodeSize","nodeRange","blockRange","targetLiftDepth","liftTarget","defaultType","contentMatchAt","setNodeMarkup","lift","createParagraphNear","createParagraphNear$1","cut","originRange","targetPos","contentSlice","deleteRange","newPos","insert","setSelection","TextSelection","deleteCurrentNode","currentNode","$anchor","$pos","depth","before","after","delete","scrollIntoView","deleteNode","typeOrName","deleteSelection","deleteSelection$1","enter","keyboardShortcut","exitCode","exitCode$1","objectIncludes","object1","object2","strict","test","findMarkInSet","isMarkInSet","getMarkRange","childAfter","offset","childBefore","startIndex","startPos","endIndex","endPos","isInSet","childCount","getMarkType","extendMarkRange","newSelection","first","i","isTextSelection","minMax","resolveFocusPosition","position","selectionAtStart","Selection","atStart","selectionAtEnd","atEnd","minPos","maxPos","isiOS","navigator","platform","userAgent","document","focus","delayedFocus","hasFocus","isSameSelection","eq","setStoredMarks","insertContent","insertContentAt","elementFromString","wrappedValue","DOMParser","parseFromString","body","createNodeFromContent","parseOptions","Fragment","fromArray","nodeFromJSON","error","parser","fromSchema","parseSlice","parse","selectionToInsertionEnd","startLen","bias","last","step","ReplaceStep","ReplaceAroundStep","maps","_from","_to","_newFrom","newTo","near","isFragment","nodeOrFragment","startsWith","updateSelection","preserveWhitespace","isOnlyTextContent","isOnlyBlockContent","check","isEmptyTextBlock","insertText","v","joinUp","joinUp$1","joinDown","joinDown$1","joinBackward","joinBackward$1","joinForward","joinForward$1","joinItemBackward","point","joinPoint","joinItemForward","isMacOS","normalizeKeyName","parts","alt","ctrl","shift","meta","mod","KeyboardEvent","altKey","ctrlKey","metaKey","shiftKey","bubbles","cancelable","capturedTransaction","captureTransaction","someProp","f","newStep","maybeStep","isNodeActive","empty","nodeRanges","relativeFrom","relativeTo","selectionRange","matchedNodeRanges","sum","isActive","lift$1","liftEmptyBlock","liftEmptyBlock$1","liftListItem","liftListItem$1","newlineInCode","newlineInCode$1","getSchemaTypeNameByName","deleteProps","obj","propOrProps","newObj","prop","resetAttributes","nodeType","markType","schemaType","addMark","selectAll","setTextSelection","selectNodeBackward","selectNodeBackward$1","selectNodeForward","selectNodeForward$1","selectParentNode","selectParentNode$1","selectTextblockEnd","selectTextblockEnd$1","selectTextblockStart","selectTextblockStart$1","createDocument","getMarkAttributes","$head","markItem","combineTransactionSteps","oldDoc","Transform","defaultBlockAt","edgeCount","edge","hasRequiredAttrs","findChildren","predicate","nodesWithPos","descendants","findChildrenInRange","findParentNodeClosestToPos","findParentNode","getHTMLFromFragment","fragment","documentFragment","DOMSerializer","serializeFragment","temporaryDocument","implementation","createHTMLDocument","container","createElement","appendChild","innerHTML","getSchema","generateHTML","contentNode","Node$1","fromJSON","generateJSON","getText","generateText","getNodeAttributes","nodeItem","getAttributes","removeDuplicates","array","by","JSON","stringify","seen","hasOwnProperty","simplifyChangedRanges","changes","uniqueChanges","change","rest","_","otherChange","oldRange","newRange","getChangedRanges","stepMap","newStart","newEnd","oldStart","invert","oldEnd","getDebugJSON","startOffset","isTopNode","topNodeType","increment","getMarksBetween","getNodeAtPosition","maxDepth","currentDepth","getSplittedAttributes","typeName","isMarkActive","markRanges","matchedRange","markRange","excludedRange","isAtEndOfNode","parentNode","$parentPos","isAtStartOfNode","isList","isNodeEmpty","defaultContent","createAndFill","isNodeSelection","NodeSelection","posToDOMRect","resolvedEnd","coordsAtPos","top","bottom","left","right","width","height","x","y","canSetMark","newMarkType","cursor","currentMarks","someNodeSupportsMark","inlineContent","allowsMarkType","_pos","isInline","parentAllowsMarkType","currentMarksAllowMarkType","otherMark","setMark","addStoredMark","trimmedFrom","trimmedTo","someHasMark","setNode","canSetBlock","setBlockType","updatedState","setNodeSelection","sinkListItem","sinkListItem$1","ensureMarks","filteredMarks","splitBlock","keepMarks","canSplit","deflt","indexAfter","$first","canReplaceWith","splitListItem","sameParent","grandParent","wrap","depthBefore","d","copy","depthAfter","newNextTypeAttributes","nextType","contentMatch","append","replace","Slice","sel","n","newTypeAttributes","joinListBackwards","listType","list","nodeAt","canJoinBackwards","canJoin","joinListForwards","canJoinForwards","toggleList","listTypeOrName","itemTypeOrName","itemType","parentList","validContent","canWrapInList","wrapInList","toggleMark","extendEmptyMarkRange","unsetMark","toggleNode","toggleTypeOrName","toggleType","toggleWrap","wrapIn","undoInputRule","undoable","getState","toUndo","j","docs","unsetAllMarks","removeMark","removeStoredMark","updateAttributes","wrapIn$1","wrapInList$1","Commands","Editable","editable","FocusEvents","isFocused","Keymap","handleBackspace","parentIsIsolating","parentPos","isAtStart","handleDelete","handleEnter","baseKeymap","Enter","Mod-Enter","Backspace","Delete","Mod-a","pcKeymap","macKeymap","Ctrl-a","Ctrl-e","newState","docChanges","allFrom","allEnd","allWasSelected","isEmpty","Tabindex","isEditable","tabindex","createStyleTag","nonce","suffix","tiptapStyleTag","querySelector","styleNode","setAttribute","getElementsByTagName","Editor","element","injectCSS","injectNonce","autofocus","editorProps","enableCoreExtensions","isCapturingTransaction","setOptions","createExtensionManager","createCommandManager","createSchema","createView","commandManager","css","setProps","updateState","setEditable","registerPlugin","handlePlugins","unregisterPlugin","nameOrPluginKey","coreExtensions","values","allExtensions","EditorView","dispatchTransaction","EditorState","createNodeViews","prependClass","className","selectionHasChanged","nameOrAttributes","attributesOrUndefined","getJSON","getHTML","getCharacterCount","docView","markInputRule","captureGroup","fullMatch","startSpaces","search","textStart","textEnd","excludedMarks","excluded","markEnd","nodeInputRule","newNode","lastIndexOf","matchStart","lastChar","textblockTypeInputRule","$start","textInputRule","cutOff","wrappingInputRule","wrapping","findWrapping","keepAttributes","joinPredicate","currentPos","isAtEnd","isInMark","m","Node","isAndroid","NodeView","component","isDragging","stopEvent","ignoreMutation","mount","contentDOM","onDragStart","dragHandle","closest","domBox","getBoundingClientRect","handleBox","offsetX","_c","_d","nativeEvent","offsetY","_e","_f","_g","dataTransfer","setDragImage","isInElement","isDragEvent","isDropEvent","isInput","tagName","isContentEditable","isDraggable","isSelectable","isCopyEvent","isPasteEvent","isCutEvent","isClickEvent","preventDefault","isValidDragHandle","once","mutation","isLeaf","isAtom","changedNodes","addedNodes","removedNodes","markPasteRule","escapeForRegEx","string","isString","nodePasteRule","textPasteRule","Tracker","currentStep","deleted","mappedPosition","newPosition","mapResult","getMap"],"sources":["/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/createChainableState.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/CommandManager.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/EventEmitter.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getExtensionField.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/splitExtensions.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getAttributesFromExtensions.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getNodeType.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/mergeAttributes.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getRenderedAttributes.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/isFunction.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/callOrReturn.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/isEmptyObject.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/fromString.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/injectExtensionAttributesToParseRule.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getSchemaByResolvedExtensions.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getSchemaTypeByName.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/isExtensionRulesEnabled.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getTextContentFromNodes.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/isRegExp.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/InputRule.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/isNumber.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/PasteRule.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/findDuplicates.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/ExtensionManager.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/isPlainObject.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/mergeDeep.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/Extension.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getTextBetween.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getTextSerializersFromSchema.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/extensions/clipboardTextSerializer.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/blur.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/clearContent.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/clearNodes.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/command.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/createParagraphNear.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/cut.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/deleteCurrentNode.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/deleteNode.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/deleteRange.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/deleteSelection.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/enter.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/exitCode.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/objectIncludes.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getMarkRange.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getMarkType.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/extendMarkRange.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/first.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/isTextSelection.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/minMax.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/resolveFocusPosition.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/isiOS.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/focus.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/forEach.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/insertContent.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/elementFromString.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/createNodeFromContent.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/selectionToInsertionEnd.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/insertContentAt.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/join.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/joinItemBackward.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/joinItemForward.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/isMacOS.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/keyboardShortcut.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/isNodeActive.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/lift.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/liftEmptyBlock.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/liftListItem.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/newlineInCode.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getSchemaTypeNameByName.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/deleteProps.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/resetAttributes.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/scrollIntoView.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/selectAll.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/selectNodeBackward.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/selectNodeForward.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/selectParentNode.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/selectTextblockEnd.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/selectTextblockStart.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/createDocument.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/setContent.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getMarkAttributes.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/combineTransactionSteps.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/defaultBlockAt.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/findChildren.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/findChildrenInRange.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/findParentNodeClosestToPos.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/findParentNode.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getHTMLFromFragment.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getSchema.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/generateHTML.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/generateJSON.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getText.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/generateText.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getNodeAttributes.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getAttributes.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/removeDuplicates.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getChangedRanges.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getDebugJSON.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getMarksBetween.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getNodeAtPosition.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getSplittedAttributes.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/isMarkActive.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/isActive.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/isAtEndOfNode.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/isAtStartOfNode.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/isList.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/isNodeEmpty.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/isNodeSelection.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/posToDOMRect.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/setMark.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/setMeta.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/setNode.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/setNodeSelection.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/setTextSelection.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/sinkListItem.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/splitBlock.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/splitListItem.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/toggleList.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/toggleMark.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/toggleNode.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/toggleWrap.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/undoInputRule.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/unsetAllMarks.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/unsetMark.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/updateAttributes.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/wrapIn.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/wrapInList.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/extensions/commands.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/extensions/editable.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/extensions/focusEvents.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/extensions/keymap.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/extensions/tabindex.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/style.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/createStyleTag.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/Editor.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/inputRules/markInputRule.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/inputRules/nodeInputRule.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/inputRules/textblockTypeInputRule.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/inputRules/textInputRule.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/inputRules/wrappingInputRule.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/Mark.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/Node.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/isAndroid.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/NodeView.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/pasteRules/markPasteRule.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/escapeForRegEx.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/isString.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/pasteRules/nodePasteRule.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/pasteRules/textPasteRule.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/Tracker.ts"],"sourcesContent":["import { EditorState, Transaction } from '@tiptap/pm/state'\n\nexport function createChainableState(config: {\n  transaction: Transaction\n  state: EditorState\n}): EditorState {\n  const { state, transaction } = config\n  let { selection } = transaction\n  let { doc } = transaction\n  let { storedMarks } = transaction\n\n  return {\n    ...state,\n    apply: state.apply.bind(state),\n    applyTransaction: state.applyTransaction.bind(state),\n    filterTransaction: state.filterTransaction,\n    plugins: state.plugins,\n    schema: state.schema,\n    reconfigure: state.reconfigure.bind(state),\n    toJSON: state.toJSON.bind(state),\n    get storedMarks() {\n      return storedMarks\n    },\n    get selection() {\n      return selection\n    },\n    get doc() {\n      return doc\n    },\n    get tr() {\n      selection = transaction.selection\n      doc = transaction.doc\n      storedMarks = transaction.storedMarks\n\n      return transaction\n    },\n  }\n}\n","import { EditorState, Transaction } from '@tiptap/pm/state'\n\nimport { Editor } from './Editor.js'\nimport { createChainableState } from './helpers/createChainableState.js'\nimport {\n  AnyCommands, CanCommands, ChainedCommands, CommandProps, SingleCommands,\n} from './types.js'\n\nexport class CommandManager {\n  editor: Editor\n\n  rawCommands: AnyCommands\n\n  customState?: EditorState\n\n  constructor(props: { editor: Editor; state?: EditorState }) {\n    this.editor = props.editor\n    this.rawCommands = this.editor.extensionManager.commands\n    this.customState = props.state\n  }\n\n  get hasCustomState(): boolean {\n    return !!this.customState\n  }\n\n  get state(): EditorState {\n    return this.customState || this.editor.state\n  }\n\n  get commands(): SingleCommands {\n    const { rawCommands, editor, state } = this\n    const { view } = editor\n    const { tr } = state\n    const props = this.buildProps(tr)\n\n    return Object.fromEntries(\n      Object.entries(rawCommands).map(([name, command]) => {\n        const method = (...args: any[]) => {\n          const callback = command(...args)(props)\n\n          if (!tr.getMeta('preventDispatch') && !this.hasCustomState) {\n            view.dispatch(tr)\n          }\n\n          return callback\n        }\n\n        return [name, method]\n      }),\n    ) as unknown as SingleCommands\n  }\n\n  get chain(): () => ChainedCommands {\n    return () => this.createChain()\n  }\n\n  get can(): () => CanCommands {\n    return () => this.createCan()\n  }\n\n  public createChain(startTr?: Transaction, shouldDispatch = true): ChainedCommands {\n    const { rawCommands, editor, state } = this\n    const { view } = editor\n    const callbacks: boolean[] = []\n    const hasStartTransaction = !!startTr\n    const tr = startTr || state.tr\n\n    const run = () => {\n      if (\n        !hasStartTransaction\n        && shouldDispatch\n        && !tr.getMeta('preventDispatch')\n        && !this.hasCustomState\n      ) {\n        view.dispatch(tr)\n      }\n\n      return callbacks.every(callback => callback === true)\n    }\n\n    const chain = {\n      ...Object.fromEntries(\n        Object.entries(rawCommands).map(([name, command]) => {\n          const chainedCommand = (...args: never[]) => {\n            const props = this.buildProps(tr, shouldDispatch)\n            const callback = command(...args)(props)\n\n            callbacks.push(callback)\n\n            return chain\n          }\n\n          return [name, chainedCommand]\n        }),\n      ),\n      run,\n    } as unknown as ChainedCommands\n\n    return chain\n  }\n\n  public createCan(startTr?: Transaction): CanCommands {\n    const { rawCommands, state } = this\n    const dispatch = false\n    const tr = startTr || state.tr\n    const props = this.buildProps(tr, dispatch)\n    const formattedCommands = Object.fromEntries(\n      Object.entries(rawCommands).map(([name, command]) => {\n        return [name, (...args: never[]) => command(...args)({ ...props, dispatch: undefined })]\n      }),\n    ) as unknown as SingleCommands\n\n    return {\n      ...formattedCommands,\n      chain: () => this.createChain(tr, dispatch),\n    } as CanCommands\n  }\n\n  public buildProps(tr: Transaction, shouldDispatch = true): CommandProps {\n    const { rawCommands, editor, state } = this\n    const { view } = editor\n\n    const props: CommandProps = {\n      tr,\n      editor,\n      view,\n      state: createChainableState({\n        state,\n        transaction: tr,\n      }),\n      dispatch: shouldDispatch ? () => undefined : undefined,\n      chain: () => this.createChain(tr, shouldDispatch),\n      can: () => this.createCan(tr),\n      get commands() {\n        return Object.fromEntries(\n          Object.entries(rawCommands).map(([name, command]) => {\n            return [name, (...args: never[]) => command(...args)(props)]\n          }),\n        ) as unknown as SingleCommands\n      },\n    }\n\n    return props\n  }\n}\n","type StringKeyOf<T> = Extract<keyof T, string>\ntype CallbackType<\n  T extends Record<string, any>,\n  EventName extends StringKeyOf<T>,\n> = T[EventName] extends any[] ? T[EventName] : [T[EventName]]\ntype CallbackFunction<\n  T extends Record<string, any>,\n  EventName extends StringKeyOf<T>,\n> = (...props: CallbackType<T, EventName>) => any\n\nexport class EventEmitter<T extends Record<string, any>> {\n\n  private callbacks: { [key: string]: Function[] } = {}\n\n  public on<EventName extends StringKeyOf<T>>(event: EventName, fn: CallbackFunction<T, EventName>): this {\n    if (!this.callbacks[event]) {\n      this.callbacks[event] = []\n    }\n\n    this.callbacks[event].push(fn)\n\n    return this\n  }\n\n  protected emit<EventName extends StringKeyOf<T>>(event: EventName, ...args: CallbackType<T, EventName>): this {\n    const callbacks = this.callbacks[event]\n\n    if (callbacks) {\n      callbacks.forEach(callback => callback.apply(this, args))\n    }\n\n    return this\n  }\n\n  public off<EventName extends StringKeyOf<T>>(event: EventName, fn?: CallbackFunction<T, EventName>): this {\n    const callbacks = this.callbacks[event]\n\n    if (callbacks) {\n      if (fn) {\n        this.callbacks[event] = callbacks.filter(callback => callback !== fn)\n      } else {\n        delete this.callbacks[event]\n      }\n    }\n\n    return this\n  }\n\n  protected removeAllListeners(): void {\n    this.callbacks = {}\n  }\n}\n","import { AnyExtension, MaybeThisParameterType, RemoveThis } from '../types.js'\n\nexport function getExtensionField<T = any>(\n  extension: AnyExtension,\n  field: string,\n  context?: Omit<MaybeThisParameterType<T>, 'parent'>,\n): RemoveThis<T> {\n\n  if (extension.config[field] === undefined && extension.parent) {\n    return getExtensionField(extension.parent, field, context)\n  }\n\n  if (typeof extension.config[field] === 'function') {\n    const value = extension.config[field].bind({\n      ...context,\n      parent: extension.parent\n        ? getExtensionField(extension.parent, field, context)\n        : null,\n    })\n\n    return value\n  }\n\n  return extension.config[field]\n}\n","import { Extension } from '../Extension.js'\nimport { Mark } from '../Mark.js'\nimport { Node } from '../Node.js'\nimport { Extensions } from '../types.js'\n\nexport function splitExtensions(extensions: Extensions) {\n  const baseExtensions = extensions.filter(extension => extension.type === 'extension') as Extension[]\n  const nodeExtensions = extensions.filter(extension => extension.type === 'node') as Node[]\n  const markExtensions = extensions.filter(extension => extension.type === 'mark') as Mark[]\n\n  return {\n    baseExtensions,\n    nodeExtensions,\n    markExtensions,\n  }\n}\n","import { MarkConfig, NodeConfig } from '../index.js'\nimport {\n  AnyConfig,\n  Attribute,\n  Attributes,\n  ExtensionAttribute,\n  Extensions,\n  GlobalAttributes,\n} from '../types.js'\nimport { getExtensionField } from './getExtensionField.js'\nimport { splitExtensions } from './splitExtensions.js'\n\n/**\n * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.\n * @param extensions List of extensions\n */\nexport function getAttributesFromExtensions(extensions: Extensions): ExtensionAttribute[] {\n  const extensionAttributes: ExtensionAttribute[] = []\n  const { nodeExtensions, markExtensions } = splitExtensions(extensions)\n  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions]\n  const defaultAttribute: Required<Attribute> = {\n    default: null,\n    rendered: true,\n    renderHTML: null,\n    parseHTML: null,\n    keepOnSplit: true,\n    isRequired: false,\n  }\n\n  extensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n    }\n\n    const addGlobalAttributes = getExtensionField<AnyConfig['addGlobalAttributes']>(\n      extension,\n      'addGlobalAttributes',\n      context,\n    )\n\n    if (!addGlobalAttributes) {\n      return\n    }\n\n    // TODO: remove `as GlobalAttributes`\n    const globalAttributes = addGlobalAttributes() as GlobalAttributes\n\n    globalAttributes.forEach(globalAttribute => {\n      globalAttribute.types.forEach(type => {\n        Object\n          .entries(globalAttribute.attributes)\n          .forEach(([name, attribute]) => {\n            extensionAttributes.push({\n              type,\n              name,\n              attribute: {\n                ...defaultAttribute,\n                ...attribute,\n              },\n            })\n          })\n      })\n    })\n  })\n\n  nodeAndMarkExtensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n    }\n\n    const addAttributes = getExtensionField<NodeConfig['addAttributes'] | MarkConfig['addAttributes']>(\n      extension,\n      'addAttributes',\n      context,\n    )\n\n    if (!addAttributes) {\n      return\n    }\n\n    // TODO: remove `as Attributes`\n    const attributes = addAttributes() as Attributes\n\n    Object\n      .entries(attributes)\n      .forEach(([name, attribute]) => {\n        const mergedAttr = {\n          ...defaultAttribute,\n          ...attribute,\n        }\n\n        if (typeof mergedAttr?.default === 'function') {\n          mergedAttr.default = mergedAttr.default()\n        }\n\n        if (mergedAttr?.isRequired && mergedAttr?.default === undefined) {\n          delete mergedAttr.default\n        }\n\n        extensionAttributes.push({\n          type: extension.name,\n          name,\n          attribute: mergedAttr,\n        })\n      })\n  })\n\n  return extensionAttributes\n}\n","import { NodeType, Schema } from '@tiptap/pm/model'\n\nexport function getNodeType(nameOrType: string | NodeType, schema: Schema): NodeType {\n  if (typeof nameOrType === 'string') {\n    if (!schema.nodes[nameOrType]) {\n      throw Error(\n        `There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`,\n      )\n    }\n\n    return schema.nodes[nameOrType]\n  }\n\n  return nameOrType\n}\n","export function mergeAttributes(...objects: Record<string, any>[]): Record<string, any> {\n  return objects\n    .filter(item => !!item)\n    .reduce((items, item) => {\n      const mergedAttributes = { ...items }\n\n      Object.entries(item).forEach(([key, value]) => {\n        const exists = mergedAttributes[key]\n\n        if (!exists) {\n          mergedAttributes[key] = value\n\n          return\n        }\n\n        if (key === 'class') {\n          const valueClasses: string[] = value ? value.split(' ') : []\n          const existingClasses: string[] = mergedAttributes[key] ? mergedAttributes[key].split(' ') : []\n\n          const insertClasses = valueClasses.filter(\n            valueClass => !existingClasses.includes(valueClass),\n          )\n\n          mergedAttributes[key] = [...existingClasses, ...insertClasses].join(' ')\n        } else if (key === 'style') {\n          mergedAttributes[key] = [mergedAttributes[key], value].join('; ')\n        } else {\n          mergedAttributes[key] = value\n        }\n      })\n\n      return mergedAttributes\n    }, {})\n}\n","import { Mark, Node } from '@tiptap/pm/model'\n\nimport { ExtensionAttribute } from '../types.js'\nimport { mergeAttributes } from '../utilities/mergeAttributes.js'\n\nexport function getRenderedAttributes(\n  nodeOrMark: Node | Mark,\n  extensionAttributes: ExtensionAttribute[],\n): Record<string, any> {\n  return extensionAttributes\n    .filter(item => item.attribute.rendered)\n    .map(item => {\n      if (!item.attribute.renderHTML) {\n        return {\n          [item.name]: nodeOrMark.attrs[item.name],\n        }\n      }\n\n      return item.attribute.renderHTML(nodeOrMark.attrs) || {}\n    })\n    .reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {})\n}\n","export function isFunction(value: any): value is Function {\n  return typeof value === 'function'\n}\n","import { MaybeReturnType } from '../types.js'\nimport { isFunction } from './isFunction.js'\n\n/**\n * Optionally calls `value` as a function.\n * Otherwise it is returned directly.\n * @param value Function or any value.\n * @param context Optional context to bind to function.\n * @param props Optional props to pass to function.\n */\nexport function callOrReturn<T>(value: T, context: any = undefined, ...props: any[]): MaybeReturnType<T> {\n  if (isFunction(value)) {\n    if (context) {\n      return value.bind(context)(...props)\n    }\n\n    return value(...props)\n  }\n\n  return value as MaybeReturnType<T>\n}\n","export function isEmptyObject(value = {}): boolean {\n  return Object.keys(value).length === 0 && value.constructor === Object\n}\n","export function fromString(value: any): any {\n  if (typeof value !== 'string') {\n    return value\n  }\n\n  if (value.match(/^[+-]?(?:\\d*\\.)?\\d+$/)) {\n    return Number(value)\n  }\n\n  if (value === 'true') {\n    return true\n  }\n\n  if (value === 'false') {\n    return false\n  }\n\n  return value\n}\n","import { ParseRule } from '@tiptap/pm/model'\n\nimport { ExtensionAttribute } from '../types.js'\nimport { fromString } from '../utilities/fromString.js'\n\n/**\n * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).\n * Cancels when `getAttrs` returned `false`.\n * @param parseRule ProseMirror ParseRule\n * @param extensionAttributes List of attributes to inject\n */\nexport function injectExtensionAttributesToParseRule(\n  parseRule: ParseRule,\n  extensionAttributes: ExtensionAttribute[],\n): ParseRule {\n  if (parseRule.style) {\n    return parseRule\n  }\n\n  return {\n    ...parseRule,\n    getAttrs: node => {\n      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs\n\n      if (oldAttributes === false) {\n        return false\n      }\n\n      const newAttributes = extensionAttributes.reduce((items, item) => {\n        const value = item.attribute.parseHTML\n          ? item.attribute.parseHTML(node as HTMLElement)\n          : fromString((node as HTMLElement).getAttribute(item.name))\n\n        if (value === null || value === undefined) {\n          return items\n        }\n\n        return {\n          ...items,\n          [item.name]: value,\n        }\n      }, {})\n\n      return { ...oldAttributes, ...newAttributes }\n    },\n  }\n}\n","import { MarkSpec, NodeSpec, Schema } from '@tiptap/pm/model'\n\nimport { Editor, MarkConfig, NodeConfig } from '../index.js'\nimport { AnyConfig, Extensions } from '../types.js'\nimport { callOrReturn } from '../utilities/callOrReturn.js'\nimport { isEmptyObject } from '../utilities/isEmptyObject.js'\nimport { getAttributesFromExtensions } from './getAttributesFromExtensions.js'\nimport { getExtensionField } from './getExtensionField.js'\nimport { getRenderedAttributes } from './getRenderedAttributes.js'\nimport { injectExtensionAttributesToParseRule } from './injectExtensionAttributesToParseRule.js'\nimport { splitExtensions } from './splitExtensions.js'\n\nfunction cleanUpSchemaItem<T>(data: T) {\n  return Object.fromEntries(\n    // @ts-ignore\n    Object.entries(data).filter(([key, value]) => {\n      if (key === 'attrs' && isEmptyObject(value as {} | undefined)) {\n        return false\n      }\n\n      return value !== null && value !== undefined\n    }),\n  ) as T\n}\n\nexport function getSchemaByResolvedExtensions(extensions: Extensions, editor?: Editor): Schema {\n  const allAttributes = getAttributesFromExtensions(extensions)\n  const { nodeExtensions, markExtensions } = splitExtensions(extensions)\n  const topNode = nodeExtensions.find(extension => getExtensionField(extension, 'topNode'))?.name\n\n  const nodes = Object.fromEntries(\n    nodeExtensions.map(extension => {\n      const extensionAttributes = allAttributes.filter(\n        attribute => attribute.type === extension.name,\n      )\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor,\n      }\n\n      const extraNodeFields = extensions.reduce((fields, e) => {\n        const extendNodeSchema = getExtensionField<AnyConfig['extendNodeSchema']>(\n          e,\n          'extendNodeSchema',\n          context,\n        )\n\n        return {\n          ...fields,\n          ...(extendNodeSchema ? extendNodeSchema(extension) : {}),\n        }\n      }, {})\n\n      const schema: NodeSpec = cleanUpSchemaItem({\n        ...extraNodeFields,\n        content: callOrReturn(\n          getExtensionField<NodeConfig['content']>(extension, 'content', context),\n        ),\n        marks: callOrReturn(getExtensionField<NodeConfig['marks']>(extension, 'marks', context)),\n        group: callOrReturn(getExtensionField<NodeConfig['group']>(extension, 'group', context)),\n        inline: callOrReturn(getExtensionField<NodeConfig['inline']>(extension, 'inline', context)),\n        atom: callOrReturn(getExtensionField<NodeConfig['atom']>(extension, 'atom', context)),\n        selectable: callOrReturn(\n          getExtensionField<NodeConfig['selectable']>(extension, 'selectable', context),\n        ),\n        draggable: callOrReturn(\n          getExtensionField<NodeConfig['draggable']>(extension, 'draggable', context),\n        ),\n        code: callOrReturn(getExtensionField<NodeConfig['code']>(extension, 'code', context)),\n        defining: callOrReturn(\n          getExtensionField<NodeConfig['defining']>(extension, 'defining', context),\n        ),\n        isolating: callOrReturn(\n          getExtensionField<NodeConfig['isolating']>(extension, 'isolating', context),\n        ),\n        attrs: Object.fromEntries(\n          extensionAttributes.map(extensionAttribute => {\n            return [extensionAttribute.name, { default: extensionAttribute?.attribute?.default }]\n          }),\n        ),\n      })\n\n      const parseHTML = callOrReturn(\n        getExtensionField<NodeConfig['parseHTML']>(extension, 'parseHTML', context),\n      )\n\n      if (parseHTML) {\n        schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes))\n      }\n\n      const renderHTML = getExtensionField<NodeConfig['renderHTML']>(\n        extension,\n        'renderHTML',\n        context,\n      )\n\n      if (renderHTML) {\n        schema.toDOM = node => renderHTML({\n          node,\n          HTMLAttributes: getRenderedAttributes(node, extensionAttributes),\n        })\n      }\n\n      const renderText = getExtensionField<NodeConfig['renderText']>(\n        extension,\n        'renderText',\n        context,\n      )\n\n      if (renderText) {\n        schema.toText = renderText\n      }\n\n      return [extension.name, schema]\n    }),\n  )\n\n  const marks = Object.fromEntries(\n    markExtensions.map(extension => {\n      const extensionAttributes = allAttributes.filter(\n        attribute => attribute.type === extension.name,\n      )\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor,\n      }\n\n      const extraMarkFields = extensions.reduce((fields, e) => {\n        const extendMarkSchema = getExtensionField<AnyConfig['extendMarkSchema']>(\n          e,\n          'extendMarkSchema',\n          context,\n        )\n\n        return {\n          ...fields,\n          ...(extendMarkSchema ? extendMarkSchema(extension) : {}),\n        }\n      }, {})\n\n      const schema: MarkSpec = cleanUpSchemaItem({\n        ...extraMarkFields,\n        inclusive: callOrReturn(\n          getExtensionField<MarkConfig['inclusive']>(extension, 'inclusive', context),\n        ),\n        excludes: callOrReturn(\n          getExtensionField<MarkConfig['excludes']>(extension, 'excludes', context),\n        ),\n        group: callOrReturn(getExtensionField<MarkConfig['group']>(extension, 'group', context)),\n        spanning: callOrReturn(\n          getExtensionField<MarkConfig['spanning']>(extension, 'spanning', context),\n        ),\n        code: callOrReturn(getExtensionField<MarkConfig['code']>(extension, 'code', context)),\n        attrs: Object.fromEntries(\n          extensionAttributes.map(extensionAttribute => {\n            return [extensionAttribute.name, { default: extensionAttribute?.attribute?.default }]\n          }),\n        ),\n      })\n\n      const parseHTML = callOrReturn(\n        getExtensionField<MarkConfig['parseHTML']>(extension, 'parseHTML', context),\n      )\n\n      if (parseHTML) {\n        schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes))\n      }\n\n      const renderHTML = getExtensionField<MarkConfig['renderHTML']>(\n        extension,\n        'renderHTML',\n        context,\n      )\n\n      if (renderHTML) {\n        schema.toDOM = mark => renderHTML({\n          mark,\n          HTMLAttributes: getRenderedAttributes(mark, extensionAttributes),\n        })\n      }\n\n      return [extension.name, schema]\n    }),\n  )\n\n  return new Schema({\n    topNode,\n    nodes,\n    marks,\n  })\n}\n","import { MarkType, NodeType, Schema } from '@tiptap/pm/model'\n\nexport function getSchemaTypeByName(name: string, schema: Schema): NodeType | MarkType | null {\n  return schema.nodes[name] || schema.marks[name] || null\n}\n","import { AnyExtension, EnableRules } from '../types.js'\n\nexport function isExtensionRulesEnabled(extension: AnyExtension, enabled: EnableRules): boolean {\n  if (Array.isArray(enabled)) {\n    return enabled.some(enabledExtension => {\n      const name = typeof enabledExtension === 'string'\n        ? enabledExtension\n        : enabledExtension.name\n\n      return name === extension.name\n    })\n  }\n\n  return enabled\n}\n","import { ResolvedPos } from '@tiptap/pm/model'\n\nexport const getTextContentFromNodes = ($from: ResolvedPos, maxMatch = 500) => {\n  let textBefore = ''\n\n  const sliceEndPos = $from.parentOffset\n\n  $from.parent.nodesBetween(\n    Math.max(0, sliceEndPos - maxMatch),\n    sliceEndPos,\n    (node, pos, parent, index) => {\n      const chunk = node.type.spec.toText?.({\n        node,\n        pos,\n        parent,\n        index,\n      })\n        || node.textContent\n        || '%leaf%'\n\n      textBefore += chunk.slice(0, Math.max(0, sliceEndPos - pos))\n    },\n  )\n\n  return textBefore\n}\n","export function isRegExp(value: any): value is RegExp {\n  return Object.prototype.toString.call(value) === '[object RegExp]'\n}\n","import { EditorState, Plugin, TextSelection } from '@tiptap/pm/state'\n\nimport { CommandManager } from './CommandManager.js'\nimport { Editor } from './Editor.js'\nimport { createChainableState } from './helpers/createChainableState.js'\nimport { getTextContentFromNodes } from './helpers/getTextContentFromNodes.js'\nimport {\n  CanCommands,\n  ChainedCommands,\n  ExtendedRegExpMatchArray,\n  Range,\n  SingleCommands,\n} from './types.js'\nimport { isRegExp } from './utilities/isRegExp.js'\n\nexport type InputRuleMatch = {\n  index: number\n  text: string\n  replaceWith?: string\n  match?: RegExpMatchArray\n  data?: Record<string, any>\n}\n\nexport type InputRuleFinder = RegExp | ((text: string) => InputRuleMatch | null)\n\nexport class InputRule {\n  find: InputRuleFinder\n\n  handler: (props: {\n    state: EditorState\n    range: Range\n    match: ExtendedRegExpMatchArray\n    commands: SingleCommands\n    chain: () => ChainedCommands\n    can: () => CanCommands\n  }) => void | null\n\n  constructor(config: {\n    find: InputRuleFinder\n    handler: (props: {\n      state: EditorState\n      range: Range\n      match: ExtendedRegExpMatchArray\n      commands: SingleCommands\n      chain: () => ChainedCommands\n      can: () => CanCommands\n    }) => void | null\n  }) {\n    this.find = config.find\n    this.handler = config.handler\n  }\n}\n\nconst inputRuleMatcherHandler = (\n  text: string,\n  find: InputRuleFinder,\n): ExtendedRegExpMatchArray | null => {\n  if (isRegExp(find)) {\n    return find.exec(text)\n  }\n\n  const inputRuleMatch = find(text)\n\n  if (!inputRuleMatch) {\n    return null\n  }\n\n  const result: ExtendedRegExpMatchArray = [inputRuleMatch.text]\n\n  result.index = inputRuleMatch.index\n  result.input = text\n  result.data = inputRuleMatch.data\n\n  if (inputRuleMatch.replaceWith) {\n    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {\n      console.warn(\n        '[tiptap warn]: \"inputRuleMatch.replaceWith\" must be part of \"inputRuleMatch.text\".',\n      )\n    }\n\n    result.push(inputRuleMatch.replaceWith)\n  }\n\n  return result\n}\n\nfunction run(config: {\n  editor: Editor\n  from: number\n  to: number\n  text: string\n  rules: InputRule[]\n  plugin: Plugin\n}): boolean {\n  const {\n    editor, from, to, text, rules, plugin,\n  } = config\n  const { view } = editor\n\n  if (view.composing) {\n    return false\n  }\n\n  const $from = view.state.doc.resolve(from)\n\n  if (\n    // check for code node\n    $from.parent.type.spec.code\n    // check for code mark\n    || !!($from.nodeBefore || $from.nodeAfter)?.marks.find(mark => mark.type.spec.code)\n  ) {\n    return false\n  }\n\n  let matched = false\n\n  const textBefore = getTextContentFromNodes($from) + text\n\n  rules.forEach(rule => {\n    if (matched) {\n      return\n    }\n\n    const match = inputRuleMatcherHandler(textBefore, rule.find)\n\n    if (!match) {\n      return\n    }\n\n    const tr = view.state.tr\n    const state = createChainableState({\n      state: view.state,\n      transaction: tr,\n    })\n    const range = {\n      from: from - (match[0].length - text.length),\n      to,\n    }\n\n    const { commands, chain, can } = new CommandManager({\n      editor,\n      state,\n    })\n\n    const handler = rule.handler({\n      state,\n      range,\n      match,\n      commands,\n      chain,\n      can,\n    })\n\n    // stop if there are no changes\n    if (handler === null || !tr.steps.length) {\n      return\n    }\n\n    // store transform as meta data\n    // so we can undo input rules within the `undoInputRules` command\n    tr.setMeta(plugin, {\n      transform: tr,\n      from,\n      to,\n      text,\n    })\n\n    view.dispatch(tr)\n    matched = true\n  })\n\n  return matched\n}\n\n/**\n * Create an input rules plugin. When enabled, it will cause text\n * input that matches any of the given rules to trigger the rule’s\n * action.\n */\nexport function inputRulesPlugin(props: { editor: Editor; rules: InputRule[] }): Plugin {\n  const { editor, rules } = props\n  const plugin = new Plugin({\n    state: {\n      init() {\n        return null\n      },\n      apply(tr, prev) {\n        const stored = tr.getMeta(plugin)\n\n        if (stored) {\n          return stored\n        }\n\n        return tr.selectionSet || tr.docChanged ? null : prev\n      },\n    },\n\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run({\n          editor,\n          from,\n          to,\n          text,\n          rules,\n          plugin,\n        })\n      },\n\n      handleDOMEvents: {\n        compositionend: view => {\n          setTimeout(() => {\n            const { $cursor } = view.state.selection as TextSelection\n\n            if ($cursor) {\n              run({\n                editor,\n                from: $cursor.pos,\n                to: $cursor.pos,\n                text: '',\n                rules,\n                plugin,\n              })\n            }\n          })\n\n          return false\n        },\n      },\n\n      // add support for input rules to trigger on enter\n      // this is useful for example for code blocks\n      handleKeyDown(view, event) {\n        if (event.key !== 'Enter') {\n          return false\n        }\n\n        const { $cursor } = view.state.selection as TextSelection\n\n        if ($cursor) {\n          return run({\n            editor,\n            from: $cursor.pos,\n            to: $cursor.pos,\n            text: '\\n',\n            rules,\n            plugin,\n          })\n        }\n\n        return false\n      },\n    },\n\n    // @ts-ignore\n    isInputRules: true,\n  }) as Plugin\n\n  return plugin\n}\n","export function isNumber(value: any): value is number {\n  return typeof value === 'number'\n}\n","import { EditorState, Plugin } from '@tiptap/pm/state'\n\nimport { CommandManager } from './CommandManager.js'\nimport { Editor } from './Editor.js'\nimport { createChainableState } from './helpers/createChainableState.js'\nimport {\n  CanCommands,\n  ChainedCommands,\n  ExtendedRegExpMatchArray,\n  Range,\n  SingleCommands,\n} from './types.js'\nimport { isNumber } from './utilities/isNumber.js'\nimport { isRegExp } from './utilities/isRegExp.js'\n\nexport type PasteRuleMatch = {\n  index: number\n  text: string\n  replaceWith?: string\n  match?: RegExpMatchArray\n  data?: Record<string, any>\n}\n\nexport type PasteRuleFinder = RegExp | ((text: string) => PasteRuleMatch[] | null | undefined)\n\nexport class PasteRule {\n  find: PasteRuleFinder\n\n  handler: (props: {\n    state: EditorState\n    range: Range\n    match: ExtendedRegExpMatchArray\n    commands: SingleCommands\n    chain: () => ChainedCommands\n    can: () => CanCommands\n    pasteEvent: ClipboardEvent\n    dropEvent: DragEvent\n  }) => void | null\n\n  constructor(config: {\n    find: PasteRuleFinder\n    handler: (props: {\n      can: () => CanCommands\n      chain: () => ChainedCommands\n      commands: SingleCommands\n      dropEvent: DragEvent\n      match: ExtendedRegExpMatchArray\n      pasteEvent: ClipboardEvent\n      range: Range\n      state: EditorState\n    }) => void | null\n  }) {\n    this.find = config.find\n    this.handler = config.handler\n  }\n}\n\nconst pasteRuleMatcherHandler = (\n  text: string,\n  find: PasteRuleFinder,\n): ExtendedRegExpMatchArray[] => {\n  if (isRegExp(find)) {\n    return [...text.matchAll(find)]\n  }\n\n  const matches = find(text)\n\n  if (!matches) {\n    return []\n  }\n\n  return matches.map(pasteRuleMatch => {\n    const result: ExtendedRegExpMatchArray = [pasteRuleMatch.text]\n\n    result.index = pasteRuleMatch.index\n    result.input = text\n    result.data = pasteRuleMatch.data\n\n    if (pasteRuleMatch.replaceWith) {\n      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {\n        console.warn(\n          '[tiptap warn]: \"pasteRuleMatch.replaceWith\" must be part of \"pasteRuleMatch.text\".',\n        )\n      }\n\n      result.push(pasteRuleMatch.replaceWith)\n    }\n\n    return result\n  })\n}\n\nfunction run(config: {\n  editor: Editor\n  state: EditorState\n  from: number\n  to: number\n  rule: PasteRule\n  pasteEvent: ClipboardEvent\n  dropEvent: DragEvent\n}): boolean {\n  const {\n    editor, state, from, to, rule, pasteEvent, dropEvent,\n  } = config\n\n  const { commands, chain, can } = new CommandManager({\n    editor,\n    state,\n  })\n\n  const handlers: (void | null)[] = []\n\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isTextblock || node.type.spec.code) {\n      return\n    }\n\n    const resolvedFrom = Math.max(from, pos)\n    const resolvedTo = Math.min(to, pos + node.content.size)\n    const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, undefined, '\\ufffc')\n\n    const matches = pasteRuleMatcherHandler(textToMatch, rule.find)\n\n    matches.forEach(match => {\n      if (match.index === undefined) {\n        return\n      }\n\n      const start = resolvedFrom + match.index + 1\n      const end = start + match[0].length\n      const range = {\n        from: state.tr.mapping.map(start),\n        to: state.tr.mapping.map(end),\n      }\n\n      const handler = rule.handler({\n        state,\n        range,\n        match,\n        commands,\n        chain,\n        can,\n        pasteEvent,\n        dropEvent,\n      })\n\n      handlers.push(handler)\n    })\n  })\n\n  const success = handlers.every(handler => handler !== null)\n\n  return success\n}\n\n/**\n * Create an paste rules plugin. When enabled, it will cause pasted\n * text that matches any of the given rules to trigger the rule’s\n * action.\n */\nexport function pasteRulesPlugin(props: { editor: Editor; rules: PasteRule[] }): Plugin[] {\n  const { editor, rules } = props\n  let dragSourceElement: Element | null = null\n  let isPastedFromProseMirror = false\n  let isDroppedFromProseMirror = false\n  let pasteEvent = new ClipboardEvent('paste')\n  let dropEvent = new DragEvent('drop')\n\n  const plugins = rules.map(rule => {\n    return new Plugin({\n      // we register a global drag handler to track the current drag source element\n      view(view) {\n        const handleDragstart = (event: DragEvent) => {\n          dragSourceElement = view.dom.parentElement?.contains(event.target as Element)\n            ? view.dom.parentElement\n            : null\n        }\n\n        window.addEventListener('dragstart', handleDragstart)\n\n        return {\n          destroy() {\n            window.removeEventListener('dragstart', handleDragstart)\n          },\n        }\n      },\n\n      props: {\n        handleDOMEvents: {\n          drop: (view, event: Event) => {\n            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement\n            dropEvent = event as DragEvent\n\n            return false\n          },\n\n          paste: (_view, event: Event) => {\n            const html = (event as ClipboardEvent).clipboardData?.getData('text/html')\n\n            pasteEvent = event as ClipboardEvent\n\n            isPastedFromProseMirror = !!html?.includes('data-pm-slice')\n\n            return false\n          },\n        },\n      },\n\n      appendTransaction: (transactions, oldState, state) => {\n        const transaction = transactions[0]\n        const isPaste = transaction.getMeta('uiEvent') === 'paste' && !isPastedFromProseMirror\n        const isDrop = transaction.getMeta('uiEvent') === 'drop' && !isDroppedFromProseMirror\n\n        if (!isPaste && !isDrop) {\n          return\n        }\n\n        // stop if there is no changed range\n        const from = oldState.doc.content.findDiffStart(state.doc.content)\n        const to = oldState.doc.content.findDiffEnd(state.doc.content)\n\n        if (!isNumber(from) || !to || from === to.b) {\n          return\n        }\n\n        // build a chainable state\n        // so we can use a single transaction for all paste rules\n        const tr = state.tr\n        const chainableState = createChainableState({\n          state,\n          transaction: tr,\n        })\n\n        const handler = run({\n          editor,\n          state: chainableState,\n          from: Math.max(from - 1, 0),\n          to: to.b - 1,\n          rule,\n          pasteEvent,\n          dropEvent,\n        })\n\n        // stop if there are no changes\n        if (!handler || !tr.steps.length) {\n          return\n        }\n\n        dropEvent = new DragEvent('drop')\n        pasteEvent = new ClipboardEvent('paste')\n\n        return tr\n      },\n    })\n  })\n\n  return plugins\n}\n","export function findDuplicates(items: any[]): any[] {\n  const filtered = items.filter((el, index) => items.indexOf(el) !== index)\n\n  return [...new Set(filtered)]\n}\n","import { keymap } from '@tiptap/pm/keymap'\nimport { Node as ProsemirrorNode, Schema } from '@tiptap/pm/model'\nimport { Plugin } from '@tiptap/pm/state'\nimport { Decoration, EditorView } from '@tiptap/pm/view'\n\nimport { Editor } from './Editor.js'\nimport { getAttributesFromExtensions } from './helpers/getAttributesFromExtensions.js'\nimport { getExtensionField } from './helpers/getExtensionField.js'\nimport { getNodeType } from './helpers/getNodeType.js'\nimport { getRenderedAttributes } from './helpers/getRenderedAttributes.js'\nimport { getSchemaByResolvedExtensions } from './helpers/getSchemaByResolvedExtensions.js'\nimport { getSchemaTypeByName } from './helpers/getSchemaTypeByName.js'\nimport { isExtensionRulesEnabled } from './helpers/isExtensionRulesEnabled.js'\nimport { splitExtensions } from './helpers/splitExtensions.js'\nimport { Mark, NodeConfig } from './index.js'\nimport { inputRulesPlugin } from './InputRule.js'\nimport { pasteRulesPlugin } from './PasteRule.js'\nimport { AnyConfig, Extensions, RawCommands } from './types.js'\nimport { callOrReturn } from './utilities/callOrReturn.js'\nimport { findDuplicates } from './utilities/findDuplicates.js'\n\nexport class ExtensionManager {\n  editor: Editor\n\n  schema: Schema\n\n  extensions: Extensions\n\n  splittableMarks: string[] = []\n\n  constructor(extensions: Extensions, editor: Editor) {\n    this.editor = editor\n    this.extensions = ExtensionManager.resolve(extensions)\n    this.schema = getSchemaByResolvedExtensions(this.extensions, editor)\n\n    this.extensions.forEach(extension => {\n      // store extension storage in editor\n      this.editor.extensionStorage[extension.name] = extension.storage\n\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema),\n      }\n\n      if (extension.type === 'mark') {\n        const keepOnSplit = callOrReturn(getExtensionField(extension, 'keepOnSplit', context)) ?? true\n\n        if (keepOnSplit) {\n          this.splittableMarks.push(extension.name)\n        }\n      }\n\n      const onBeforeCreate = getExtensionField<AnyConfig['onBeforeCreate']>(\n        extension,\n        'onBeforeCreate',\n        context,\n      )\n\n      if (onBeforeCreate) {\n        this.editor.on('beforeCreate', onBeforeCreate)\n      }\n\n      const onCreate = getExtensionField<AnyConfig['onCreate']>(extension, 'onCreate', context)\n\n      if (onCreate) {\n        this.editor.on('create', onCreate)\n      }\n\n      const onUpdate = getExtensionField<AnyConfig['onUpdate']>(extension, 'onUpdate', context)\n\n      if (onUpdate) {\n        this.editor.on('update', onUpdate)\n      }\n\n      const onSelectionUpdate = getExtensionField<AnyConfig['onSelectionUpdate']>(\n        extension,\n        'onSelectionUpdate',\n        context,\n      )\n\n      if (onSelectionUpdate) {\n        this.editor.on('selectionUpdate', onSelectionUpdate)\n      }\n\n      const onTransaction = getExtensionField<AnyConfig['onTransaction']>(\n        extension,\n        'onTransaction',\n        context,\n      )\n\n      if (onTransaction) {\n        this.editor.on('transaction', onTransaction)\n      }\n\n      const onFocus = getExtensionField<AnyConfig['onFocus']>(extension, 'onFocus', context)\n\n      if (onFocus) {\n        this.editor.on('focus', onFocus)\n      }\n\n      const onBlur = getExtensionField<AnyConfig['onBlur']>(extension, 'onBlur', context)\n\n      if (onBlur) {\n        this.editor.on('blur', onBlur)\n      }\n\n      const onDestroy = getExtensionField<AnyConfig['onDestroy']>(extension, 'onDestroy', context)\n\n      if (onDestroy) {\n        this.editor.on('destroy', onDestroy)\n      }\n    })\n  }\n\n  static resolve(extensions: Extensions): Extensions {\n    const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions))\n    const duplicatedNames = findDuplicates(resolvedExtensions.map(extension => extension.name))\n\n    if (duplicatedNames.length) {\n      console.warn(\n        `[tiptap warn]: Duplicate extension names found: [${duplicatedNames\n          .map(item => `'${item}'`)\n          .join(', ')}]. This can lead to issues.`,\n      )\n    }\n\n    return resolvedExtensions\n  }\n\n  static flatten(extensions: Extensions): Extensions {\n    return (\n      extensions\n        .map(extension => {\n          const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n          }\n\n          const addExtensions = getExtensionField<AnyConfig['addExtensions']>(\n            extension,\n            'addExtensions',\n            context,\n          )\n\n          if (addExtensions) {\n            return [extension, ...this.flatten(addExtensions())]\n          }\n\n          return extension\n        })\n        // `Infinity` will break TypeScript so we set a number that is probably high enough\n        .flat(10)\n    )\n  }\n\n  static sort(extensions: Extensions): Extensions {\n    const defaultPriority = 100\n\n    return extensions.sort((a, b) => {\n      const priorityA = getExtensionField<AnyConfig['priority']>(a, 'priority') || defaultPriority\n      const priorityB = getExtensionField<AnyConfig['priority']>(b, 'priority') || defaultPriority\n\n      if (priorityA > priorityB) {\n        return -1\n      }\n\n      if (priorityA < priorityB) {\n        return 1\n      }\n\n      return 0\n    })\n  }\n\n  get commands(): RawCommands {\n    return this.extensions.reduce((commands, extension) => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema),\n      }\n\n      const addCommands = getExtensionField<AnyConfig['addCommands']>(\n        extension,\n        'addCommands',\n        context,\n      )\n\n      if (!addCommands) {\n        return commands\n      }\n\n      return {\n        ...commands,\n        ...addCommands(),\n      }\n    }, {} as RawCommands)\n  }\n\n  get plugins(): Plugin[] {\n    const { editor } = this\n\n    // With ProseMirror, first plugins within an array are executed first.\n    // In Tiptap, we provide the ability to override plugins,\n    // so it feels more natural to run plugins at the end of an array first.\n    // That’s why we have to reverse the `extensions` array and sort again\n    // based on the `priority` option.\n    const extensions = ExtensionManager.sort([...this.extensions].reverse())\n\n    const inputRules: any[] = []\n    const pasteRules: any[] = []\n\n    const allPlugins = extensions\n      .map(extension => {\n        const context = {\n          name: extension.name,\n          options: extension.options,\n          storage: extension.storage,\n          editor,\n          type: getSchemaTypeByName(extension.name, this.schema),\n        }\n\n        const plugins: Plugin[] = []\n\n        const addKeyboardShortcuts = getExtensionField<AnyConfig['addKeyboardShortcuts']>(\n          extension,\n          'addKeyboardShortcuts',\n          context,\n        )\n\n        let defaultBindings: Record<string, () => boolean> = {}\n\n        // bind exit handling\n        if (extension.type === 'mark' && extension.config.exitable) {\n          defaultBindings.ArrowRight = () => Mark.handleExit({ editor, mark: extension as Mark })\n        }\n\n        if (addKeyboardShortcuts) {\n          const bindings = Object.fromEntries(\n            Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {\n              return [shortcut, () => method({ editor })]\n            }),\n          )\n\n          defaultBindings = { ...defaultBindings, ...bindings }\n        }\n\n        const keyMapPlugin = keymap(defaultBindings)\n\n        plugins.push(keyMapPlugin)\n\n        const addInputRules = getExtensionField<AnyConfig['addInputRules']>(\n          extension,\n          'addInputRules',\n          context,\n        )\n\n        if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {\n          inputRules.push(...addInputRules())\n        }\n\n        const addPasteRules = getExtensionField<AnyConfig['addPasteRules']>(\n          extension,\n          'addPasteRules',\n          context,\n        )\n\n        if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {\n          pasteRules.push(...addPasteRules())\n        }\n\n        const addProseMirrorPlugins = getExtensionField<AnyConfig['addProseMirrorPlugins']>(\n          extension,\n          'addProseMirrorPlugins',\n          context,\n        )\n\n        if (addProseMirrorPlugins) {\n          const proseMirrorPlugins = addProseMirrorPlugins()\n\n          plugins.push(...proseMirrorPlugins)\n        }\n\n        return plugins\n      })\n      .flat()\n\n    return [\n      inputRulesPlugin({\n        editor,\n        rules: inputRules,\n      }),\n      ...pasteRulesPlugin({\n        editor,\n        rules: pasteRules,\n      }),\n      ...allPlugins,\n    ]\n  }\n\n  get attributes() {\n    return getAttributesFromExtensions(this.extensions)\n  }\n\n  get nodeViews() {\n    const { editor } = this\n    const { nodeExtensions } = splitExtensions(this.extensions)\n\n    return Object.fromEntries(\n      nodeExtensions\n        .filter(extension => !!getExtensionField(extension, 'addNodeView'))\n        .map(extension => {\n          const extensionAttributes = this.attributes.filter(\n            attribute => attribute.type === extension.name,\n          )\n          const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n            editor,\n            type: getNodeType(extension.name, this.schema),\n          }\n          const addNodeView = getExtensionField<NodeConfig['addNodeView']>(\n            extension,\n            'addNodeView',\n            context,\n          )\n\n          if (!addNodeView) {\n            return []\n          }\n\n          const nodeview = (\n            node: ProsemirrorNode,\n            view: EditorView,\n            getPos: (() => number) | boolean,\n            decorations: Decoration[],\n          ) => {\n            const HTMLAttributes = getRenderedAttributes(node, extensionAttributes)\n\n            return addNodeView()({\n              editor,\n              node,\n              getPos,\n              decorations,\n              HTMLAttributes,\n              extension,\n            })\n          }\n\n          return [extension.name, nodeview]\n        }),\n    )\n  }\n}\n","// see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts\n\nfunction getType(value: any): string {\n  return Object.prototype.toString.call(value).slice(8, -1)\n}\n\nexport function isPlainObject(value: any): value is Record<string, any> {\n  if (getType(value) !== 'Object') {\n    return false\n  }\n\n  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype\n}\n","import { isPlainObject } from './isPlainObject.js'\n\nexport function mergeDeep(target: Record<string, any>, source: Record<string, any>): Record<string, any> {\n  const output = { ...target }\n\n  if (isPlainObject(target) && isPlainObject(source)) {\n    Object.keys(source).forEach(key => {\n      if (isPlainObject(source[key])) {\n        if (!(key in target)) {\n          Object.assign(output, { [key]: source[key] })\n        } else {\n          output[key] = mergeDeep(target[key], source[key])\n        }\n      } else {\n        Object.assign(output, { [key]: source[key] })\n      }\n    })\n  }\n\n  return output\n}\n","import { Plugin, Transaction } from '@tiptap/pm/state'\n\nimport { Editor } from './Editor.js'\nimport { getExtensionField } from './helpers/getExtensionField.js'\nimport { ExtensionConfig } from './index.js'\nimport { InputRule } from './InputRule.js'\nimport { Mark } from './Mark.js'\nimport { Node } from './Node.js'\nimport { PasteRule } from './PasteRule.js'\nimport {\n  AnyConfig,\n  Extensions,\n  GlobalAttributes,\n  KeyboardShortcutCommand,\n  ParentConfig,\n  RawCommands,\n} from './types.js'\nimport { callOrReturn } from './utilities/callOrReturn.js'\nimport { mergeDeep } from './utilities/mergeDeep.js'\n\ndeclare module '@tiptap/core' {\n  interface ExtensionConfig<Options = any, Storage = any> {\n    [key: string]: any\n\n    /**\n     * Name\n     */\n    name: string\n\n    /**\n     * Priority\n     */\n    priority?: number\n\n    /**\n     * Default options\n     */\n    defaultOptions?: Options\n\n    /**\n     * Default Options\n     */\n    addOptions?: (this: {\n      name: string\n      parent: Exclude<ParentConfig<ExtensionConfig<Options, Storage>>['addOptions'], undefined>\n    }) => Options\n\n    /**\n     * Default Storage\n     */\n    addStorage?: (this: {\n      name: string\n      options: Options\n      parent: Exclude<ParentConfig<ExtensionConfig<Options, Storage>>['addStorage'], undefined>\n    }) => Storage\n\n    /**\n     * Global attributes\n     */\n    addGlobalAttributes?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addGlobalAttributes']\n    }) => GlobalAttributes | {}\n\n    /**\n     * Raw\n     */\n    addCommands?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addCommands']\n    }) => Partial<RawCommands>\n\n    /**\n     * Keyboard shortcuts\n     */\n    addKeyboardShortcuts?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addKeyboardShortcuts']\n    }) => {\n      [key: string]: KeyboardShortcutCommand\n    }\n\n    /**\n     * Input rules\n     */\n    addInputRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addInputRules']\n    }) => InputRule[]\n\n    /**\n     * Paste rules\n     */\n    addPasteRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addPasteRules']\n    }) => PasteRule[]\n\n    /**\n     * ProseMirror plugins\n     */\n    addProseMirrorPlugins?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addProseMirrorPlugins']\n    }) => Plugin[]\n\n    /**\n     * Extensions\n     */\n    addExtensions?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addExtensions']\n    }) => Extensions\n\n    /**\n     * Extend Node Schema\n     */\n    extendNodeSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<ExtensionConfig<Options, Storage>>['extendNodeSchema']\n          },\n          extension: Node,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * Extend Mark Schema\n     */\n    extendMarkSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<ExtensionConfig<Options, Storage>>['extendMarkSchema']\n          },\n          extension: Mark,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * The editor is not ready yet.\n     */\n    onBeforeCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          parent: ParentConfig<ExtensionConfig<Options, Storage>>['onBeforeCreate']\n        }) => void)\n      | null\n\n    /**\n     * The editor is ready.\n     */\n    onCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          parent: ParentConfig<ExtensionConfig<Options, Storage>>['onCreate']\n        }) => void)\n      | null\n\n    /**\n     * The content has changed.\n     */\n    onUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          parent: ParentConfig<ExtensionConfig<Options, Storage>>['onUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The selection has changed.\n     */\n    onSelectionUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          parent: ParentConfig<ExtensionConfig<Options, Storage>>['onSelectionUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The editor state has changed.\n     */\n    onTransaction?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            parent: ParentConfig<ExtensionConfig<Options, Storage>>['onTransaction']\n          },\n          props: {\n            transaction: Transaction\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is focused.\n     */\n    onFocus?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            parent: ParentConfig<ExtensionConfig<Options, Storage>>['onFocus']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor isn’t focused anymore.\n     */\n    onBlur?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            parent: ParentConfig<ExtensionConfig<Options, Storage>>['onBlur']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is destroyed.\n     */\n    onDestroy?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          parent: ParentConfig<ExtensionConfig<Options, Storage>>['onDestroy']\n        }) => void)\n      | null\n  }\n}\n\nexport class Extension<Options = any, Storage = any> {\n  type = 'extension'\n\n  name = 'extension'\n\n  parent: Extension | null = null\n\n  child: Extension | null = null\n\n  options: Options\n\n  storage: Storage\n\n  config: ExtensionConfig = {\n    name: this.name,\n    defaultOptions: {},\n  }\n\n  constructor(config: Partial<ExtensionConfig<Options, Storage>> = {}) {\n    this.config = {\n      ...this.config,\n      ...config,\n    }\n\n    this.name = this.config.name\n\n    if (config.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`,\n      )\n    }\n\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions\n\n    if (this.config.addOptions) {\n      this.options = callOrReturn(\n        getExtensionField<AnyConfig['addOptions']>(this, 'addOptions', {\n          name: this.name,\n        }),\n      )\n    }\n\n    this.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(this, 'addStorage', {\n        name: this.name,\n        options: this.options,\n      }),\n    ) || {}\n  }\n\n  static create<O = any, S = any>(config: Partial<ExtensionConfig<O, S>> = {}) {\n    return new Extension<O, S>(config)\n  }\n\n  configure(options: Partial<Options> = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend()\n\n    extension.options = mergeDeep(this.options as Record<string, any>, options) as Options\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n\n  extend<ExtendedOptions = Options, ExtendedStorage = Storage>(\n    extendedConfig: Partial<ExtensionConfig<ExtendedOptions, ExtendedStorage>> = {},\n  ) {\n    const extension = new Extension<ExtendedOptions, ExtendedStorage>(extendedConfig)\n\n    extension.parent = this\n\n    this.child = extension\n\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name\n\n    if (extendedConfig.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`,\n      )\n    }\n\n    extension.options = callOrReturn(\n      getExtensionField<AnyConfig['addOptions']>(extension, 'addOptions', {\n        name: extension.name,\n      }),\n    )\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { Range, TextSerializer } from '../types.js'\n\nexport function getTextBetween(\n  startNode: ProseMirrorNode,\n  range: Range,\n  options?: {\n    blockSeparator?: string\n    textSerializers?: Record<string, TextSerializer>\n  },\n): string {\n  const { from, to } = range\n  const { blockSeparator = '\\n\\n', textSerializers = {} } = options || {}\n  let text = ''\n  let separated = true\n\n  startNode.nodesBetween(from, to, (node, pos, parent, index) => {\n    const textSerializer = textSerializers?.[node.type.name]\n\n    if (textSerializer) {\n      if (node.isBlock && !separated) {\n        text += blockSeparator\n        separated = true\n      }\n\n      if (parent) {\n        text += textSerializer({\n          node,\n          pos,\n          parent,\n          index,\n          range,\n        })\n      }\n    } else if (node.isText) {\n      text += node?.text?.slice(Math.max(from, pos) - pos, to - pos) // eslint-disable-line\n      separated = false\n    } else if (node.isBlock && !separated) {\n      text += blockSeparator\n      separated = true\n    }\n  })\n\n  return text\n}\n","import { Schema } from '@tiptap/pm/model'\n\nimport { TextSerializer } from '../types.js'\n\nexport function getTextSerializersFromSchema(schema: Schema): Record<string, TextSerializer> {\n  return Object.fromEntries(\n    Object.entries(schema.nodes)\n      .filter(([, node]) => node.spec.toText)\n      .map(([name, node]) => [name, node.spec.toText]),\n  )\n}\n","import { Plugin, PluginKey } from '@tiptap/pm/state'\n\nimport { Extension } from '../Extension.js'\nimport { getTextBetween } from '../helpers/getTextBetween.js'\nimport { getTextSerializersFromSchema } from '../helpers/getTextSerializersFromSchema.js'\n\nexport const ClipboardTextSerializer = Extension.create({\n  name: 'clipboardTextSerializer',\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('clipboardTextSerializer'),\n        props: {\n          clipboardTextSerializer: () => {\n            const { editor } = this\n            const { state, schema } = editor\n            const { doc, selection } = state\n            const { ranges } = selection\n            const from = Math.min(...ranges.map(range => range.$from.pos))\n            const to = Math.max(...ranges.map(range => range.$to.pos))\n            const textSerializers = getTextSerializersFromSchema(schema)\n            const range = { from, to }\n\n            return getTextBetween(doc, range, {\n              textSerializers,\n            })\n          },\n        },\n      }),\n    ]\n  },\n})\n","import { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    blur: {\n      /**\n       * Removes focus from the editor.\n       */\n      blur: () => ReturnType,\n    }\n  }\n}\n\nexport const blur: RawCommands['blur'] = () => ({ editor, view }) => {\n  requestAnimationFrame(() => {\n    if (!editor.isDestroyed) {\n      (view.dom as HTMLElement).blur()\n\n      // Browsers should remove the caret on blur but safari does not.\n      // See: https://github.com/ueberdosis/tiptap/issues/2405\n      window?.getSelection()?.removeAllRanges()\n    }\n  })\n\n  return true\n}\n","import { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    clearContent: {\n      /**\n       * Clear the whole document.\n       */\n      clearContent: (emitUpdate?: boolean) => ReturnType,\n    }\n  }\n}\n\nexport const clearContent: RawCommands['clearContent'] = (emitUpdate = false) => ({ commands }) => {\n  return commands.setContent('', emitUpdate)\n}\n","import { liftTarget } from '@tiptap/pm/transform'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    clearNodes: {\n      /**\n       * Normalize nodes to a simple paragraph.\n       */\n      clearNodes: () => ReturnType,\n    }\n  }\n}\n\nexport const clearNodes: RawCommands['clearNodes'] = () => ({ state, tr, dispatch }) => {\n  const { selection } = tr\n  const { ranges } = selection\n\n  if (!dispatch) {\n    return true\n  }\n\n  ranges.forEach(({ $from, $to }) => {\n    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n      if (node.type.isText) {\n        return\n      }\n\n      const { doc, mapping } = tr\n      const $mappedFrom = doc.resolve(mapping.map(pos))\n      const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize))\n      const nodeRange = $mappedFrom.blockRange($mappedTo)\n\n      if (!nodeRange) {\n        return\n      }\n\n      const targetLiftDepth = liftTarget(nodeRange)\n\n      if (node.type.isTextblock) {\n        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index())\n\n        tr.setNodeMarkup(nodeRange.start, defaultType)\n      }\n\n      if (targetLiftDepth || targetLiftDepth === 0) {\n        tr.lift(nodeRange, targetLiftDepth)\n      }\n    })\n  })\n\n  return true\n}\n","import { Command, RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    command: {\n      /**\n       * Define a command inline.\n       */\n      command: (fn: (props: Parameters<Command>[0]) => boolean) => ReturnType,\n    }\n  }\n}\n\nexport const command: RawCommands['command'] = fn => props => {\n  return fn(props)\n}\n","import { createParagraphNear as originalCreateParagraphNear } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    createParagraphNear: {\n      /**\n       * Create a paragraph nearby.\n       */\n      createParagraphNear: () => ReturnType\n    }\n  }\n}\n\nexport const createParagraphNear: RawCommands['createParagraphNear'] = () => ({ state, dispatch }) => {\n  return originalCreateParagraphNear(state, dispatch)\n}\n","import { TextSelection } from '@tiptap/pm/state'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    cut: {\n      /**\n       * Cuts content from a range and inserts it at a given position.\n       */\n      cut: ({ from, to }: { from: number, to: number }, targetPos: number) => ReturnType,\n    }\n  }\n}\n\nexport const cut: RawCommands['cut'] = (originRange, targetPos) => ({ editor, tr }) => {\n  const { state } = editor\n\n  const contentSlice = state.doc.slice(originRange.from, originRange.to)\n\n  tr.deleteRange(originRange.from, originRange.to)\n  const newPos = tr.mapping.map(targetPos)\n\n  tr.insert(newPos, contentSlice.content)\n\n  tr.setSelection(new TextSelection(tr.doc.resolve(newPos - 1)))\n\n  return true\n}\n","import { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    deleteCurrentNode: {\n      /**\n       * Delete the node that currently has the selection anchor.\n       */\n      deleteCurrentNode: () => ReturnType,\n    }\n  }\n}\n\nexport const deleteCurrentNode: RawCommands['deleteCurrentNode'] = () => ({ tr, dispatch }) => {\n  const { selection } = tr\n  const currentNode = selection.$anchor.node()\n\n  // if there is content inside the current node, break out of this command\n  if (currentNode.content.size > 0) {\n    return false\n  }\n\n  const $pos = tr.selection.$anchor\n\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth)\n\n    if (node.type === currentNode.type) {\n      if (dispatch) {\n        const from = $pos.before(depth)\n        const to = $pos.after(depth)\n\n        tr.delete(from, to).scrollIntoView()\n      }\n\n      return true\n    }\n  }\n\n  return false\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    deleteNode: {\n      /**\n       * Delete a node.\n       */\n      deleteNode: (typeOrName: string | NodeType) => ReturnType,\n    }\n  }\n}\n\nexport const deleteNode: RawCommands['deleteNode'] = typeOrName => ({ tr, state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const $pos = tr.selection.$anchor\n\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth)\n\n    if (node.type === type) {\n      if (dispatch) {\n        const from = $pos.before(depth)\n        const to = $pos.after(depth)\n\n        tr.delete(from, to).scrollIntoView()\n      }\n\n      return true\n    }\n  }\n\n  return false\n}\n","import { Range, RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    deleteRange: {\n      /**\n       * Delete a given range.\n       */\n      deleteRange: (range: Range) => ReturnType,\n    }\n  }\n}\n\nexport const deleteRange: RawCommands['deleteRange'] = range => ({ tr, dispatch }) => {\n  const { from, to } = range\n\n  if (dispatch) {\n    tr.delete(from, to)\n  }\n\n  return true\n}\n","import { deleteSelection as originalDeleteSelection } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    deleteSelection: {\n      /**\n       * Delete the selection, if there is one.\n       */\n      deleteSelection: () => ReturnType\n    }\n  }\n}\n\nexport const deleteSelection: RawCommands['deleteSelection'] = () => ({ state, dispatch }) => {\n  return originalDeleteSelection(state, dispatch)\n}\n","import { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    enter: {\n      /**\n       * Trigger enter.\n       */\n      enter: () => ReturnType,\n    }\n  }\n}\n\nexport const enter: RawCommands['enter'] = () => ({ commands }) => {\n  return commands.keyboardShortcut('Enter')\n}\n","import { exitCode as originalExitCode } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    exitCode: {\n      /**\n       * Exit from a code block.\n       */\n      exitCode: () => ReturnType\n    }\n  }\n}\n\nexport const exitCode: RawCommands['exitCode'] = () => ({ state, dispatch }) => {\n  return originalExitCode(state, dispatch)\n}\n","import { isRegExp } from './isRegExp.js'\n\n/**\n * Check if object1 includes object2\n * @param object1 Object\n * @param object2 Object\n */\nexport function objectIncludes(\n  object1: Record<string, any>,\n  object2: Record<string, any>,\n  options: { strict: boolean } = { strict: true },\n): boolean {\n  const keys = Object.keys(object2)\n\n  if (!keys.length) {\n    return true\n  }\n\n  return keys.every(key => {\n    if (options.strict) {\n      return object2[key] === object1[key]\n    }\n\n    if (isRegExp(object2[key])) {\n      return object2[key].test(object1[key])\n    }\n\n    return object2[key] === object1[key]\n  })\n}\n","import { Mark as ProseMirrorMark, MarkType, ResolvedPos } from '@tiptap/pm/model'\n\nimport { Range } from '../types.js'\nimport { objectIncludes } from '../utilities/objectIncludes.js'\n\nfunction findMarkInSet(\n  marks: ProseMirrorMark[],\n  type: MarkType,\n  attributes: Record<string, any> = {},\n): ProseMirrorMark | undefined {\n  return marks.find(item => {\n    return item.type === type && objectIncludes(item.attrs, attributes)\n  })\n}\n\nfunction isMarkInSet(\n  marks: ProseMirrorMark[],\n  type: MarkType,\n  attributes: Record<string, any> = {},\n): boolean {\n  return !!findMarkInSet(marks, type, attributes)\n}\n\nexport function getMarkRange(\n  $pos: ResolvedPos,\n  type: MarkType,\n  attributes: Record<string, any> = {},\n): Range | void {\n  if (!$pos || !type) {\n    return\n  }\n\n  let start = $pos.parent.childAfter($pos.parentOffset)\n\n  if ($pos.parentOffset === start.offset && start.offset !== 0) {\n    start = $pos.parent.childBefore($pos.parentOffset)\n  }\n\n  if (!start.node) {\n    return\n  }\n\n  const mark = findMarkInSet([...start.node.marks], type, attributes)\n\n  if (!mark) {\n    return\n  }\n\n  let startIndex = start.index\n  let startPos = $pos.start() + start.offset\n  let endIndex = startIndex + 1\n  let endPos = startPos + start.node.nodeSize\n\n  findMarkInSet([...start.node.marks], type, attributes)\n\n  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {\n    startIndex -= 1\n    startPos -= $pos.parent.child(startIndex).nodeSize\n  }\n\n  while (\n    endIndex < $pos.parent.childCount\n    && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)\n  ) {\n    endPos += $pos.parent.child(endIndex).nodeSize\n    endIndex += 1\n  }\n\n  return {\n    from: startPos,\n    to: endPos,\n  }\n}\n","import { MarkType, Schema } from '@tiptap/pm/model'\n\nexport function getMarkType(nameOrType: string | MarkType, schema: Schema): MarkType {\n  if (typeof nameOrType === 'string') {\n    if (!schema.marks[nameOrType]) {\n      throw Error(\n        `There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`,\n      )\n    }\n\n    return schema.marks[nameOrType]\n  }\n\n  return nameOrType\n}\n","import { MarkType } from '@tiptap/pm/model'\nimport { TextSelection } from '@tiptap/pm/state'\n\nimport { getMarkRange } from '../helpers/getMarkRange.js'\nimport { getMarkType } from '../helpers/getMarkType.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    extendMarkRange: {\n      /**\n       * Extends the text selection to the current mark.\n       */\n      extendMarkRange: (\n        typeOrName: string | MarkType,\n        attributes?: Record<string, any>,\n      ) => ReturnType\n    }\n  }\n}\n\nexport const extendMarkRange: RawCommands['extendMarkRange'] = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  const type = getMarkType(typeOrName, state.schema)\n  const { doc, selection } = tr\n  const { $from, from, to } = selection\n\n  if (dispatch) {\n    const range = getMarkRange($from, type, attributes)\n\n    if (range && range.from <= from && range.to >= to) {\n      const newSelection = TextSelection.create(doc, range.from, range.to)\n\n      tr.setSelection(newSelection)\n    }\n  }\n\n  return true\n}\n","import { Command, CommandProps, RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    first: {\n      /**\n       * Runs one command after the other and stops at the first which returns true.\n       */\n      first: (commands: Command[] | ((props: CommandProps) => Command[])) => ReturnType,\n    }\n  }\n}\n\nexport const first: RawCommands['first'] = commands => props => {\n  const items = typeof commands === 'function'\n    ? commands(props)\n    : commands\n\n  for (let i = 0; i < items.length; i += 1) {\n    if (items[i](props)) {\n      return true\n    }\n  }\n\n  return false\n}\n","import { TextSelection } from '@tiptap/pm/state'\n\nexport function isTextSelection(value: unknown): value is TextSelection {\n  return value instanceof TextSelection\n}\n","export function minMax(value = 0, min = 0, max = 0): number {\n  return Math.min(Math.max(value, min), max)\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { Selection, TextSelection } from '@tiptap/pm/state'\n\nimport { FocusPosition } from '../types.js'\nimport { minMax } from '../utilities/minMax.js'\n\nexport function resolveFocusPosition(\n  doc: ProseMirrorNode,\n  position: FocusPosition = null,\n): Selection | null {\n  if (!position) {\n    return null\n  }\n\n  const selectionAtStart = Selection.atStart(doc)\n  const selectionAtEnd = Selection.atEnd(doc)\n\n  if (position === 'start' || position === true) {\n    return selectionAtStart\n  }\n\n  if (position === 'end') {\n    return selectionAtEnd\n  }\n\n  const minPos = selectionAtStart.from\n  const maxPos = selectionAtEnd.to\n\n  if (position === 'all') {\n    return TextSelection.create(\n      doc,\n      minMax(0, minPos, maxPos),\n      minMax(doc.content.size, minPos, maxPos),\n    )\n  }\n\n  return TextSelection.create(\n    doc,\n    minMax(position, minPos, maxPos),\n    minMax(position, minPos, maxPos),\n  )\n}\n","export function isiOS(): boolean {\n  return [\n    'iPad Simulator',\n    'iPhone Simulator',\n    'iPod Simulator',\n    'iPad',\n    'iPhone',\n    'iPod',\n  ].includes(navigator.platform)\n  // iPad on iOS 13 detection\n  || (navigator.userAgent.includes('Mac') && 'ontouchend' in document)\n}\n","import { isTextSelection } from '../helpers/isTextSelection.js'\nimport { resolveFocusPosition } from '../helpers/resolveFocusPosition.js'\nimport { FocusPosition, RawCommands } from '../types.js'\nimport { isiOS } from '../utilities/isiOS.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    focus: {\n      /**\n       * Focus the editor at the given position.\n       */\n      focus: (\n        position?: FocusPosition,\n        options?: {\n          scrollIntoView?: boolean,\n        },\n      ) => ReturnType,\n    }\n  }\n}\n\nexport const focus: RawCommands['focus'] = (position = null, options = {}) => ({\n  editor,\n  view,\n  tr,\n  dispatch,\n}) => {\n  options = {\n    scrollIntoView: true,\n    ...options,\n  }\n\n  const delayedFocus = () => {\n    // focus within `requestAnimationFrame` breaks focus on iOS\n    // so we have to call this\n    if (isiOS()) {\n      (view.dom as HTMLElement).focus()\n    }\n\n    // For React we have to focus asynchronously. Otherwise wild things happen.\n    // see: https://github.com/ueberdosis/tiptap/issues/1520\n    requestAnimationFrame(() => {\n      if (!editor.isDestroyed) {\n        view.focus()\n\n        if (options?.scrollIntoView) {\n          editor.commands.scrollIntoView()\n        }\n      }\n    })\n  }\n\n  if ((view.hasFocus() && position === null) || position === false) {\n    return true\n  }\n\n  // we don’t try to resolve a NodeSelection or CellSelection\n  if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\n    delayedFocus()\n    return true\n  }\n\n  // pass through tr.doc instead of editor.state.doc\n  // since transactions could change the editors state before this command has been run\n  const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection\n  const isSameSelection = editor.state.selection.eq(selection)\n\n  if (dispatch) {\n    if (!isSameSelection) {\n      tr.setSelection(selection)\n    }\n\n    // `tr.setSelection` resets the stored marks\n    // so we’ll restore them if the selection is the same as before\n    if (isSameSelection && tr.storedMarks) {\n      tr.setStoredMarks(tr.storedMarks)\n    }\n\n    delayedFocus()\n  }\n\n  return true\n}\n","import { CommandProps, RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    forEach: {\n      /**\n       * Loop through an array of items.\n       */\n      forEach: <T>(\n        items: T[],\n        fn: (\n          item: T,\n          props: CommandProps & {\n            index: number,\n          },\n        ) => boolean,\n      ) => ReturnType,\n    }\n  }\n}\n\nexport const forEach: RawCommands['forEach'] = (items, fn) => props => {\n  return items.every((item, index) => fn(item, { ...props, index }))\n}\n","import { ParseOptions } from '@tiptap/pm/model'\n\nimport { Content, RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    insertContent: {\n      /**\n       * Insert a node or string of HTML at the current position.\n       */\n      insertContent: (\n        value: Content,\n        options?: {\n          parseOptions?: ParseOptions\n          updateSelection?: boolean\n        },\n      ) => ReturnType\n    }\n  }\n}\n\nexport const insertContent: RawCommands['insertContent'] = (value, options) => ({ tr, commands }) => {\n  return commands.insertContentAt(\n    { from: tr.selection.from, to: tr.selection.to },\n    value,\n    options,\n  )\n}\n","export function elementFromString(value: string): HTMLElement {\n  // add a wrapper to preserve leading and trailing whitespace\n  const wrappedValue = `<body>${value}</body>`\n\n  return new window.DOMParser().parseFromString(wrappedValue, 'text/html').body\n}\n","import {\n  DOMParser,\n  Fragment,\n  Node as ProseMirrorNode,\n  ParseOptions,\n  Schema,\n} from '@tiptap/pm/model'\n\nimport { Content } from '../types.js'\nimport { elementFromString } from '../utilities/elementFromString.js'\n\nexport type CreateNodeFromContentOptions = {\n  slice?: boolean\n  parseOptions?: ParseOptions\n}\n\nexport function createNodeFromContent(\n  content: Content,\n  schema: Schema,\n  options?: CreateNodeFromContentOptions,\n): ProseMirrorNode | Fragment {\n  options = {\n    slice: true,\n    parseOptions: {},\n    ...options,\n  }\n\n  if (typeof content === 'object' && content !== null) {\n    try {\n      if (Array.isArray(content) && content.length > 0) {\n        return Fragment.fromArray(content.map(item => schema.nodeFromJSON(item)))\n      }\n\n      return schema.nodeFromJSON(content)\n    } catch (error) {\n      console.warn('[tiptap warn]: Invalid content.', 'Passed value:', content, 'Error:', error)\n\n      return createNodeFromContent('', schema, options)\n    }\n  }\n\n  if (typeof content === 'string') {\n    const parser = DOMParser.fromSchema(schema)\n\n    return options.slice\n      ? parser.parseSlice(elementFromString(content), options.parseOptions).content\n      : parser.parse(elementFromString(content), options.parseOptions)\n  }\n\n  return createNodeFromContent('', schema, options)\n}\n","import { Selection, Transaction } from '@tiptap/pm/state'\nimport { ReplaceAroundStep, ReplaceStep } from '@tiptap/pm/transform'\n\n// source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466\nexport function selectionToInsertionEnd(tr: Transaction, startLen: number, bias: number) {\n  const last = tr.steps.length - 1\n\n  if (last < startLen) {\n    return\n  }\n\n  const step = tr.steps[last]\n\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {\n    return\n  }\n\n  const map = tr.mapping.maps[last]\n  let end = 0\n\n  map.forEach((_from, _to, _newFrom, newTo) => {\n    if (end === 0) {\n      end = newTo\n    }\n  })\n\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias))\n}\n","import { Fragment, Node as ProseMirrorNode, ParseOptions } from '@tiptap/pm/model'\n\nimport { createNodeFromContent } from '../helpers/createNodeFromContent.js'\nimport { selectionToInsertionEnd } from '../helpers/selectionToInsertionEnd.js'\nimport { Content, Range, RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    insertContentAt: {\n      /**\n       * Insert a node or string of HTML at a specific position.\n       */\n      insertContentAt: (\n        position: number | Range,\n        value: Content,\n        options?: {\n          parseOptions?: ParseOptions\n          updateSelection?: boolean\n        },\n      ) => ReturnType\n    }\n  }\n}\n\nconst isFragment = (nodeOrFragment: ProseMirrorNode | Fragment): nodeOrFragment is Fragment => {\n  return nodeOrFragment.toString().startsWith('<')\n}\n\nexport const insertContentAt: RawCommands['insertContentAt'] = (position, value, options) => ({ tr, dispatch, editor }) => {\n  if (dispatch) {\n    options = {\n      parseOptions: {},\n      updateSelection: true,\n      ...options,\n    }\n\n    const content = createNodeFromContent(value, editor.schema, {\n      parseOptions: {\n        preserveWhitespace: 'full',\n        ...options.parseOptions,\n      },\n    })\n\n    // don’t dispatch an empty fragment because this can lead to strange errors\n    if (content.toString() === '<>') {\n      return true\n    }\n\n    let { from, to } = typeof position === 'number' ? { from: position, to: position } : { from: position.from, to: position.to }\n\n    let isOnlyTextContent = true\n    let isOnlyBlockContent = true\n    const nodes = isFragment(content) ? content : [content]\n\n    nodes.forEach(node => {\n      // check if added node is valid\n      node.check()\n\n      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false\n\n      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false\n    })\n\n    // check if we can replace the wrapping node by\n    // the newly inserted content\n    // example:\n    // replace an empty paragraph by an inserted image\n    // instead of inserting the image below the paragraph\n    if (from === to && isOnlyBlockContent) {\n      const { parent } = tr.doc.resolve(from)\n      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount\n\n      if (isEmptyTextBlock) {\n        from -= 1\n        to += 1\n      }\n    }\n\n    // if there is only plain text we have to use `insertText`\n    // because this will keep the current marks\n    if (isOnlyTextContent) {\n      // if value is string, we can use it directly\n      // otherwise if it is an array, we have to join it\n      if (Array.isArray(value)) {\n        tr.insertText(value.map(v => v.text || '').join(''), from, to)\n      } else if (typeof value === 'object' && !!value && !!value.text) {\n        tr.insertText(value.text, from, to)\n      } else {\n        tr.insertText(value as string, from, to)\n      }\n    } else {\n      tr.replaceWith(from, to, content)\n    }\n\n    // set cursor at end of inserted content\n    if (options.updateSelection) {\n      selectionToInsertionEnd(tr, tr.steps.length - 1, -1)\n    }\n  }\n\n  return true\n}\n","import {\n  joinBackward as originalJoinBackward,\n  joinDown as originalJoinDown,\n  joinForward as originalJoinForward,\n  joinUp as originalJoinUp,\n} from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    joinUp: {\n      /**\n       * Join two nodes Up.\n       */\n      joinUp: () => ReturnType\n    }\n    joinDown: {\n      /**\n       * Join two nodes Down.\n       */\n      joinDown: () => ReturnType\n    }\n    joinBackward: {\n      /**\n       * Join two nodes Backwards.\n       */\n      joinBackward: () => ReturnType\n    }\n    joinForward: {\n      /**\n       * Join two nodes Forwards.\n       */\n      joinForward: () => ReturnType\n    }\n  }\n}\n\nexport const joinUp: RawCommands['joinUp'] = () => ({ state, dispatch }) => {\n  return originalJoinUp(state, dispatch)\n}\n\nexport const joinDown: RawCommands['joinDown'] = () => ({ state, dispatch }) => {\n  return originalJoinDown(state, dispatch)\n}\n\nexport const joinBackward: RawCommands['joinBackward'] = () => ({ state, dispatch }) => {\n  return originalJoinBackward(state, dispatch)\n}\n\nexport const joinForward: RawCommands['joinForward'] = () => ({ state, dispatch }) => {\n  return originalJoinForward(state, dispatch)\n}\n","import { joinPoint } from '@tiptap/pm/transform'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    joinItemBackward: {\n      /**\n       * Join two nodes Forwards.\n       */\n      joinItemBackward: () => ReturnType\n    }\n  }\n}\n\nexport const joinItemBackward: RawCommands['joinItemBackward'] = () => ({\n  tr, state, dispatch,\n}) => {\n  try {\n    const point = joinPoint(state.doc, state.selection.$from.pos, -1)\n\n    if (point === null || point === undefined) {\n      return false\n    }\n\n    tr.join(point, 2)\n\n    if (dispatch) {\n      dispatch(tr)\n    }\n\n    return true\n  } catch {\n    return false\n  }\n}\n","import { joinPoint } from '@tiptap/pm/transform'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    joinItemForward: {\n      /**\n       * Join two nodes Forwards.\n       */\n      joinItemForward: () => ReturnType\n    }\n  }\n}\n\nexport const joinItemForward: RawCommands['joinItemForward'] = () => ({\n  state,\n  dispatch,\n  tr,\n}) => {\n  try {\n    const point = joinPoint(state.doc, state.selection.$from.pos, +1)\n\n    if (point === null || point === undefined) {\n      return false\n    }\n\n    tr.join(point, 2)\n\n    if (dispatch) {\n      dispatch(tr)\n    }\n\n    return true\n  } catch (e) {\n    return false\n  }\n}\n","export function isMacOS(): boolean {\n  return typeof navigator !== 'undefined'\n    ? /Mac/.test(navigator.platform)\n    : false\n}\n","import { RawCommands } from '../types.js'\nimport { isiOS } from '../utilities/isiOS.js'\nimport { isMacOS } from '../utilities/isMacOS.js'\n\nfunction normalizeKeyName(name: string) {\n  const parts = name.split(/-(?!$)/)\n  let result = parts[parts.length - 1]\n\n  if (result === 'Space') {\n    result = ' '\n  }\n\n  let alt\n  let ctrl\n  let shift\n  let meta\n\n  for (let i = 0; i < parts.length - 1; i += 1) {\n    const mod = parts[i]\n\n    if (/^(cmd|meta|m)$/i.test(mod)) {\n      meta = true\n    } else if (/^a(lt)?$/i.test(mod)) {\n      alt = true\n    } else if (/^(c|ctrl|control)$/i.test(mod)) {\n      ctrl = true\n    } else if (/^s(hift)?$/i.test(mod)) {\n      shift = true\n    } else if (/^mod$/i.test(mod)) {\n      if (isiOS() || isMacOS()) {\n        meta = true\n      } else {\n        ctrl = true\n      }\n    } else {\n      throw new Error(`Unrecognized modifier name: ${mod}`)\n    }\n  }\n\n  if (alt) {\n    result = `Alt-${result}`\n  }\n\n  if (ctrl) {\n    result = `Ctrl-${result}`\n  }\n\n  if (meta) {\n    result = `Meta-${result}`\n  }\n\n  if (shift) {\n    result = `Shift-${result}`\n  }\n\n  return result\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    keyboardShortcut: {\n      /**\n       * Trigger a keyboard shortcut.\n       */\n      keyboardShortcut: (name: string) => ReturnType,\n    }\n  }\n}\n\nexport const keyboardShortcut: RawCommands['keyboardShortcut'] = name => ({\n  editor,\n  view,\n  tr,\n  dispatch,\n}) => {\n  const keys = normalizeKeyName(name).split(/-(?!$)/)\n  const key = keys.find(item => !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(item))\n  const event = new KeyboardEvent('keydown', {\n    key: key === 'Space'\n      ? ' '\n      : key,\n    altKey: keys.includes('Alt'),\n    ctrlKey: keys.includes('Ctrl'),\n    metaKey: keys.includes('Meta'),\n    shiftKey: keys.includes('Shift'),\n    bubbles: true,\n    cancelable: true,\n  })\n\n  const capturedTransaction = editor.captureTransaction(() => {\n    view.someProp('handleKeyDown', f => f(view, event))\n  })\n\n  capturedTransaction?.steps.forEach(step => {\n    const newStep = step.map(tr.mapping)\n\n    if (newStep && dispatch) {\n      tr.maybeStep(newStep)\n    }\n  })\n\n  return true\n}\n","import { NodeType } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\nimport { NodeRange } from '../types.js'\nimport { objectIncludes } from '../utilities/objectIncludes.js'\nimport { getNodeType } from './getNodeType.js'\n\nexport function isNodeActive(\n  state: EditorState,\n  typeOrName: NodeType | string | null,\n  attributes: Record<string, any> = {},\n): boolean {\n  const { from, to, empty } = state.selection\n  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null\n\n  const nodeRanges: NodeRange[] = []\n\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isText) {\n      return\n    }\n\n    const relativeFrom = Math.max(from, pos)\n    const relativeTo = Math.min(to, pos + node.nodeSize)\n\n    nodeRanges.push({\n      node,\n      from: relativeFrom,\n      to: relativeTo,\n    })\n  })\n\n  const selectionRange = to - from\n  const matchedNodeRanges = nodeRanges\n    .filter(nodeRange => {\n      if (!type) {\n        return true\n      }\n\n      return type.name === nodeRange.node.type.name\n    })\n    .filter(nodeRange => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }))\n\n  if (empty) {\n    return !!matchedNodeRanges.length\n  }\n\n  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0)\n\n  return range >= selectionRange\n}\n","import { lift as originalLift } from '@tiptap/pm/commands'\nimport { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { isNodeActive } from '../helpers/isNodeActive.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    lift: {\n      /**\n       * Removes an existing wrap.\n       */\n      lift: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const lift: RawCommands['lift'] = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const isActive = isNodeActive(state, type, attributes)\n\n  if (!isActive) {\n    return false\n  }\n\n  return originalLift(state, dispatch)\n}\n","import { liftEmptyBlock as originalLiftEmptyBlock } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    liftEmptyBlock: {\n      /**\n       * Lift block if empty.\n       */\n      liftEmptyBlock: () => ReturnType,\n    }\n  }\n}\n\nexport const liftEmptyBlock: RawCommands['liftEmptyBlock'] = () => ({ state, dispatch }) => {\n  return originalLiftEmptyBlock(state, dispatch)\n}\n","import { NodeType } from '@tiptap/pm/model'\nimport { liftListItem as originalLiftListItem } from '@tiptap/pm/schema-list'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    liftListItem: {\n      /**\n       * Lift the list item into a wrapping list.\n       */\n      liftListItem: (typeOrName: string | NodeType) => ReturnType\n    }\n  }\n}\n\nexport const liftListItem: RawCommands['liftListItem'] = typeOrName => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalLiftListItem(type)(state, dispatch)\n}\n","import { newlineInCode as originalNewlineInCode } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    newlineInCode: {\n      /**\n       * Add a newline character in code.\n       */\n      newlineInCode: () => ReturnType\n    }\n  }\n}\n\nexport const newlineInCode: RawCommands['newlineInCode'] = () => ({ state, dispatch }) => {\n  return originalNewlineInCode(state, dispatch)\n}\n","import { Schema } from '@tiptap/pm/model'\n\nexport function getSchemaTypeNameByName(name: string, schema: Schema): 'node' | 'mark' | null {\n  if (schema.nodes[name]) {\n    return 'node'\n  }\n\n  if (schema.marks[name]) {\n    return 'mark'\n  }\n\n  return null\n}\n","/**\n * Remove a property or an array of properties from an object\n * @param obj Object\n * @param key Key to remove\n */\nexport function deleteProps(obj: Record<string, any>, propOrProps: string | string[]): Record<string, any> {\n  const props = typeof propOrProps === 'string'\n    ? [propOrProps]\n    : propOrProps\n\n  return Object\n    .keys(obj)\n    .reduce((newObj: Record<string, any>, prop) => {\n      if (!props.includes(prop)) {\n        newObj[prop] = obj[prop]\n      }\n\n      return newObj\n    }, {})\n}\n","import { MarkType, NodeType } from '@tiptap/pm/model'\n\nimport { getMarkType } from '../helpers/getMarkType.js'\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { getSchemaTypeNameByName } from '../helpers/getSchemaTypeNameByName.js'\nimport { RawCommands } from '../types.js'\nimport { deleteProps } from '../utilities/deleteProps.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    resetAttributes: {\n      /**\n       * Resets some node attributes to the default value.\n       */\n      resetAttributes: (\n        typeOrName: string | NodeType | MarkType,\n        attributes: string | string[],\n      ) => ReturnType\n    }\n  }\n}\n\nexport const resetAttributes: RawCommands['resetAttributes'] = (typeOrName, attributes) => ({ tr, state, dispatch }) => {\n  let nodeType: NodeType | null = null\n  let markType: MarkType | null = null\n\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === 'string' ? typeOrName : typeOrName.name,\n    state.schema,\n  )\n\n  if (!schemaType) {\n    return false\n  }\n\n  if (schemaType === 'node') {\n    nodeType = getNodeType(typeOrName as NodeType, state.schema)\n  }\n\n  if (schemaType === 'mark') {\n    markType = getMarkType(typeOrName as MarkType, state.schema)\n  }\n\n  if (dispatch) {\n    tr.selection.ranges.forEach(range => {\n      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes))\n        }\n\n        if (markType && node.marks.length) {\n          node.marks.forEach(mark => {\n            if (markType === mark.type) {\n              tr.addMark(\n                pos,\n                pos + node.nodeSize,\n                markType.create(deleteProps(mark.attrs, attributes)),\n              )\n            }\n          })\n        }\n      })\n    })\n  }\n\n  return true\n}\n","import { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    scrollIntoView: {\n      /**\n       * Scroll the selection into view.\n       */\n      scrollIntoView: () => ReturnType,\n    }\n  }\n}\n\nexport const scrollIntoView: RawCommands['scrollIntoView'] = () => ({ tr, dispatch }) => {\n  if (dispatch) {\n    tr.scrollIntoView()\n  }\n\n  return true\n}\n","import { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectAll: {\n      /**\n       * Select the whole document.\n       */\n      selectAll: () => ReturnType,\n    }\n  }\n}\n\nexport const selectAll: RawCommands['selectAll'] = () => ({ tr, commands }) => {\n  return commands.setTextSelection({\n    from: 0,\n    to: tr.doc.content.size,\n  })\n}\n","import { selectNodeBackward as originalSelectNodeBackward } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectNodeBackward: {\n      /**\n       * Select a node backward.\n       */\n      selectNodeBackward: () => ReturnType\n    }\n  }\n}\n\nexport const selectNodeBackward: RawCommands['selectNodeBackward'] = () => ({ state, dispatch }) => {\n  return originalSelectNodeBackward(state, dispatch)\n}\n","import { selectNodeForward as originalSelectNodeForward } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectNodeForward: {\n      /**\n       * Select a node forward.\n       */\n      selectNodeForward: () => ReturnType\n    }\n  }\n}\n\nexport const selectNodeForward: RawCommands['selectNodeForward'] = () => ({ state, dispatch }) => {\n  return originalSelectNodeForward(state, dispatch)\n}\n","import { selectParentNode as originalSelectParentNode } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectParentNode: {\n      /**\n       * Select the parent node.\n       */\n      selectParentNode: () => ReturnType\n    }\n  }\n}\n\nexport const selectParentNode: RawCommands['selectParentNode'] = () => ({ state, dispatch }) => {\n  return originalSelectParentNode(state, dispatch)\n}\n","// @ts-ignore\n// TODO: add types to @types/prosemirror-commands\nimport { selectTextblockEnd as originalSelectTextblockEnd } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectTextblockEnd: {\n      /**\n       * Moves the cursor to the end of current text block.\n       */\n      selectTextblockEnd: () => ReturnType\n    }\n  }\n}\n\nexport const selectTextblockEnd: RawCommands['selectTextblockEnd'] = () => ({ state, dispatch }) => {\n  return originalSelectTextblockEnd(state, dispatch)\n}\n","// @ts-ignore\n// TODO: add types to @types/prosemirror-commands\nimport { selectTextblockStart as originalSelectTextblockStart } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectTextblockStart: {\n      /**\n       * Moves the cursor to the start of current text block.\n       */\n      selectTextblockStart: () => ReturnType\n    }\n  }\n}\n\nexport const selectTextblockStart: RawCommands['selectTextblockStart'] = () => ({ state, dispatch }) => {\n  return originalSelectTextblockStart(state, dispatch)\n}\n","import { Node as ProseMirrorNode, ParseOptions, Schema } from '@tiptap/pm/model'\n\nimport { Content } from '../types.js'\nimport { createNodeFromContent } from './createNodeFromContent.js'\n\nexport function createDocument(\n  content: Content,\n  schema: Schema,\n  parseOptions: ParseOptions = {},\n): ProseMirrorNode {\n  return createNodeFromContent(content, schema, { slice: false, parseOptions }) as ProseMirrorNode\n}\n","import { ParseOptions } from '@tiptap/pm/model'\n\nimport { createDocument } from '../helpers/createDocument.js'\nimport { Content, RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setContent: {\n      /**\n       * Replace the whole document with new content.\n       */\n      setContent: (\n        content: Content,\n        emitUpdate?: boolean,\n        parseOptions?: ParseOptions,\n      ) => ReturnType\n    }\n  }\n}\n\nexport const setContent: RawCommands['setContent'] = (content, emitUpdate = false, parseOptions = {}) => ({ tr, editor, dispatch }) => {\n  const { doc } = tr\n  const document = createDocument(content, editor.schema, parseOptions)\n\n  if (dispatch) {\n    tr.replaceWith(0, doc.content.size, document).setMeta('preventUpdate', !emitUpdate)\n  }\n\n  return true\n}\n","import { Mark, MarkType } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\nimport { getMarkType } from './getMarkType.js'\n\nexport function getMarkAttributes(\n  state: EditorState,\n  typeOrName: string | MarkType,\n): Record<string, any> {\n  const type = getMarkType(typeOrName, state.schema)\n  const { from, to, empty } = state.selection\n  const marks: Mark[] = []\n\n  if (empty) {\n    if (state.storedMarks) {\n      marks.push(...state.storedMarks)\n    }\n\n    marks.push(...state.selection.$head.marks())\n  } else {\n    state.doc.nodesBetween(from, to, node => {\n      marks.push(...node.marks)\n    })\n  }\n\n  const mark = marks.find(markItem => markItem.type.name === type.name)\n\n  if (!mark) {\n    return {}\n  }\n\n  return { ...mark.attrs }\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { Transaction } from '@tiptap/pm/state'\nimport { Transform } from '@tiptap/pm/transform'\n\n/**\n * Returns a new `Transform` based on all steps of the passed transactions.\n */\nexport function combineTransactionSteps(\n  oldDoc: ProseMirrorNode,\n  transactions: Transaction[],\n): Transform {\n  const transform = new Transform(oldDoc)\n\n  transactions.forEach(transaction => {\n    transaction.steps.forEach(step => {\n      transform.step(step)\n    })\n  })\n\n  return transform\n}\n","import { ContentMatch, NodeType } from '@tiptap/pm/model'\n\nexport function defaultBlockAt(match: ContentMatch): NodeType | null {\n  for (let i = 0; i < match.edgeCount; i += 1) {\n    const { type } = match.edge(i)\n\n    if (type.isTextblock && !type.hasRequiredAttrs()) {\n      return type\n    }\n  }\n\n  return null\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { NodeWithPos, Predicate } from '../types.js'\n\nexport function findChildren(node: ProseMirrorNode, predicate: Predicate): NodeWithPos[] {\n  const nodesWithPos: NodeWithPos[] = []\n\n  node.descendants((child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos,\n      })\n    }\n  })\n\n  return nodesWithPos\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { NodeWithPos, Predicate, Range } from '../types.js'\n\n/**\n * Same as `findChildren` but searches only within a `range`.\n */\nexport function findChildrenInRange(\n  node: ProseMirrorNode,\n  range: Range,\n  predicate: Predicate,\n): NodeWithPos[] {\n  const nodesWithPos: NodeWithPos[] = []\n\n  // if (range.from === range.to) {\n  //   const nodeAt = node.nodeAt(range.from)\n\n  //   if (nodeAt) {\n  //     nodesWithPos.push({\n  //       node: nodeAt,\n  //       pos: range.from,\n  //     })\n  //   }\n  // }\n\n  node.nodesBetween(range.from, range.to, (child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos,\n      })\n    }\n  })\n\n  return nodesWithPos\n}\n","import { Node as ProseMirrorNode, ResolvedPos } from '@tiptap/pm/model'\n\nimport { Predicate } from '../types.js'\n\nexport function findParentNodeClosestToPos(\n  $pos: ResolvedPos,\n  predicate: Predicate,\n):\n  | {\n      pos: number\n      start: number\n      depth: number\n      node: ProseMirrorNode\n    }\n  | undefined {\n  for (let i = $pos.depth; i > 0; i -= 1) {\n    const node = $pos.node(i)\n\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node,\n      }\n    }\n  }\n}\n","import { Selection } from '@tiptap/pm/state'\n\nimport { Predicate } from '../types.js'\nimport { findParentNodeClosestToPos } from './findParentNodeClosestToPos.js'\n\nexport function findParentNode(predicate: Predicate) {\n  return (selection: Selection) => findParentNodeClosestToPos(selection.$from, predicate)\n}\n","import { DOMSerializer, Fragment, Schema } from '@tiptap/pm/model'\n\nexport function getHTMLFromFragment(fragment: Fragment, schema: Schema): string {\n  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment)\n\n  const temporaryDocument = document.implementation.createHTMLDocument()\n  const container = temporaryDocument.createElement('div')\n\n  container.appendChild(documentFragment)\n\n  return container.innerHTML\n}\n","import { Schema } from '@tiptap/pm/model'\n\nimport { Editor } from '../Editor.js'\nimport { ExtensionManager } from '../ExtensionManager.js'\nimport { Extensions } from '../types.js'\nimport { getSchemaByResolvedExtensions } from './getSchemaByResolvedExtensions.js'\n\nexport function getSchema(extensions: Extensions, editor?: Editor): Schema {\n  const resolvedExtensions = ExtensionManager.resolve(extensions)\n\n  return getSchemaByResolvedExtensions(resolvedExtensions, editor)\n}\n","import { Node } from '@tiptap/pm/model'\n\nimport { Extensions, JSONContent } from '../types.js'\nimport { getHTMLFromFragment } from './getHTMLFromFragment.js'\nimport { getSchema } from './getSchema.js'\n\nexport function generateHTML(doc: JSONContent, extensions: Extensions): string {\n  const schema = getSchema(extensions)\n  const contentNode = Node.fromJSON(schema, doc)\n\n  return getHTMLFromFragment(contentNode.content, schema)\n}\n","import { DOMParser } from '@tiptap/pm/model'\n\nimport { Extensions } from '../types.js'\nimport { elementFromString } from '../utilities/elementFromString.js'\nimport { getSchema } from './getSchema.js'\n\nexport function generateJSON(html: string, extensions: Extensions): Record<string, any> {\n  const schema = getSchema(extensions)\n  const dom = elementFromString(html)\n\n  return DOMParser.fromSchema(schema).parse(dom).toJSON()\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { TextSerializer } from '../types.js'\nimport { getTextBetween } from './getTextBetween.js'\n\nexport function getText(\n  node: ProseMirrorNode,\n  options?: {\n    blockSeparator?: string\n    textSerializers?: Record<string, TextSerializer>\n  },\n) {\n  const range = {\n    from: 0,\n    to: node.content.size,\n  }\n\n  return getTextBetween(node, range, options)\n}\n","import { Node } from '@tiptap/pm/model'\n\nimport { Extensions, JSONContent, TextSerializer } from '../types.js'\nimport { getSchema } from './getSchema.js'\nimport { getText } from './getText.js'\nimport { getTextSerializersFromSchema } from './getTextSerializersFromSchema.js'\n\nexport function generateText(\n  doc: JSONContent,\n  extensions: Extensions,\n  options?: {\n    blockSeparator?: string\n    textSerializers?: Record<string, TextSerializer>\n  },\n): string {\n  const { blockSeparator = '\\n\\n', textSerializers = {} } = options || {}\n  const schema = getSchema(extensions)\n  const contentNode = Node.fromJSON(schema, doc)\n\n  return getText(contentNode, {\n    blockSeparator,\n    textSerializers: {\n      ...getTextSerializersFromSchema(schema),\n      ...textSerializers,\n    },\n  })\n}\n","import { Node, NodeType } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\nimport { getNodeType } from './getNodeType.js'\n\nexport function getNodeAttributes(\n  state: EditorState,\n  typeOrName: string | NodeType,\n): Record<string, any> {\n  const type = getNodeType(typeOrName, state.schema)\n  const { from, to } = state.selection\n  const nodes: Node[] = []\n\n  state.doc.nodesBetween(from, to, node => {\n    nodes.push(node)\n  })\n\n  const node = nodes.reverse().find(nodeItem => nodeItem.type.name === type.name)\n\n  if (!node) {\n    return {}\n  }\n\n  return { ...node.attrs }\n}\n","import { MarkType, NodeType } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\nimport { getMarkAttributes } from './getMarkAttributes.js'\nimport { getNodeAttributes } from './getNodeAttributes.js'\nimport { getSchemaTypeNameByName } from './getSchemaTypeNameByName.js'\n\nexport function getAttributes(\n  state: EditorState,\n  typeOrName: string | NodeType | MarkType,\n): Record<string, any> {\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === 'string' ? typeOrName : typeOrName.name,\n    state.schema,\n  )\n\n  if (schemaType === 'node') {\n    return getNodeAttributes(state, typeOrName as NodeType)\n  }\n\n  if (schemaType === 'mark') {\n    return getMarkAttributes(state, typeOrName as MarkType)\n  }\n\n  return {}\n}\n","/**\n * Removes duplicated values within an array.\n * Supports numbers, strings and objects.\n */\nexport function removeDuplicates<T>(array: T[], by = JSON.stringify): T[] {\n  const seen: Record<any, any> = {}\n\n  return array.filter(item => {\n    const key = by(item)\n\n    return Object.prototype.hasOwnProperty.call(seen, key)\n      ? false\n      : (seen[key] = true)\n  })\n}\n","import { Step, Transform } from '@tiptap/pm/transform'\n\nimport { Range } from '../types.js'\nimport { removeDuplicates } from '../utilities/removeDuplicates.js'\n\nexport type ChangedRange = {\n  oldRange: Range,\n  newRange: Range,\n}\n\n/**\n * Removes duplicated ranges and ranges that are\n * fully captured by other ranges.\n */\nfunction simplifyChangedRanges(changes: ChangedRange[]): ChangedRange[] {\n  const uniqueChanges = removeDuplicates(changes)\n\n  return uniqueChanges.length === 1\n    ? uniqueChanges\n    : uniqueChanges.filter((change, index) => {\n      const rest = uniqueChanges.filter((_, i) => i !== index)\n\n      return !rest.some(otherChange => {\n        return change.oldRange.from >= otherChange.oldRange.from\n          && change.oldRange.to <= otherChange.oldRange.to\n          && change.newRange.from >= otherChange.newRange.from\n          && change.newRange.to <= otherChange.newRange.to\n      })\n    })\n}\n\n/**\n * Returns a list of changed ranges\n * based on the first and last state of all steps.\n */\nexport function getChangedRanges(transform: Transform): ChangedRange[] {\n  const { mapping, steps } = transform\n  const changes: ChangedRange[] = []\n\n  mapping.maps.forEach((stepMap, index) => {\n    const ranges: Range[] = []\n\n    // This accounts for step changes where no range was actually altered\n    // e.g. when setting a mark, node attribute, etc.\n    // @ts-ignore\n    if (!stepMap.ranges.length) {\n      const { from, to } = steps[index] as Step & {\n        from?: number,\n        to?: number,\n      }\n\n      if (from === undefined || to === undefined) {\n        return\n      }\n\n      ranges.push({ from, to })\n    } else {\n      stepMap.forEach((from, to) => {\n        ranges.push({ from, to })\n      })\n    }\n\n    ranges.forEach(({ from, to }) => {\n      const newStart = mapping.slice(index).map(from, -1)\n      const newEnd = mapping.slice(index).map(to)\n      const oldStart = mapping.invert().map(newStart, -1)\n      const oldEnd = mapping.invert().map(newEnd)\n\n      changes.push({\n        oldRange: {\n          from: oldStart,\n          to: oldEnd,\n        },\n        newRange: {\n          from: newStart,\n          to: newEnd,\n        },\n      })\n    })\n  })\n\n  return simplifyChangedRanges(changes)\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { JSONContent } from '../types.js'\n\ninterface DebugJSONContent extends JSONContent {\n  from: number\n  to: number\n}\n\nexport function getDebugJSON(node: ProseMirrorNode, startOffset = 0): DebugJSONContent {\n  const isTopNode = node.type === node.type.schema.topNodeType\n  const increment = isTopNode ? 0 : 1\n  const from = startOffset\n  const to = from + node.nodeSize\n  const marks = node.marks.map(mark => {\n    const output: { type: string; attrs?: Record<string, any> } = {\n      type: mark.type.name,\n    }\n\n    if (Object.keys(mark.attrs).length) {\n      output.attrs = { ...mark.attrs }\n    }\n\n    return output\n  })\n  const attrs = { ...node.attrs }\n  const output: DebugJSONContent = {\n    type: node.type.name,\n    from,\n    to,\n  }\n\n  if (Object.keys(attrs).length) {\n    output.attrs = attrs\n  }\n\n  if (marks.length) {\n    output.marks = marks\n  }\n\n  if (node.content.childCount) {\n    output.content = []\n\n    node.forEach((child, offset) => {\n      output.content?.push(getDebugJSON(child, startOffset + offset + increment))\n    })\n  }\n\n  if (node.text) {\n    output.text = node.text\n  }\n\n  return output\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { MarkRange } from '../types.js'\nimport { getMarkRange } from './getMarkRange.js'\n\nexport function getMarksBetween(from: number, to: number, doc: ProseMirrorNode): MarkRange[] {\n  const marks: MarkRange[] = []\n\n  // get all inclusive marks on empty selection\n  if (from === to) {\n    doc\n      .resolve(from)\n      .marks()\n      .forEach(mark => {\n        const $pos = doc.resolve(from - 1)\n        const range = getMarkRange($pos, mark.type)\n\n        if (!range) {\n          return\n        }\n\n        marks.push({\n          mark,\n          ...range,\n        })\n      })\n  } else {\n    doc.nodesBetween(from, to, (node, pos) => {\n      marks.push(\n        ...node.marks.map(mark => ({\n          from: pos,\n          to: pos + node.nodeSize,\n          mark,\n        })),\n      )\n    })\n  }\n\n  return marks\n}\n","import { Node, NodeType } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\n/**\n * Finds the first node of a given type or name in the current selection.\n * @param state The editor state.\n * @param typeOrName The node type or name.\n * @param pos The position to start searching from.\n * @param maxDepth The maximum depth to search.\n * @returns The node and the depth as an array.\n */\nexport const getNodeAtPosition = (state: EditorState, typeOrName: string | NodeType, pos: number, maxDepth = 20) => {\n  const $pos = state.doc.resolve(pos)\n\n  let currentDepth = maxDepth\n  let node: Node | null = null\n\n  while (currentDepth > 0 && node === null) {\n    const currentNode = $pos.node(currentDepth)\n\n    if (currentNode?.type.name === typeOrName) {\n      node = currentNode\n    } else {\n      currentDepth -= 1\n    }\n  }\n\n  return [node, currentDepth] as [Node | null, number]\n}\n","import { ExtensionAttribute } from '../types.js'\n\nexport function getSplittedAttributes(\n  extensionAttributes: ExtensionAttribute[],\n  typeName: string,\n  attributes: Record<string, any>,\n): Record<string, any> {\n  return Object.fromEntries(Object\n    .entries(attributes)\n    .filter(([name]) => {\n      const extensionAttribute = extensionAttributes.find(item => {\n        return item.type === typeName && item.name === name\n      })\n\n      if (!extensionAttribute) {\n        return false\n      }\n\n      return extensionAttribute.attribute.keepOnSplit\n    }))\n}\n","import { MarkType } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\nimport { MarkRange } from '../types.js'\nimport { objectIncludes } from '../utilities/objectIncludes.js'\nimport { getMarkType } from './getMarkType.js'\n\nexport function isMarkActive(\n  state: EditorState,\n  typeOrName: MarkType | string | null,\n  attributes: Record<string, any> = {},\n): boolean {\n  const { empty, ranges } = state.selection\n  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null\n\n  if (empty) {\n    return !!(state.storedMarks || state.selection.$from.marks())\n      .filter(mark => {\n        if (!type) {\n          return true\n        }\n\n        return type.name === mark.type.name\n      })\n      .find(mark => objectIncludes(mark.attrs, attributes, { strict: false }))\n  }\n\n  let selectionRange = 0\n  const markRanges: MarkRange[] = []\n\n  ranges.forEach(({ $from, $to }) => {\n    const from = $from.pos\n    const to = $to.pos\n\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (!node.isText && !node.marks.length) {\n        return\n      }\n\n      const relativeFrom = Math.max(from, pos)\n      const relativeTo = Math.min(to, pos + node.nodeSize)\n      const range = relativeTo - relativeFrom\n\n      selectionRange += range\n\n      markRanges.push(\n        ...node.marks.map(mark => ({\n          mark,\n          from: relativeFrom,\n          to: relativeTo,\n        })),\n      )\n    })\n  })\n\n  if (selectionRange === 0) {\n    return false\n  }\n\n  // calculate range of matched mark\n  const matchedRange = markRanges\n    .filter(markRange => {\n      if (!type) {\n        return true\n      }\n\n      return type.name === markRange.mark.type.name\n    })\n    .filter(markRange => objectIncludes(markRange.mark.attrs, attributes, { strict: false }))\n    .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0)\n\n  // calculate range of marks that excludes the searched mark\n  // for example `code` doesn’t allow any other marks\n  const excludedRange = markRanges\n    .filter(markRange => {\n      if (!type) {\n        return true\n      }\n\n      return markRange.mark.type !== type && markRange.mark.type.excludes(type)\n    })\n    .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0)\n\n  // we only include the result of `excludedRange`\n  // if there is a match at all\n  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange\n\n  return range >= selectionRange\n}\n","import { EditorState } from '@tiptap/pm/state'\n\nimport { getSchemaTypeNameByName } from './getSchemaTypeNameByName.js'\nimport { isMarkActive } from './isMarkActive.js'\nimport { isNodeActive } from './isNodeActive.js'\n\nexport function isActive(\n  state: EditorState,\n  name: string | null,\n  attributes: Record<string, any> = {},\n): boolean {\n  if (!name) {\n    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes)\n  }\n\n  const schemaType = getSchemaTypeNameByName(name, state.schema)\n\n  if (schemaType === 'node') {\n    return isNodeActive(state, name, attributes)\n  }\n\n  if (schemaType === 'mark') {\n    return isMarkActive(state, name, attributes)\n  }\n\n  return false\n}\n","import { EditorState } from '@tiptap/pm/state'\n\nimport { findParentNode } from './findParentNode.js'\n\nexport const isAtEndOfNode = (state: EditorState, nodeType?: string) => {\n  const { $from, $to, $anchor } = state.selection\n\n  if (nodeType) {\n    const parentNode = findParentNode(node => node.type.name === nodeType)(state.selection)\n\n    if (!parentNode) {\n      return false\n    }\n\n    const $parentPos = state.doc.resolve(parentNode.pos + 1)\n\n    if ($anchor.pos + 1 === $parentPos.end()) {\n      return true\n    }\n\n    return false\n  }\n\n  if ($to.parentOffset < $to.parent.nodeSize - 2 || $from.pos !== $to.pos) {\n    return false\n  }\n\n  return true\n}\n","import { EditorState } from '@tiptap/pm/state'\n\nexport const isAtStartOfNode = (state: EditorState) => {\n  const { $from, $to } = state.selection\n\n  if ($from.parentOffset > 0 || $from.pos !== $to.pos) {\n    return false\n  }\n\n  return true\n}\n","import { getExtensionField } from '../helpers/getExtensionField.js'\nimport { NodeConfig } from '../index.js'\nimport { Extensions } from '../types.js'\nimport { callOrReturn } from '../utilities/callOrReturn.js'\nimport { splitExtensions } from './splitExtensions.js'\n\nexport function isList(name: string, extensions: Extensions): boolean {\n  const { nodeExtensions } = splitExtensions(extensions)\n  const extension = nodeExtensions.find(item => item.name === name)\n\n  if (!extension) {\n    return false\n  }\n\n  const context = {\n    name: extension.name,\n    options: extension.options,\n    storage: extension.storage,\n  }\n  const group = callOrReturn(getExtensionField<NodeConfig['group']>(extension, 'group', context))\n\n  if (typeof group !== 'string') {\n    return false\n  }\n\n  return group.split(' ').includes('list')\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nexport function isNodeEmpty(node: ProseMirrorNode): boolean {\n  const defaultContent = node.type.createAndFill()?.toJSON()\n  const content = node.toJSON()\n\n  return JSON.stringify(defaultContent) === JSON.stringify(content)\n}\n","import { NodeSelection } from '@tiptap/pm/state'\n\nexport function isNodeSelection(value: unknown): value is NodeSelection {\n  return value instanceof NodeSelection\n}\n","import { EditorView } from '@tiptap/pm/view'\n\nimport { minMax } from '../utilities/minMax.js'\n\nexport function posToDOMRect(view: EditorView, from: number, to: number): DOMRect {\n  const minPos = 0\n  const maxPos = view.state.doc.content.size\n  const resolvedFrom = minMax(from, minPos, maxPos)\n  const resolvedEnd = minMax(to, minPos, maxPos)\n  const start = view.coordsAtPos(resolvedFrom)\n  const end = view.coordsAtPos(resolvedEnd, -1)\n  const top = Math.min(start.top, end.top)\n  const bottom = Math.max(start.bottom, end.bottom)\n  const left = Math.min(start.left, end.left)\n  const right = Math.max(start.right, end.right)\n  const width = right - left\n  const height = bottom - top\n  const x = left\n  const y = top\n  const data = {\n    top,\n    bottom,\n    left,\n    right,\n    width,\n    height,\n    x,\n    y,\n  }\n\n  return {\n    ...data,\n    toJSON: () => data,\n  }\n}\n","import { MarkType, ResolvedPos } from '@tiptap/pm/model'\nimport { EditorState, Transaction } from '@tiptap/pm/state'\n\nimport { getMarkAttributes } from '../helpers/getMarkAttributes.js'\nimport { getMarkType } from '../helpers/getMarkType.js'\nimport { isTextSelection } from '../helpers/index.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setMark: {\n      /**\n       * Add a mark with new attributes.\n       */\n      setMark: (typeOrName: string | MarkType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nfunction canSetMark(state: EditorState, tr: Transaction, newMarkType: MarkType) {\n  const { selection } = tr\n  let cursor: ResolvedPos | null = null\n\n  if (isTextSelection(selection)) {\n    cursor = selection.$cursor\n  }\n\n  if (cursor) {\n    const currentMarks = state.storedMarks ?? cursor.marks()\n\n    // There can be no current marks that exclude the new mark\n    return (\n      !!newMarkType.isInSet(currentMarks)\n      || !currentMarks.some(mark => mark.type.excludes(newMarkType))\n    )\n  }\n\n  const { ranges } = selection\n\n  return ranges.some(({ $from, $to }) => {\n    let someNodeSupportsMark = $from.depth === 0\n      ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType)\n      : false\n\n    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {\n      // If we already found a mark that we can enable, return false to bypass the remaining search\n      if (someNodeSupportsMark) {\n        return false\n      }\n\n      if (node.isInline) {\n        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType)\n        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks)\n          || !node.marks.some(otherMark => otherMark.type.excludes(newMarkType))\n\n        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType\n      }\n      return !someNodeSupportsMark\n    })\n\n    return someNodeSupportsMark\n  })\n}\nexport const setMark: RawCommands['setMark'] = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  const { selection } = tr\n  const { empty, ranges } = selection\n  const type = getMarkType(typeOrName, state.schema)\n\n  if (dispatch) {\n    if (empty) {\n      const oldAttributes = getMarkAttributes(state, type)\n\n      tr.addStoredMark(\n        type.create({\n          ...oldAttributes,\n          ...attributes,\n        }),\n      )\n    } else {\n      ranges.forEach(range => {\n        const from = range.$from.pos\n        const to = range.$to.pos\n\n        state.doc.nodesBetween(from, to, (node, pos) => {\n          const trimmedFrom = Math.max(pos, from)\n          const trimmedTo = Math.min(pos + node.nodeSize, to)\n          const someHasMark = node.marks.find(mark => mark.type === type)\n\n          // if there is already a mark of this type\n          // we know that we have to merge its attributes\n          // otherwise we add a fresh new mark\n          if (someHasMark) {\n            node.marks.forEach(mark => {\n              if (type === mark.type) {\n                tr.addMark(\n                  trimmedFrom,\n                  trimmedTo,\n                  type.create({\n                    ...mark.attrs,\n                    ...attributes,\n                  }),\n                )\n              }\n            })\n          } else {\n            tr.addMark(trimmedFrom, trimmedTo, type.create(attributes))\n          }\n        })\n      })\n    }\n  }\n\n  return canSetMark(state, tr, type)\n}\n","import { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setMeta: {\n      /**\n       * Store a metadata property in the current transaction.\n       */\n      setMeta: (key: string, value: any) => ReturnType,\n    }\n  }\n}\n\nexport const setMeta: RawCommands['setMeta'] = (key, value) => ({ tr }) => {\n  tr.setMeta(key, value)\n\n  return true\n}\n","import { setBlockType } from '@tiptap/pm/commands'\nimport { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setNode: {\n      /**\n       * Replace a given range with a node.\n       */\n      setNode: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const setNode: RawCommands['setNode'] = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  // TODO: use a fallback like insertContent?\n  if (!type.isTextblock) {\n    console.warn('[tiptap warn]: Currently \"setNode()\" only supports text block nodes.')\n\n    return false\n  }\n\n  return (\n    chain()\n    // try to convert node to default node if needed\n      .command(({ commands }) => {\n        const canSetBlock = setBlockType(type, attributes)(state)\n\n        if (canSetBlock) {\n          return true\n        }\n\n        return commands.clearNodes()\n      })\n      .command(({ state: updatedState }) => {\n        return setBlockType(type, attributes)(updatedState, dispatch)\n      })\n      .run()\n  )\n}\n","import { NodeSelection } from '@tiptap/pm/state'\n\nimport { RawCommands } from '../types.js'\nimport { minMax } from '../utilities/minMax.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setNodeSelection: {\n      /**\n       * Creates a NodeSelection.\n       */\n      setNodeSelection: (position: number) => ReturnType\n    }\n  }\n}\n\nexport const setNodeSelection: RawCommands['setNodeSelection'] = position => ({ tr, dispatch }) => {\n  if (dispatch) {\n    const { doc } = tr\n    const from = minMax(position, 0, doc.content.size)\n    const selection = NodeSelection.create(doc, from)\n\n    tr.setSelection(selection)\n  }\n\n  return true\n}\n","import { TextSelection } from '@tiptap/pm/state'\n\nimport { Range, RawCommands } from '../types.js'\nimport { minMax } from '../utilities/minMax.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setTextSelection: {\n      /**\n       * Creates a TextSelection.\n       */\n      setTextSelection: (position: number | Range) => ReturnType\n    }\n  }\n}\n\nexport const setTextSelection: RawCommands['setTextSelection'] = position => ({ tr, dispatch }) => {\n  if (dispatch) {\n    const { doc } = tr\n    const { from, to } = typeof position === 'number' ? { from: position, to: position } : position\n    const minPos = TextSelection.atStart(doc).from\n    const maxPos = TextSelection.atEnd(doc).to\n    const resolvedFrom = minMax(from, minPos, maxPos)\n    const resolvedEnd = minMax(to, minPos, maxPos)\n    const selection = TextSelection.create(doc, resolvedFrom, resolvedEnd)\n\n    tr.setSelection(selection)\n  }\n\n  return true\n}\n","import { NodeType } from '@tiptap/pm/model'\nimport { sinkListItem as originalSinkListItem } from '@tiptap/pm/schema-list'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    sinkListItem: {\n      /**\n       * Sink the list item down into an inner list.\n       */\n      sinkListItem: (typeOrName: string | NodeType) => ReturnType\n    }\n  }\n}\n\nexport const sinkListItem: RawCommands['sinkListItem'] = typeOrName => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalSinkListItem(type)(state, dispatch)\n}\n","import { EditorState, NodeSelection, TextSelection } from '@tiptap/pm/state'\nimport { canSplit } from '@tiptap/pm/transform'\n\nimport { defaultBlockAt } from '../helpers/defaultBlockAt.js'\nimport { getSplittedAttributes } from '../helpers/getSplittedAttributes.js'\nimport { RawCommands } from '../types.js'\n\nfunction ensureMarks(state: EditorState, splittableMarks?: string[]) {\n  const marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks())\n\n  if (marks) {\n    const filteredMarks = marks.filter(mark => splittableMarks?.includes(mark.type.name))\n\n    state.tr.ensureMarks(filteredMarks)\n  }\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    splitBlock: {\n      /**\n       * Forks a new node from an existing node.\n       */\n      splitBlock: (options?: { keepMarks?: boolean }) => ReturnType\n    }\n  }\n}\n\nexport const splitBlock: RawCommands['splitBlock'] = ({ keepMarks = true } = {}) => ({\n  tr, state, dispatch, editor,\n}) => {\n  const { selection, doc } = tr\n  const { $from, $to } = selection\n  const extensionAttributes = editor.extensionManager.attributes\n  const newAttributes = getSplittedAttributes(\n    extensionAttributes,\n    $from.node().type.name,\n    $from.node().attrs,\n  )\n\n  if (selection instanceof NodeSelection && selection.node.isBlock) {\n    if (!$from.parentOffset || !canSplit(doc, $from.pos)) {\n      return false\n    }\n\n    if (dispatch) {\n      if (keepMarks) {\n        ensureMarks(state, editor.extensionManager.splittableMarks)\n      }\n\n      tr.split($from.pos).scrollIntoView()\n    }\n\n    return true\n  }\n\n  if (!$from.parent.isBlock) {\n    return false\n  }\n\n  if (dispatch) {\n    const atEnd = $to.parentOffset === $to.parent.content.size\n\n    if (selection instanceof TextSelection) {\n      tr.deleteSelection()\n    }\n\n    const deflt = $from.depth === 0\n      ? undefined\n      : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)))\n\n    let types = atEnd && deflt\n      ? [\n        {\n          type: deflt,\n          attrs: newAttributes,\n        },\n      ]\n      : undefined\n\n    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types)\n\n    if (\n      !types\n        && !can\n        && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : undefined)\n    ) {\n      can = true\n      types = deflt\n        ? [\n          {\n            type: deflt,\n            attrs: newAttributes,\n          },\n        ]\n        : undefined\n    }\n\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types)\n\n      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {\n        const first = tr.mapping.map($from.before())\n        const $first = tr.doc.resolve(first)\n\n        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {\n          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt)\n        }\n      }\n    }\n\n    if (keepMarks) {\n      ensureMarks(state, editor.extensionManager.splittableMarks)\n    }\n\n    tr.scrollIntoView()\n  }\n\n  return true\n}\n","import {\n  Fragment, Node as ProseMirrorNode, NodeType, Slice,\n} from '@tiptap/pm/model'\nimport { TextSelection } from '@tiptap/pm/state'\nimport { canSplit } from '@tiptap/pm/transform'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { getSplittedAttributes } from '../helpers/getSplittedAttributes.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    splitListItem: {\n      /**\n       * Splits one list item into two list items.\n       */\n      splitListItem: (typeOrName: string | NodeType) => ReturnType\n    }\n  }\n}\n\nexport const splitListItem: RawCommands['splitListItem'] = typeOrName => ({\n  tr, state, dispatch, editor,\n}) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const { $from, $to } = state.selection\n\n  // @ts-ignore\n  // eslint-disable-next-line\n    const node: ProseMirrorNode = state.selection.node\n\n  if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) {\n    return false\n  }\n\n  const grandParent = $from.node(-1)\n\n  if (grandParent.type !== type) {\n    return false\n  }\n\n  const extensionAttributes = editor.extensionManager.attributes\n\n  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n    // In an empty block. If this is a nested list, the wrapping\n    // list item should be split. Otherwise, bail out and let next\n    // command handle lifting.\n    if (\n      $from.depth === 2\n        || $from.node(-3).type !== type\n        || $from.index(-2) !== $from.node(-2).childCount - 1\n    ) {\n      return false\n    }\n\n    if (dispatch) {\n      let wrap = Fragment.empty\n      // eslint-disable-next-line\n        const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3\n\n      // Build a fragment containing empty versions of the structure\n      // from the outer list item to the parent node of the cursor\n      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {\n        wrap = Fragment.from($from.node(d).copy(wrap))\n      }\n\n      // eslint-disable-next-line\n        const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3\n\n      // Add a second list item with an empty default start node\n      const newNextTypeAttributes = getSplittedAttributes(\n        extensionAttributes,\n        $from.node().type.name,\n        $from.node().attrs,\n      )\n      const nextType = type.contentMatch.defaultType?.createAndFill(newNextTypeAttributes) || undefined\n\n      wrap = wrap.append(Fragment.from(type.createAndFill(null, nextType) || undefined))\n\n      const start = $from.before($from.depth - (depthBefore - 1))\n\n      tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0))\n\n      let sel = -1\n\n      tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {\n        if (sel > -1) {\n          return false\n        }\n\n        if (n.isTextblock && n.content.size === 0) {\n          sel = pos + 1\n        }\n      })\n\n      if (sel > -1) {\n        tr.setSelection(TextSelection.near(tr.doc.resolve(sel)))\n      }\n\n      tr.scrollIntoView()\n    }\n\n    return true\n  }\n\n  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null\n\n  const newTypeAttributes = getSplittedAttributes(\n    extensionAttributes,\n    grandParent.type.name,\n    grandParent.attrs,\n  )\n  const newNextTypeAttributes = getSplittedAttributes(\n    extensionAttributes,\n    $from.node().type.name,\n    $from.node().attrs,\n  )\n\n  tr.delete($from.pos, $to.pos)\n\n  const types = nextType\n    ? [\n      { type, attrs: newTypeAttributes },\n      { type: nextType, attrs: newNextTypeAttributes },\n    ]\n    : [{ type, attrs: newTypeAttributes }]\n\n  if (!canSplit(tr.doc, $from.pos, 2)) {\n    return false\n  }\n\n  if (dispatch) {\n    const { selection, storedMarks } = state\n    const { splittableMarks } = editor.extensionManager\n    const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks())\n\n    tr.split($from.pos, 2, types).scrollIntoView()\n\n    if (!marks || !dispatch) {\n      return true\n    }\n\n    const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name))\n\n    tr.ensureMarks(filteredMarks)\n  }\n\n  return true\n}\n","import { NodeType } from '@tiptap/pm/model'\nimport { Transaction } from '@tiptap/pm/state'\nimport { canJoin } from '@tiptap/pm/transform'\n\nimport { findParentNode } from '../helpers/findParentNode.js'\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { isList } from '../helpers/isList.js'\nimport { RawCommands } from '../types.js'\n\nconst joinListBackwards = (tr: Transaction, listType: NodeType): boolean => {\n  const list = findParentNode(node => node.type === listType)(tr.selection)\n\n  if (!list) {\n    return true\n  }\n\n  const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth)\n\n  if (before === undefined) {\n    return true\n  }\n\n  const nodeBefore = tr.doc.nodeAt(before)\n  const canJoinBackwards = list.node.type === nodeBefore?.type && canJoin(tr.doc, list.pos)\n\n  if (!canJoinBackwards) {\n    return true\n  }\n\n  tr.join(list.pos)\n\n  return true\n}\n\nconst joinListForwards = (tr: Transaction, listType: NodeType): boolean => {\n  const list = findParentNode(node => node.type === listType)(tr.selection)\n\n  if (!list) {\n    return true\n  }\n\n  const after = tr.doc.resolve(list.start).after(list.depth)\n\n  if (after === undefined) {\n    return true\n  }\n\n  const nodeAfter = tr.doc.nodeAt(after)\n  const canJoinForwards = list.node.type === nodeAfter?.type && canJoin(tr.doc, after)\n\n  if (!canJoinForwards) {\n    return true\n  }\n\n  tr.join(after)\n\n  return true\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    toggleList: {\n      /**\n       * Toggle between different list types.\n       */\n      toggleList: (listTypeOrName: string | NodeType, itemTypeOrName: string | NodeType, keepMarks?: boolean, attributes?: Record<string, any>) => ReturnType;\n    }\n  }\n}\n\nexport const toggleList: RawCommands['toggleList'] = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({\n  editor, tr, state, dispatch, chain, commands, can,\n}) => {\n  const { extensions, splittableMarks } = editor.extensionManager\n  const listType = getNodeType(listTypeOrName, state.schema)\n  const itemType = getNodeType(itemTypeOrName, state.schema)\n  const { selection, storedMarks } = state\n  const { $from, $to } = selection\n  const range = $from.blockRange($to)\n\n  const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks())\n\n  if (!range) {\n    return false\n  }\n\n  const parentList = findParentNode(node => isList(node.type.name, extensions))(selection)\n\n  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n    // remove list\n    if (parentList.node.type === listType) {\n      return commands.liftListItem(itemType)\n    }\n\n    // change list type\n    if (\n      isList(parentList.node.type.name, extensions)\n        && listType.validContent(parentList.node.content)\n        && dispatch\n    ) {\n      return chain()\n        .command(() => {\n          tr.setNodeMarkup(parentList.pos, listType)\n\n          return true\n        })\n        .command(() => joinListBackwards(tr, listType))\n        .command(() => joinListForwards(tr, listType))\n        .run()\n    }\n  }\n  if (!keepMarks || !marks || !dispatch) {\n\n    return chain()\n      // try to convert node to default node if needed\n      .command(() => {\n        const canWrapInList = can().wrapInList(listType, attributes)\n\n        if (canWrapInList) {\n          return true\n        }\n\n        return commands.clearNodes()\n      })\n      .wrapInList(listType, attributes)\n      .command(() => joinListBackwards(tr, listType))\n      .command(() => joinListForwards(tr, listType))\n      .run()\n  }\n\n  return (\n    chain()\n    // try to convert node to default node if needed\n      .command(() => {\n        const canWrapInList = can().wrapInList(listType, attributes)\n\n        const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name))\n\n        tr.ensureMarks(filteredMarks)\n\n        if (canWrapInList) {\n          return true\n        }\n\n        return commands.clearNodes()\n      })\n      .wrapInList(listType, attributes)\n      .command(() => joinListBackwards(tr, listType))\n      .command(() => joinListForwards(tr, listType))\n      .run()\n  )\n}\n","import { MarkType } from '@tiptap/pm/model'\n\nimport { getMarkType } from '../helpers/getMarkType.js'\nimport { isMarkActive } from '../helpers/isMarkActive.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    toggleMark: {\n      /**\n       * Toggle a mark on and off.\n       */\n      toggleMark: (\n        typeOrName: string | MarkType,\n        attributes?: Record<string, any>,\n        options?: {\n          /**\n           * Removes the mark even across the current selection. Defaults to `false`.\n           */\n          extendEmptyMarkRange?: boolean\n        },\n      ) => ReturnType\n    }\n  }\n}\n\nexport const toggleMark: RawCommands['toggleMark'] = (typeOrName, attributes = {}, options = {}) => ({ state, commands }) => {\n  const { extendEmptyMarkRange = false } = options\n  const type = getMarkType(typeOrName, state.schema)\n  const isActive = isMarkActive(state, type, attributes)\n\n  if (isActive) {\n    return commands.unsetMark(type, { extendEmptyMarkRange })\n  }\n\n  return commands.setMark(type, attributes)\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { isNodeActive } from '../helpers/isNodeActive.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    toggleNode: {\n      /**\n       * Toggle a node with another node.\n       */\n      toggleNode: (\n        typeOrName: string | NodeType,\n        toggleTypeOrName: string | NodeType,\n        attributes?: Record<string, any>,\n      ) => ReturnType\n    }\n  }\n}\n\nexport const toggleNode: RawCommands['toggleNode'] = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const toggleType = getNodeType(toggleTypeOrName, state.schema)\n  const isActive = isNodeActive(state, type, attributes)\n\n  if (isActive) {\n    return commands.setNode(toggleType)\n  }\n\n  return commands.setNode(type, attributes)\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { isNodeActive } from '../helpers/isNodeActive.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    toggleWrap: {\n      /**\n       * Wraps nodes in another node, or removes an existing wrap.\n       */\n      toggleWrap: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const toggleWrap: RawCommands['toggleWrap'] = (typeOrName, attributes = {}) => ({ state, commands }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const isActive = isNodeActive(state, type, attributes)\n\n  if (isActive) {\n    return commands.lift(type)\n  }\n\n  return commands.wrapIn(type, attributes)\n}\n","import { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    undoInputRule: {\n      /**\n       * Undo an input rule.\n       */\n      undoInputRule: () => ReturnType,\n    }\n  }\n}\n\nexport const undoInputRule: RawCommands['undoInputRule'] = () => ({ state, dispatch }) => {\n  const plugins = state.plugins\n\n  for (let i = 0; i < plugins.length; i += 1) {\n    const plugin = plugins[i]\n    let undoable\n\n    // @ts-ignore\n    // eslint-disable-next-line\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        const tr = state.tr\n        const toUndo = undoable.transform\n\n        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {\n          tr.step(toUndo.steps[j].invert(toUndo.docs[j]))\n        }\n\n        if (undoable.text) {\n          const marks = tr.doc.resolve(undoable.from).marks()\n\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks))\n        } else {\n          tr.delete(undoable.from, undoable.to)\n        }\n      }\n\n      return true\n    }\n  }\n\n  return false\n}\n","import { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    unsetAllMarks: {\n      /**\n       * Remove all marks in the current selection.\n       */\n      unsetAllMarks: () => ReturnType,\n    }\n  }\n}\n\nexport const unsetAllMarks: RawCommands['unsetAllMarks'] = () => ({ tr, dispatch }) => {\n  const { selection } = tr\n  const { empty, ranges } = selection\n\n  if (empty) {\n    return true\n  }\n\n  if (dispatch) {\n    ranges.forEach(range => {\n      tr.removeMark(range.$from.pos, range.$to.pos)\n    })\n  }\n\n  return true\n}\n","import { MarkType } from '@tiptap/pm/model'\n\nimport { getMarkRange } from '../helpers/getMarkRange.js'\nimport { getMarkType } from '../helpers/getMarkType.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    unsetMark: {\n      /**\n       * Remove all marks in the current selection.\n       */\n      unsetMark: (\n        typeOrName: string | MarkType,\n        options?: {\n          /**\n           * Removes the mark even across the current selection. Defaults to `false`.\n           */\n          extendEmptyMarkRange?: boolean\n        },\n      ) => ReturnType\n    }\n  }\n}\n\nexport const unsetMark: RawCommands['unsetMark'] = (typeOrName, options = {}) => ({ tr, state, dispatch }) => {\n  const { extendEmptyMarkRange = false } = options\n  const { selection } = tr\n  const type = getMarkType(typeOrName, state.schema)\n  const { $from, empty, ranges } = selection\n\n  if (!dispatch) {\n    return true\n  }\n\n  if (empty && extendEmptyMarkRange) {\n    let { from, to } = selection\n    const attrs = $from.marks().find(mark => mark.type === type)?.attrs\n    const range = getMarkRange($from, type, attrs)\n\n    if (range) {\n      from = range.from\n      to = range.to\n    }\n\n    tr.removeMark(from, to, type)\n  } else {\n    ranges.forEach(range => {\n      tr.removeMark(range.$from.pos, range.$to.pos, type)\n    })\n  }\n\n  tr.removeStoredMark(type)\n\n  return true\n}\n","import { MarkType, NodeType } from '@tiptap/pm/model'\n\nimport { getMarkType } from '../helpers/getMarkType.js'\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { getSchemaTypeNameByName } from '../helpers/getSchemaTypeNameByName.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    updateAttributes: {\n      /**\n       * Update attributes of a node or mark.\n       */\n      updateAttributes: (\n        typeOrName: string | NodeType | MarkType,\n        attributes: Record<string, any>,\n      ) => ReturnType\n    }\n  }\n}\n\nexport const updateAttributes: RawCommands['updateAttributes'] = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  let nodeType: NodeType | null = null\n  let markType: MarkType | null = null\n\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === 'string' ? typeOrName : typeOrName.name,\n    state.schema,\n  )\n\n  if (!schemaType) {\n    return false\n  }\n\n  if (schemaType === 'node') {\n    nodeType = getNodeType(typeOrName as NodeType, state.schema)\n  }\n\n  if (schemaType === 'mark') {\n    markType = getMarkType(typeOrName as MarkType, state.schema)\n  }\n\n  if (dispatch) {\n    tr.selection.ranges.forEach(range => {\n      const from = range.$from.pos\n      const to = range.$to.pos\n\n      state.doc.nodesBetween(from, to, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, undefined, {\n            ...node.attrs,\n            ...attributes,\n          })\n        }\n\n        if (markType && node.marks.length) {\n          node.marks.forEach(mark => {\n            if (markType === mark.type) {\n              const trimmedFrom = Math.max(pos, from)\n              const trimmedTo = Math.min(pos + node.nodeSize, to)\n\n              tr.addMark(\n                trimmedFrom,\n                trimmedTo,\n                markType.create({\n                  ...mark.attrs,\n                  ...attributes,\n                }),\n              )\n            }\n          })\n        }\n      })\n    })\n  }\n\n  return true\n}\n","import { wrapIn as originalWrapIn } from '@tiptap/pm/commands'\nimport { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    wrapIn: {\n      /**\n       * Wraps nodes in another node.\n       */\n      wrapIn: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const wrapIn: RawCommands['wrapIn'] = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalWrapIn(type, attributes)(state, dispatch)\n}\n","import { NodeType } from '@tiptap/pm/model'\nimport { wrapInList as originalWrapInList } from '@tiptap/pm/schema-list'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    wrapInList: {\n      /**\n       * Wrap a node in a list.\n       */\n      wrapInList: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const wrapInList: RawCommands['wrapInList'] = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalWrapInList(type, attributes)(state, dispatch)\n}\n","import * as commands from '../commands/index.js'\nimport { Extension } from '../Extension.js'\n\nexport * from '../commands/index.js'\n\nexport const Commands = Extension.create({\n  name: 'commands',\n\n  addCommands() {\n    return {\n      ...commands,\n    }\n  },\n})\n","import { Plugin, PluginKey } from '@tiptap/pm/state'\n\nimport { Extension } from '../Extension.js'\n\nexport const Editable = Extension.create({\n  name: 'editable',\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('editable'),\n        props: {\n          editable: () => this.editor.options.editable,\n        },\n      }),\n    ]\n  },\n})\n","import { Plugin, PluginKey } from '@tiptap/pm/state'\n\nimport { Extension } from '../Extension.js'\n\nexport const FocusEvents = Extension.create({\n  name: 'focusEvents',\n\n  addProseMirrorPlugins() {\n    const { editor } = this\n\n    return [\n      new Plugin({\n        key: new PluginKey('focusEvents'),\n        props: {\n          handleDOMEvents: {\n            focus: (view, event: Event) => {\n              editor.isFocused = true\n\n              const transaction = editor.state.tr\n                .setMeta('focus', { event })\n                .setMeta('addToHistory', false)\n\n              view.dispatch(transaction)\n\n              return false\n            },\n            blur: (view, event: Event) => {\n              editor.isFocused = false\n\n              const transaction = editor.state.tr\n                .setMeta('blur', { event })\n                .setMeta('addToHistory', false)\n\n              view.dispatch(transaction)\n\n              return false\n            },\n          },\n        },\n      }),\n    ]\n  },\n})\n","import { Plugin, PluginKey, Selection } from '@tiptap/pm/state'\n\nimport { CommandManager } from '../CommandManager.js'\nimport { Extension } from '../Extension.js'\nimport { createChainableState } from '../helpers/createChainableState.js'\nimport { isiOS } from '../utilities/isiOS.js'\nimport { isMacOS } from '../utilities/isMacOS.js'\n\nexport const Keymap = Extension.create({\n  name: 'keymap',\n\n  addKeyboardShortcuts() {\n    const handleBackspace = () => this.editor.commands.first(({ commands }) => [\n      () => commands.undoInputRule(),\n\n      // maybe convert first text block node to default node\n      () => commands.command(({ tr }) => {\n        const { selection, doc } = tr\n        const { empty, $anchor } = selection\n        const { pos, parent } = $anchor\n        const $parentPos = $anchor.parent.isTextblock ? tr.doc.resolve(pos - 1) : $anchor\n        const parentIsIsolating = $parentPos.parent.type.spec.isolating\n\n        const parentPos = $anchor.pos - $anchor.parentOffset\n\n        const isAtStart = (parentIsIsolating && $parentPos.parent.childCount === 1)\n          ? parentPos === $anchor.pos\n          : Selection.atStart(doc).from === pos\n\n        if (!empty || !isAtStart || !parent.type.isTextblock || parent.textContent.length) {\n          return false\n        }\n\n        return commands.clearNodes()\n      }),\n\n      () => commands.deleteSelection(),\n      () => commands.joinBackward(),\n      () => commands.selectNodeBackward(),\n    ])\n\n    const handleDelete = () => this.editor.commands.first(({ commands }) => [\n      () => commands.deleteSelection(),\n      () => commands.deleteCurrentNode(),\n      () => commands.joinForward(),\n      () => commands.selectNodeForward(),\n    ])\n\n    const handleEnter = () => this.editor.commands.first(({ commands }) => [\n      () => commands.newlineInCode(),\n      () => commands.createParagraphNear(),\n      () => commands.liftEmptyBlock(),\n      () => commands.splitBlock(),\n    ])\n\n    const baseKeymap = {\n      Enter: handleEnter,\n      'Mod-Enter': () => this.editor.commands.exitCode(),\n      Backspace: handleBackspace,\n      'Mod-Backspace': handleBackspace,\n      'Shift-Backspace': handleBackspace,\n      Delete: handleDelete,\n      'Mod-Delete': handleDelete,\n      'Mod-a': () => this.editor.commands.selectAll(),\n    }\n\n    const pcKeymap = {\n      ...baseKeymap,\n    }\n\n    const macKeymap = {\n      ...baseKeymap,\n      'Ctrl-h': handleBackspace,\n      'Alt-Backspace': handleBackspace,\n      'Ctrl-d': handleDelete,\n      'Ctrl-Alt-Backspace': handleDelete,\n      'Alt-Delete': handleDelete,\n      'Alt-d': handleDelete,\n      'Ctrl-a': () => this.editor.commands.selectTextblockStart(),\n      'Ctrl-e': () => this.editor.commands.selectTextblockEnd(),\n    }\n\n    if (isiOS() || isMacOS()) {\n      return macKeymap\n    }\n\n    return pcKeymap\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      // With this plugin we check if the whole document was selected and deleted.\n      // In this case we will additionally call `clearNodes()` to convert e.g. a heading\n      // to a paragraph if necessary.\n      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well\n      // with many other commands.\n      new Plugin({\n        key: new PluginKey('clearDocument'),\n        appendTransaction: (transactions, oldState, newState) => {\n          const docChanges = transactions.some(transaction => transaction.docChanged)\n            && !oldState.doc.eq(newState.doc)\n\n          if (!docChanges) {\n            return\n          }\n\n          const { empty, from, to } = oldState.selection\n          const allFrom = Selection.atStart(oldState.doc).from\n          const allEnd = Selection.atEnd(oldState.doc).to\n          const allWasSelected = from === allFrom && to === allEnd\n\n          if (empty || !allWasSelected) {\n            return\n          }\n\n          const isEmpty = newState.doc.textBetween(0, newState.doc.content.size, ' ', ' ').length === 0\n\n          if (!isEmpty) {\n            return\n          }\n\n          const tr = newState.tr\n          const state = createChainableState({\n            state: newState,\n            transaction: tr,\n          })\n          const { commands } = new CommandManager({\n            editor: this.editor,\n            state,\n          })\n\n          commands.clearNodes()\n\n          if (!tr.steps.length) {\n            return\n          }\n\n          return tr\n        },\n      }),\n    ]\n  },\n})\n","import { Plugin, PluginKey } from '@tiptap/pm/state'\n\nimport { Extension } from '../Extension.js'\n\nexport const Tabindex = Extension.create({\n  name: 'tabindex',\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('tabindex'),\n        props: {\n          attributes: this.editor.isEditable ? { tabindex: '0' } : {},\n        },\n      }),\n    ]\n  },\n})\n","export const style = `.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: \"liga\" 0; /* the above doesn't seem to work in Edge */\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 1px !important;\n  height: 1px !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}`\n","export function createStyleTag(style: string, nonce?: string, suffix?: string): HTMLStyleElement {\n  const tiptapStyleTag = (<HTMLStyleElement>document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : ''}]`))\n\n  if (tiptapStyleTag !== null) {\n    return tiptapStyleTag\n  }\n\n  const styleNode = document.createElement('style')\n\n  if (nonce) {\n    styleNode.setAttribute('nonce', nonce)\n  }\n\n  styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : ''}`, '')\n  styleNode.innerHTML = style\n  document.getElementsByTagName('head')[0].appendChild(styleNode)\n\n  return styleNode\n}\n","import { MarkType, NodeType, Schema } from '@tiptap/pm/model'\nimport {\n  EditorState, Plugin, PluginKey, Transaction,\n} from '@tiptap/pm/state'\nimport { EditorView } from '@tiptap/pm/view'\n\nimport { CommandManager } from './CommandManager.js'\nimport { EventEmitter } from './EventEmitter.js'\nimport { ExtensionManager } from './ExtensionManager.js'\nimport * as extensions from './extensions/index.js'\nimport { createDocument } from './helpers/createDocument.js'\nimport { getAttributes } from './helpers/getAttributes.js'\nimport { getHTMLFromFragment } from './helpers/getHTMLFromFragment.js'\nimport { getText } from './helpers/getText.js'\nimport { getTextSerializersFromSchema } from './helpers/getTextSerializersFromSchema.js'\nimport { isActive } from './helpers/isActive.js'\nimport { isNodeEmpty } from './helpers/isNodeEmpty.js'\nimport { resolveFocusPosition } from './helpers/resolveFocusPosition.js'\nimport { style } from './style.js'\nimport {\n  CanCommands,\n  ChainedCommands,\n  EditorEvents,\n  EditorOptions,\n  JSONContent,\n  SingleCommands,\n  TextSerializer,\n} from './types.js'\nimport { createStyleTag } from './utilities/createStyleTag.js'\nimport { isFunction } from './utilities/isFunction.js'\n\nexport { extensions }\n\nexport interface HTMLElement {\n  editor?: Editor\n}\n\nexport class Editor extends EventEmitter<EditorEvents> {\n  private commandManager!: CommandManager\n\n  public extensionManager!: ExtensionManager\n\n  private css!: HTMLStyleElement\n\n  public schema!: Schema\n\n  public view!: EditorView\n\n  public isFocused = false\n\n  public extensionStorage: Record<string, any> = {}\n\n  public options: EditorOptions = {\n    element: document.createElement('div'),\n    content: '',\n    injectCSS: true,\n    injectNonce: undefined,\n    extensions: [],\n    autofocus: false,\n    editable: true,\n    editorProps: {},\n    parseOptions: {},\n    enableInputRules: true,\n    enablePasteRules: true,\n    enableCoreExtensions: true,\n    onBeforeCreate: () => null,\n    onCreate: () => null,\n    onUpdate: () => null,\n    onSelectionUpdate: () => null,\n    onTransaction: () => null,\n    onFocus: () => null,\n    onBlur: () => null,\n    onDestroy: () => null,\n  }\n\n  constructor(options: Partial<EditorOptions> = {}) {\n    super()\n    this.setOptions(options)\n    this.createExtensionManager()\n    this.createCommandManager()\n    this.createSchema()\n    this.on('beforeCreate', this.options.onBeforeCreate)\n    this.emit('beforeCreate', { editor: this })\n    this.createView()\n    this.injectCSS()\n    this.on('create', this.options.onCreate)\n    this.on('update', this.options.onUpdate)\n    this.on('selectionUpdate', this.options.onSelectionUpdate)\n    this.on('transaction', this.options.onTransaction)\n    this.on('focus', this.options.onFocus)\n    this.on('blur', this.options.onBlur)\n    this.on('destroy', this.options.onDestroy)\n\n    window.setTimeout(() => {\n      if (this.isDestroyed) {\n        return\n      }\n\n      this.commands.focus(this.options.autofocus)\n      this.emit('create', { editor: this })\n    }, 0)\n  }\n\n  /**\n   * Returns the editor storage.\n   */\n  public get storage(): Record<string, any> {\n    return this.extensionStorage\n  }\n\n  /**\n   * An object of all registered commands.\n   */\n  public get commands(): SingleCommands {\n    return this.commandManager.commands\n  }\n\n  /**\n   * Create a command chain to call multiple commands at once.\n   */\n  public chain(): ChainedCommands {\n    return this.commandManager.chain()\n  }\n\n  /**\n   * Check if a command or a command chain can be executed. Without executing it.\n   */\n  public can(): CanCommands {\n    return this.commandManager.can()\n  }\n\n  /**\n   * Inject CSS styles.\n   */\n  private injectCSS(): void {\n    if (this.options.injectCSS && document) {\n      this.css = createStyleTag(style, this.options.injectNonce)\n    }\n  }\n\n  /**\n   * Update editor options.\n   *\n   * @param options A list of options\n   */\n  public setOptions(options: Partial<EditorOptions> = {}): void {\n    this.options = {\n      ...this.options,\n      ...options,\n    }\n\n    if (!this.view || !this.state || this.isDestroyed) {\n      return\n    }\n\n    if (this.options.editorProps) {\n      this.view.setProps(this.options.editorProps)\n    }\n\n    this.view.updateState(this.state)\n  }\n\n  /**\n   * Update editable state of the editor.\n   */\n  public setEditable(editable: boolean, emitUpdate = true): void {\n    this.setOptions({ editable })\n\n    if (emitUpdate) {\n      this.emit('update', { editor: this, transaction: this.state.tr })\n    }\n  }\n\n  /**\n   * Returns whether the editor is editable.\n   */\n  public get isEditable(): boolean {\n    // since plugins are applied after creating the view\n    // `editable` is always `true` for one tick.\n    // that’s why we also have to check for `options.editable`\n    return this.options.editable && this.view && this.view.editable\n  }\n\n  /**\n   * Returns the editor state.\n   */\n  public get state(): EditorState {\n    return this.view.state\n  }\n\n  /**\n   * Register a ProseMirror plugin.\n   *\n   * @param plugin A ProseMirror plugin\n   * @param handlePlugins Control how to merge the plugin into the existing plugins.\n   */\n  public registerPlugin(\n    plugin: Plugin,\n    handlePlugins?: (newPlugin: Plugin, plugins: Plugin[]) => Plugin[],\n  ): void {\n    const plugins = isFunction(handlePlugins)\n      ? handlePlugins(plugin, [...this.state.plugins])\n      : [...this.state.plugins, plugin]\n\n    const state = this.state.reconfigure({ plugins })\n\n    this.view.updateState(state)\n  }\n\n  /**\n   * Unregister a ProseMirror plugin.\n   *\n   * @param nameOrPluginKey The plugins name\n   */\n  public unregisterPlugin(nameOrPluginKey: string | PluginKey): void {\n    if (this.isDestroyed) {\n      return\n    }\n\n    // @ts-ignore\n    const name = typeof nameOrPluginKey === 'string' ? `${nameOrPluginKey}$` : nameOrPluginKey.key\n\n    const state = this.state.reconfigure({\n      // @ts-ignore\n      plugins: this.state.plugins.filter(plugin => !plugin.key.startsWith(name)),\n    })\n\n    this.view.updateState(state)\n  }\n\n  /**\n   * Creates an extension manager.\n   */\n  private createExtensionManager(): void {\n    const coreExtensions = this.options.enableCoreExtensions ? Object.values(extensions) : []\n    const allExtensions = [...coreExtensions, ...this.options.extensions].filter(extension => {\n      return ['extension', 'node', 'mark'].includes(extension?.type)\n    })\n\n    this.extensionManager = new ExtensionManager(allExtensions, this)\n  }\n\n  /**\n   * Creates an command manager.\n   */\n  private createCommandManager(): void {\n    this.commandManager = new CommandManager({\n      editor: this,\n    })\n  }\n\n  /**\n   * Creates a ProseMirror schema.\n   */\n  private createSchema(): void {\n    this.schema = this.extensionManager.schema\n  }\n\n  /**\n   * Creates a ProseMirror view.\n   */\n  private createView(): void {\n    const doc = createDocument(this.options.content, this.schema, this.options.parseOptions)\n    const selection = resolveFocusPosition(doc, this.options.autofocus)\n\n    this.view = new EditorView(this.options.element, {\n      ...this.options.editorProps,\n      dispatchTransaction: this.dispatchTransaction.bind(this),\n      state: EditorState.create({\n        doc,\n        selection: selection || undefined,\n      }),\n    })\n\n    // `editor.view` is not yet available at this time.\n    // Therefore we will add all plugins and node views directly afterwards.\n    const newState = this.state.reconfigure({\n      plugins: this.extensionManager.plugins,\n    })\n\n    this.view.updateState(newState)\n\n    this.createNodeViews()\n    this.prependClass()\n\n    // Let’s store the editor instance in the DOM element.\n    // So we’ll have access to it for tests.\n    const dom = this.view.dom as HTMLElement\n\n    dom.editor = this\n  }\n\n  /**\n   * Creates all node views.\n   */\n  public createNodeViews(): void {\n    this.view.setProps({\n      nodeViews: this.extensionManager.nodeViews,\n    })\n  }\n\n  /**\n   * Prepend class name to element.\n   */\n  public prependClass(): void {\n    this.view.dom.className = `tiptap ${this.view.dom.className}`\n  }\n\n  public isCapturingTransaction = false\n\n  private capturedTransaction: Transaction | null = null\n\n  public captureTransaction(fn: Function) {\n    this.isCapturingTransaction = true\n    fn()\n    this.isCapturingTransaction = false\n\n    const tr = this.capturedTransaction\n\n    this.capturedTransaction = null\n\n    return tr\n  }\n\n  /**\n   * The callback over which to send transactions (state updates) produced by the view.\n   *\n   * @param transaction An editor state transaction\n   */\n  private dispatchTransaction(transaction: Transaction): void {\n    // if the editor / the view of the editor was destroyed\n    // the transaction should not be dispatched as there is no view anymore.\n    if (this.view.isDestroyed) {\n      return\n    }\n\n    if (this.isCapturingTransaction) {\n      if (!this.capturedTransaction) {\n        this.capturedTransaction = transaction\n\n        return\n      }\n\n      transaction.steps.forEach(step => this.capturedTransaction?.step(step))\n\n      return\n    }\n\n    const state = this.state.apply(transaction)\n    const selectionHasChanged = !this.state.selection.eq(state.selection)\n\n    this.view.updateState(state)\n    this.emit('transaction', {\n      editor: this,\n      transaction,\n    })\n\n    if (selectionHasChanged) {\n      this.emit('selectionUpdate', {\n        editor: this,\n        transaction,\n      })\n    }\n\n    const focus = transaction.getMeta('focus')\n    const blur = transaction.getMeta('blur')\n\n    if (focus) {\n      this.emit('focus', {\n        editor: this,\n        event: focus.event,\n        transaction,\n      })\n    }\n\n    if (blur) {\n      this.emit('blur', {\n        editor: this,\n        event: blur.event,\n        transaction,\n      })\n    }\n\n    if (!transaction.docChanged || transaction.getMeta('preventUpdate')) {\n      return\n    }\n\n    this.emit('update', {\n      editor: this,\n      transaction,\n    })\n  }\n\n  /**\n   * Get attributes of the currently selected node or mark.\n   */\n  public getAttributes(nameOrType: string | NodeType | MarkType): Record<string, any> {\n    return getAttributes(this.state, nameOrType)\n  }\n\n  /**\n   * Returns if the currently selected node or mark is active.\n   *\n   * @param name Name of the node or mark\n   * @param attributes Attributes of the node or mark\n   */\n  public isActive(name: string, attributes?: {}): boolean\n  public isActive(attributes: {}): boolean\n  public isActive(nameOrAttributes: string, attributesOrUndefined?: {}): boolean {\n    const name = typeof nameOrAttributes === 'string' ? nameOrAttributes : null\n\n    const attributes = typeof nameOrAttributes === 'string' ? attributesOrUndefined : nameOrAttributes\n\n    return isActive(this.state, name, attributes)\n  }\n\n  /**\n   * Get the document as JSON.\n   */\n  public getJSON(): JSONContent {\n    return this.state.doc.toJSON()\n  }\n\n  /**\n   * Get the document as HTML.\n   */\n  public getHTML(): string {\n    return getHTMLFromFragment(this.state.doc.content, this.schema)\n  }\n\n  /**\n   * Get the document as text.\n   */\n  public getText(options?: {\n    blockSeparator?: string\n    textSerializers?: Record<string, TextSerializer>\n  }): string {\n    const { blockSeparator = '\\n\\n', textSerializers = {} } = options || {}\n\n    return getText(this.state.doc, {\n      blockSeparator,\n      textSerializers: {\n        ...getTextSerializersFromSchema(this.schema),\n        ...textSerializers,\n      },\n    })\n  }\n\n  /**\n   * Check if there is no content.\n   */\n  public get isEmpty(): boolean {\n    return isNodeEmpty(this.state.doc)\n  }\n\n  /**\n   * Get the number of characters for the current document.\n   *\n   * @deprecated\n   */\n  public getCharacterCount(): number {\n    console.warn(\n      '[tiptap warn]: \"editor.getCharacterCount()\" is deprecated. Please use \"editor.storage.characterCount.characters()\" instead.',\n    )\n\n    return this.state.doc.content.size - 2\n  }\n\n  /**\n   * Destroy the editor.\n   */\n  public destroy(): void {\n    this.emit('destroy')\n\n    if (this.view) {\n      this.view.destroy()\n    }\n\n    this.removeAllListeners()\n  }\n\n  /**\n   * Check if the editor is already destroyed.\n   */\n  public get isDestroyed(): boolean {\n    // @ts-ignore\n    return !this.view?.docView\n  }\n}\n","import { MarkType } from '@tiptap/pm/model'\n\nimport { getMarksBetween } from '../helpers/getMarksBetween.js'\nimport { InputRule, InputRuleFinder } from '../InputRule.js'\nimport { ExtendedRegExpMatchArray } from '../types.js'\nimport { callOrReturn } from '../utilities/callOrReturn.js'\n\n/**\n * Build an input rule that adds a mark when the\n * matched text is typed into it.\n */\nexport function markInputRule(config: {\n  find: InputRuleFinder\n  type: MarkType\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n    | false\n    | null\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match)\n\n      if (attributes === false || attributes === null) {\n        return null\n      }\n\n      const { tr } = state\n      const captureGroup = match[match.length - 1]\n      const fullMatch = match[0]\n\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/)\n        const textStart = range.from + fullMatch.indexOf(captureGroup)\n        const textEnd = textStart + captureGroup.length\n\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc)\n          .filter(item => {\n            // @ts-ignore\n            const excluded = item.mark.type.excluded as MarkType[]\n\n            return excluded.find(type => type === config.type && type !== item.mark.type)\n          })\n          .filter(item => item.to > textStart)\n\n        if (excludedMarks.length) {\n          return null\n        }\n\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to)\n        }\n\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart)\n        }\n\n        const markEnd = range.from + startSpaces + captureGroup.length\n\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}))\n\n        tr.removeStoredMark(config.type)\n      }\n    },\n  })\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { InputRule, InputRuleFinder } from '../InputRule.js'\nimport { ExtendedRegExpMatchArray } from '../types.js'\nimport { callOrReturn } from '../utilities/callOrReturn.js'\n\n/**\n * Build an input rule that adds a node when the\n * matched text is typed into it.\n */\nexport function nodeInputRule(config: {\n  /**\n   * The regex to match.\n   */\n  find: InputRuleFinder\n\n  /**\n   * The node type to add.\n   */\n  type: NodeType\n\n  /**\n   * A function that returns the attributes for the node\n   * can also be an object of attributes\n   */\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n    | false\n    | null\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {}\n      const { tr } = state\n      const start = range.from\n      let end = range.to\n\n      const newNode = config.type.create(attributes)\n\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1])\n        let matchStart = start + offset\n\n        if (matchStart > end) {\n          matchStart = end\n        } else {\n          end = matchStart + match[1].length\n        }\n\n        // insert last typed character\n        const lastChar = match[0][match[0].length - 1]\n\n        tr.insertText(lastChar, start + match[0].length - 1)\n\n        // insert node from input rule\n        tr.replaceWith(matchStart, end, newNode)\n      } else if (match[0]) {\n        tr.insert(start - 1, config.type.create(attributes)).delete(\n          tr.mapping.map(start),\n          tr.mapping.map(end),\n        )\n      }\n\n      tr.scrollIntoView()\n    },\n  })\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { InputRule, InputRuleFinder } from '../InputRule.js'\nimport { ExtendedRegExpMatchArray } from '../types.js'\nimport { callOrReturn } from '../utilities/callOrReturn.js'\n\n/**\n * Build an input rule that changes the type of a textblock when the\n * matched text is typed into it. When using a regular expresion you’ll\n * probably want the regexp to start with `^`, so that the pattern can\n * only occur at the start of a textblock.\n */\nexport function textblockTypeInputRule(config: {\n  find: InputRuleFinder\n  type: NodeType\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n    | false\n    | null\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const $start = state.doc.resolve(range.from)\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {}\n\n      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {\n        return null\n      }\n\n      state.tr\n        .delete(range.from, range.to)\n        .setBlockType(range.from, range.from, config.type, attributes)\n    },\n  })\n}\n","import { InputRule, InputRuleFinder } from '../InputRule.js'\n\n/**\n * Build an input rule that replaces text when the\n * matched text is typed into it.\n */\nexport function textInputRule(config: {\n  find: InputRuleFinder,\n  replace: string,\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      let insert = config.replace\n      let start = range.from\n      const end = range.to\n\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1])\n\n        insert += match[0].slice(offset + match[1].length)\n        start += offset\n\n        const cutOff = start - end\n\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert\n          start = end\n        }\n      }\n\n      state.tr.insertText(insert, start, end)\n    },\n  })\n}\n","import { Node as ProseMirrorNode, NodeType } from '@tiptap/pm/model'\nimport { canJoin, findWrapping } from '@tiptap/pm/transform'\n\nimport { Editor } from '../Editor.js'\nimport { InputRule, InputRuleFinder } from '../InputRule.js'\nimport { ExtendedRegExpMatchArray } from '../types.js'\nimport { callOrReturn } from '../utilities/callOrReturn.js'\n\n/**\n * Build an input rule for automatically wrapping a textblock when a\n * given string is typed. When using a regular expresion you’ll\n * probably want the regexp to start with `^`, so that the pattern can\n * only occur at the start of a textblock.\n *\n * `type` is the type of node to wrap in.\n *\n * By default, if there’s a node with the same type above the newly\n * wrapped node, the rule will try to join those\n * two nodes. You can pass a join predicate, which takes a regular\n * expression match and the node before the wrapped node, and can\n * return a boolean to indicate whether a join should happen.\n */\nexport function wrappingInputRule(config: {\n  find: InputRuleFinder,\n  type: NodeType,\n  keepMarks?: boolean,\n  keepAttributes?: boolean,\n  editor?: Editor\n  getAttributes?:\n  | Record<string, any>\n  | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n  | false\n  | null\n  ,\n  joinPredicate?: (match: ExtendedRegExpMatchArray, node: ProseMirrorNode) => boolean,\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({\n      state, range, match, chain,\n    }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {}\n      const tr = state.tr.delete(range.from, range.to)\n      const $start = tr.doc.resolve(range.from)\n      const blockRange = $start.blockRange()\n      const wrapping = blockRange && findWrapping(blockRange, config.type, attributes)\n\n      if (!wrapping) {\n        return null\n      }\n\n      tr.wrap(blockRange, wrapping)\n\n      if (config.keepMarks && config.editor) {\n        const { selection, storedMarks } = state\n        const { splittableMarks } = config.editor.extensionManager\n        const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks())\n\n        if (marks) {\n          const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name))\n\n          tr.ensureMarks(filteredMarks)\n        }\n      }\n      if (config.keepAttributes) {\n        /** If the nodeType is `bulletList` or `orderedList` set the `nodeType` as `listItem` */\n        const nodeType = config.type.name === 'bulletList' || config.type.name === 'orderedList' ? 'listItem' : 'taskList'\n\n        chain().updateAttributes(nodeType, attributes).run()\n      }\n\n      const before = tr.doc.resolve(range.from - 1).nodeBefore\n\n      if (\n        before\n        && before.type === config.type\n        && canJoin(tr.doc, range.from - 1)\n        && (!config.joinPredicate || config.joinPredicate(match, before))\n      ) {\n        tr.join(range.from - 1)\n      }\n    },\n  })\n}\n","import {\n  DOMOutputSpec, Mark as ProseMirrorMark, MarkSpec, MarkType,\n} from '@tiptap/pm/model'\nimport { Plugin, Transaction } from '@tiptap/pm/state'\n\nimport { Editor } from './Editor.js'\nimport { getExtensionField } from './helpers/getExtensionField.js'\nimport { MarkConfig } from './index.js'\nimport { InputRule } from './InputRule.js'\nimport { Node } from './Node.js'\nimport { PasteRule } from './PasteRule.js'\nimport {\n  AnyConfig,\n  Attributes,\n  Extensions,\n  GlobalAttributes,\n  KeyboardShortcutCommand,\n  ParentConfig,\n  RawCommands,\n} from './types.js'\nimport { callOrReturn } from './utilities/callOrReturn.js'\nimport { mergeDeep } from './utilities/mergeDeep.js'\n\ndeclare module '@tiptap/core' {\n  export interface MarkConfig<Options = any, Storage = any> {\n    [key: string]: any\n\n    /**\n     * Name\n     */\n    name: string\n\n    /**\n     * Priority\n     */\n    priority?: number\n\n    /**\n     * Default options\n     */\n    defaultOptions?: Options\n\n    /**\n     * Default Options\n     */\n    addOptions?: (this: {\n      name: string\n      parent: Exclude<ParentConfig<MarkConfig<Options, Storage>>['addOptions'], undefined>\n    }) => Options\n\n    /**\n     * Default Storage\n     */\n    addStorage?: (this: {\n      name: string\n      options: Options\n      parent: Exclude<ParentConfig<MarkConfig<Options, Storage>>['addStorage'], undefined>\n    }) => Storage\n\n    /**\n     * Global attributes\n     */\n    addGlobalAttributes?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addGlobalAttributes']\n    }) => GlobalAttributes | {}\n\n    /**\n     * Raw\n     */\n    addCommands?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: MarkType\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addCommands']\n    }) => Partial<RawCommands>\n\n    /**\n     * Keyboard shortcuts\n     */\n    addKeyboardShortcuts?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: MarkType\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addKeyboardShortcuts']\n    }) => {\n      [key: string]: KeyboardShortcutCommand\n    }\n\n    /**\n     * Input rules\n     */\n    addInputRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: MarkType\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addInputRules']\n    }) => InputRule[]\n\n    /**\n     * Paste rules\n     */\n    addPasteRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: MarkType\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addPasteRules']\n    }) => PasteRule[]\n\n    /**\n     * ProseMirror plugins\n     */\n    addProseMirrorPlugins?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: MarkType\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addProseMirrorPlugins']\n    }) => Plugin[]\n\n    /**\n     * Extensions\n     */\n    addExtensions?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addExtensions']\n    }) => Extensions\n\n    /**\n     * Extend Node Schema\n     */\n    extendNodeSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<MarkConfig<Options, Storage>>['extendNodeSchema']\n          },\n          extension: Node,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * Extend Mark Schema\n     */\n    extendMarkSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<MarkConfig<Options, Storage>>['extendMarkSchema']\n          },\n          extension: Mark,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * The editor is not ready yet.\n     */\n    onBeforeCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: MarkType\n          parent: ParentConfig<MarkConfig<Options, Storage>>['onBeforeCreate']\n        }) => void)\n      | null\n\n    /**\n     * The editor is ready.\n     */\n    onCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: MarkType\n          parent: ParentConfig<MarkConfig<Options, Storage>>['onCreate']\n        }) => void)\n      | null\n\n    /**\n     * The content has changed.\n     */\n    onUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: MarkType\n          parent: ParentConfig<MarkConfig<Options, Storage>>['onUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The selection has changed.\n     */\n    onSelectionUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: MarkType\n          parent: ParentConfig<MarkConfig<Options, Storage>>['onSelectionUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The editor state has changed.\n     */\n    onTransaction?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: MarkType\n            parent: ParentConfig<MarkConfig<Options, Storage>>['onTransaction']\n          },\n          props: {\n            transaction: Transaction\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is focused.\n     */\n    onFocus?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: MarkType\n            parent: ParentConfig<MarkConfig<Options, Storage>>['onFocus']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor isn’t focused anymore.\n     */\n    onBlur?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: MarkType\n            parent: ParentConfig<MarkConfig<Options, Storage>>['onBlur']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is destroyed.\n     */\n    onDestroy?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: MarkType\n          parent: ParentConfig<MarkConfig<Options, Storage>>['onDestroy']\n        }) => void)\n      | null\n\n    /**\n     * Keep mark after split node\n     */\n    keepOnSplit?: boolean | (() => boolean)\n\n    /**\n     * Inclusive\n     */\n    inclusive?:\n      | MarkSpec['inclusive']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<MarkConfig<Options, Storage>>['inclusive']\n          editor?: Editor\n        }) => MarkSpec['inclusive'])\n\n    /**\n     * Excludes\n     */\n    excludes?:\n      | MarkSpec['excludes']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<MarkConfig<Options, Storage>>['excludes']\n          editor?: Editor\n        }) => MarkSpec['excludes'])\n\n    /**\n     * Marks this Mark as exitable\n     */\n    exitable?: boolean | (() => boolean)\n\n    /**\n     * Group\n     */\n    group?:\n      | MarkSpec['group']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<MarkConfig<Options, Storage>>['group']\n          editor?: Editor\n        }) => MarkSpec['group'])\n\n    /**\n     * Spanning\n     */\n    spanning?:\n      | MarkSpec['spanning']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<MarkConfig<Options, Storage>>['spanning']\n          editor?: Editor\n        }) => MarkSpec['spanning'])\n\n    /**\n     * Code\n     */\n    code?:\n      | boolean\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<MarkConfig<Options, Storage>>['code']\n          editor?: Editor\n        }) => boolean)\n\n    /**\n     * Parse HTML\n     */\n    parseHTML?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<MarkConfig<Options, Storage>>['parseHTML']\n      editor?: Editor\n    }) => MarkSpec['parseDOM']\n\n    /**\n     * Render HTML\n     */\n    renderHTML?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<MarkConfig<Options, Storage>>['renderHTML']\n            editor?: Editor\n          },\n          props: {\n            mark: ProseMirrorMark\n            HTMLAttributes: Record<string, any>\n          },\n        ) => DOMOutputSpec)\n      | null\n\n    /**\n     * Attributes\n     */\n    addAttributes?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addAttributes']\n      editor?: Editor\n    }) => Attributes | {}\n  }\n}\n\nexport class Mark<Options = any, Storage = any> {\n  type = 'mark'\n\n  name = 'mark'\n\n  parent: Mark | null = null\n\n  child: Mark | null = null\n\n  options: Options\n\n  storage: Storage\n\n  config: MarkConfig = {\n    name: this.name,\n    defaultOptions: {},\n  }\n\n  constructor(config: Partial<MarkConfig<Options, Storage>> = {}) {\n    this.config = {\n      ...this.config,\n      ...config,\n    }\n\n    this.name = this.config.name\n\n    if (config.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`,\n      )\n    }\n\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions\n\n    if (this.config.addOptions) {\n      this.options = callOrReturn(\n        getExtensionField<AnyConfig['addOptions']>(this, 'addOptions', {\n          name: this.name,\n        }),\n      )\n    }\n\n    this.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(this, 'addStorage', {\n        name: this.name,\n        options: this.options,\n      }),\n    ) || {}\n  }\n\n  static create<O = any, S = any>(config: Partial<MarkConfig<O, S>> = {}) {\n    return new Mark<O, S>(config)\n  }\n\n  configure(options: Partial<Options> = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend()\n\n    extension.options = mergeDeep(this.options as Record<string, any>, options) as Options\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n\n  extend<ExtendedOptions = Options, ExtendedStorage = Storage>(\n    extendedConfig: Partial<MarkConfig<ExtendedOptions, ExtendedStorage>> = {},\n  ) {\n    const extension = new Mark<ExtendedOptions, ExtendedStorage>(extendedConfig)\n\n    extension.parent = this\n\n    this.child = extension\n\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name\n\n    if (extendedConfig.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`,\n      )\n    }\n\n    extension.options = callOrReturn(\n      getExtensionField<AnyConfig['addOptions']>(extension, 'addOptions', {\n        name: extension.name,\n      }),\n    )\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n\n  static handleExit({ editor, mark }: { editor: Editor; mark: Mark }) {\n    const { tr } = editor.state\n    const currentPos = editor.state.selection.$from\n    const isAtEnd = currentPos.pos === currentPos.end()\n\n    if (isAtEnd) {\n      const currentMarks = currentPos.marks()\n      const isInMark = !!currentMarks.find(m => m?.type.name === mark.name)\n\n      if (!isInMark) {\n        return false\n      }\n\n      const removeMark = currentMarks.find(m => m?.type.name === mark.name)\n\n      if (removeMark) {\n        tr.removeStoredMark(removeMark)\n      }\n      tr.insertText(' ', currentPos.pos)\n\n      editor.view.dispatch(tr)\n\n      return true\n    }\n\n    return false\n  }\n}\n","import {\n  DOMOutputSpec, Node as ProseMirrorNode, NodeSpec, NodeType,\n} from '@tiptap/pm/model'\nimport { Plugin, Transaction } from '@tiptap/pm/state'\n\nimport { Editor } from './Editor.js'\nimport { getExtensionField } from './helpers/getExtensionField.js'\nimport { NodeConfig } from './index.js'\nimport { InputRule } from './InputRule.js'\nimport { PasteRule } from './PasteRule.js'\nimport {\n  AnyConfig,\n  Attributes,\n  Extensions,\n  GlobalAttributes,\n  KeyboardShortcutCommand,\n  NodeViewRenderer,\n  ParentConfig,\n  RawCommands,\n} from './types.js'\nimport { callOrReturn } from './utilities/callOrReturn.js'\nimport { mergeDeep } from './utilities/mergeDeep.js'\n\ndeclare module '@tiptap/core' {\n  interface NodeConfig<Options = any, Storage = any> {\n    [key: string]: any\n\n    /**\n     * Name\n     */\n    name: string\n\n    /**\n     * Priority\n     */\n    priority?: number\n\n    /**\n     * Default options\n     */\n    defaultOptions?: Options\n\n    /**\n     * Default Options\n     */\n    addOptions?: (this: {\n      name: string\n      parent: Exclude<ParentConfig<NodeConfig<Options, Storage>>['addOptions'], undefined>\n    }) => Options\n\n    /**\n     * Default Storage\n     */\n    addStorage?: (this: {\n      name: string\n      options: Options\n      parent: Exclude<ParentConfig<NodeConfig<Options, Storage>>['addStorage'], undefined>\n    }) => Storage\n\n    /**\n     * Global attributes\n     */\n    addGlobalAttributes?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addGlobalAttributes']\n    }) => GlobalAttributes | {}\n\n    /**\n     * Raw\n     */\n    addCommands?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: NodeType\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addCommands']\n    }) => Partial<RawCommands>\n\n    /**\n     * Keyboard shortcuts\n     */\n    addKeyboardShortcuts?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: NodeType\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addKeyboardShortcuts']\n    }) => {\n      [key: string]: KeyboardShortcutCommand\n    }\n\n    /**\n     * Input rules\n     */\n    addInputRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: NodeType\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addInputRules']\n    }) => InputRule[]\n\n    /**\n     * Paste rules\n     */\n    addPasteRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: NodeType\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addPasteRules']\n    }) => PasteRule[]\n\n    /**\n     * ProseMirror plugins\n     */\n    addProseMirrorPlugins?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: NodeType\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addProseMirrorPlugins']\n    }) => Plugin[]\n\n    /**\n     * Extensions\n     */\n    addExtensions?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addExtensions']\n    }) => Extensions\n\n    /**\n     * Extend Node Schema\n     */\n    extendNodeSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<NodeConfig<Options, Storage>>['extendNodeSchema']\n          },\n          extension: Node,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * Extend Mark Schema\n     */\n    extendMarkSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<NodeConfig<Options, Storage>>['extendMarkSchema']\n            editor?: Editor\n          },\n          extension: Node,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * The editor is not ready yet.\n     */\n    onBeforeCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['onBeforeCreate']\n        }) => void)\n      | null\n\n    /**\n     * The editor is ready.\n     */\n    onCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['onCreate']\n        }) => void)\n      | null\n\n    /**\n     * The content has changed.\n     */\n    onUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['onUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The selection has changed.\n     */\n    onSelectionUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['onSelectionUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The editor state has changed.\n     */\n    onTransaction?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: NodeType\n            parent: ParentConfig<NodeConfig<Options, Storage>>['onTransaction']\n          },\n          props: {\n            transaction: Transaction\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is focused.\n     */\n    onFocus?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: NodeType\n            parent: ParentConfig<NodeConfig<Options, Storage>>['onFocus']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor isn’t focused anymore.\n     */\n    onBlur?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: NodeType\n            parent: ParentConfig<NodeConfig<Options, Storage>>['onBlur']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is destroyed.\n     */\n    onDestroy?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['onDestroy']\n        }) => void)\n      | null\n\n    /**\n     * Node View\n     */\n    addNodeView?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['addNodeView']\n        }) => NodeViewRenderer)\n      | null\n\n    /**\n     * TopNode\n     */\n    topNode?: boolean\n\n    /**\n     * Content\n     */\n    content?:\n      | NodeSpec['content']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['content']\n          editor?: Editor\n        }) => NodeSpec['content'])\n\n    /**\n     * Marks\n     */\n    marks?:\n      | NodeSpec['marks']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['marks']\n          editor?: Editor\n        }) => NodeSpec['marks'])\n\n    /**\n     * Group\n     */\n    group?:\n      | NodeSpec['group']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['group']\n          editor?: Editor\n        }) => NodeSpec['group'])\n\n    /**\n     * Inline\n     */\n    inline?:\n      | NodeSpec['inline']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['inline']\n          editor?: Editor\n        }) => NodeSpec['inline'])\n\n    /**\n     * Atom\n     */\n    atom?:\n      | NodeSpec['atom']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['atom']\n          editor?: Editor\n        }) => NodeSpec['atom'])\n\n    /**\n     * Selectable\n     */\n    selectable?:\n      | NodeSpec['selectable']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['selectable']\n          editor?: Editor\n        }) => NodeSpec['selectable'])\n\n    /**\n     * Draggable\n     */\n    draggable?:\n      | NodeSpec['draggable']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['draggable']\n          editor?: Editor\n        }) => NodeSpec['draggable'])\n\n    /**\n     * Code\n     */\n    code?:\n      | NodeSpec['code']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['code']\n          editor?: Editor\n        }) => NodeSpec['code'])\n\n    /**\n     * Whitespace\n     */\n    whitespace?:\n      | NodeSpec['whitespace']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['whitespace']\n          editor?: Editor\n        }) => NodeSpec['whitespace'])\n\n    /**\n     * Defining\n     */\n    defining?:\n      | NodeSpec['defining']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['defining']\n          editor?: Editor\n        }) => NodeSpec['defining'])\n\n    /**\n     * Isolating\n     */\n    isolating?:\n      | NodeSpec['isolating']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['isolating']\n          editor?: Editor\n        }) => NodeSpec['isolating'])\n\n    /**\n     * Parse HTML\n     */\n    parseHTML?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<NodeConfig<Options, Storage>>['parseHTML']\n      editor?: Editor\n    }) => NodeSpec['parseDOM']\n\n    /**\n     * Render HTML\n     */\n    renderHTML?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<NodeConfig<Options, Storage>>['renderHTML']\n            editor?: Editor\n          },\n          props: {\n            node: ProseMirrorNode\n            HTMLAttributes: Record<string, any>\n          },\n        ) => DOMOutputSpec)\n      | null\n\n    /**\n     * Render Text\n     */\n    renderText?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<NodeConfig<Options, Storage>>['renderText']\n            editor?: Editor\n          },\n          props: {\n            node: ProseMirrorNode\n            pos: number\n            parent: ProseMirrorNode\n            index: number\n          },\n        ) => string)\n      | null\n\n    /**\n     * Add Attributes\n     */\n    addAttributes?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addAttributes']\n      editor?: Editor\n    }) => Attributes | {}\n  }\n}\n\nexport class Node<Options = any, Storage = any> {\n  type = 'node'\n\n  name = 'node'\n\n  parent: Node | null = null\n\n  child: Node | null = null\n\n  options: Options\n\n  storage: Storage\n\n  config: NodeConfig = {\n    name: this.name,\n    defaultOptions: {},\n  }\n\n  constructor(config: Partial<NodeConfig<Options, Storage>> = {}) {\n    this.config = {\n      ...this.config,\n      ...config,\n    }\n\n    this.name = this.config.name\n\n    if (config.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`,\n      )\n    }\n\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions\n\n    if (this.config.addOptions) {\n      this.options = callOrReturn(\n        getExtensionField<AnyConfig['addOptions']>(this, 'addOptions', {\n          name: this.name,\n        }),\n      )\n    }\n\n    this.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(this, 'addStorage', {\n        name: this.name,\n        options: this.options,\n      }),\n    ) || {}\n  }\n\n  static create<O = any, S = any>(config: Partial<NodeConfig<O, S>> = {}) {\n    return new Node<O, S>(config)\n  }\n\n  configure(options: Partial<Options> = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend()\n\n    extension.options = mergeDeep(this.options as Record<string, any>, options) as Options\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n\n  extend<ExtendedOptions = Options, ExtendedStorage = Storage>(\n    extendedConfig: Partial<NodeConfig<ExtendedOptions, ExtendedStorage>> = {},\n  ) {\n    const extension = new Node<ExtendedOptions, ExtendedStorage>(extendedConfig)\n\n    extension.parent = this\n\n    this.child = extension\n\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name\n\n    if (extendedConfig.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`,\n      )\n    }\n\n    extension.options = callOrReturn(\n      getExtensionField<AnyConfig['addOptions']>(extension, 'addOptions', {\n        name: extension.name,\n      }),\n    )\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n}\n","export function isAndroid(): boolean {\n  return navigator.platform === 'Android' || /android/i.test(navigator.userAgent)\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { NodeSelection } from '@tiptap/pm/state'\nimport { NodeView as ProseMirrorNodeView } from '@tiptap/pm/view'\n\nimport { Editor as CoreEditor } from './Editor.js'\nimport { Node } from './Node.js'\nimport { DecorationWithType, NodeViewRendererOptions, NodeViewRendererProps } from './types.js'\nimport { isAndroid } from './utilities/isAndroid.js'\nimport { isiOS } from './utilities/isiOS.js'\n\nexport class NodeView<\n  Component,\n  NodeEditor extends CoreEditor = CoreEditor,\n  Options extends NodeViewRendererOptions = NodeViewRendererOptions,\n> implements ProseMirrorNodeView {\n  component: Component\n\n  editor: NodeEditor\n\n  options: Options\n\n  extension: Node\n\n  node: ProseMirrorNode\n\n  decorations: DecorationWithType[]\n\n  getPos: any\n\n  isDragging = false\n\n  constructor(component: Component, props: NodeViewRendererProps, options?: Partial<Options>) {\n    this.component = component\n    this.editor = props.editor as NodeEditor\n    this.options = {\n      stopEvent: null,\n      ignoreMutation: null,\n      ...options,\n    } as Options\n    this.extension = props.extension\n    this.node = props.node\n    this.decorations = props.decorations as DecorationWithType[]\n    this.getPos = props.getPos\n    this.mount()\n  }\n\n  mount() {\n    // eslint-disable-next-line\n    return\n  }\n\n  get dom(): HTMLElement {\n    return this.editor.view.dom as HTMLElement\n  }\n\n  get contentDOM(): HTMLElement | null {\n    return null\n  }\n\n  onDragStart(event: DragEvent) {\n    const { view } = this.editor\n    const target = event.target as HTMLElement\n\n    // get the drag handle element\n    // `closest` is not available for text nodes so we may have to use its parent\n    const dragHandle = target.nodeType === 3\n      ? target.parentElement?.closest('[data-drag-handle]')\n      : target.closest('[data-drag-handle]')\n\n    if (!this.dom || this.contentDOM?.contains(target) || !dragHandle) {\n      return\n    }\n\n    let x = 0\n    let y = 0\n\n    // calculate offset for drag element if we use a different drag handle element\n    if (this.dom !== dragHandle) {\n      const domBox = this.dom.getBoundingClientRect()\n      const handleBox = dragHandle.getBoundingClientRect()\n\n      // In React, we have to go through nativeEvent to reach offsetX/offsetY.\n      const offsetX = event.offsetX ?? (event as any).nativeEvent?.offsetX\n      const offsetY = event.offsetY ?? (event as any).nativeEvent?.offsetY\n\n      x = handleBox.x - domBox.x + offsetX\n      y = handleBox.y - domBox.y + offsetY\n    }\n\n    event.dataTransfer?.setDragImage(this.dom, x, y)\n\n    // we need to tell ProseMirror that we want to move the whole node\n    // so we create a NodeSelection\n    const selection = NodeSelection.create(view.state.doc, this.getPos())\n    const transaction = view.state.tr.setSelection(selection)\n\n    view.dispatch(transaction)\n  }\n\n  stopEvent(event: Event) {\n    if (!this.dom) {\n      return false\n    }\n\n    if (typeof this.options.stopEvent === 'function') {\n      return this.options.stopEvent({ event })\n    }\n\n    const target = event.target as HTMLElement\n    const isInElement = this.dom.contains(target) && !this.contentDOM?.contains(target)\n\n    // any event from child nodes should be handled by ProseMirror\n    if (!isInElement) {\n      return false\n    }\n\n    const isDragEvent = event.type.startsWith('drag')\n    const isDropEvent = event.type === 'drop'\n    const isInput = ['INPUT', 'BUTTON', 'SELECT', 'TEXTAREA'].includes(target.tagName) || target.isContentEditable\n\n    // any input event within node views should be ignored by ProseMirror\n    if (isInput && !isDropEvent && !isDragEvent) {\n      return true\n    }\n\n    const { isEditable } = this.editor\n    const { isDragging } = this\n    const isDraggable = !!this.node.type.spec.draggable\n    const isSelectable = NodeSelection.isSelectable(this.node)\n    const isCopyEvent = event.type === 'copy'\n    const isPasteEvent = event.type === 'paste'\n    const isCutEvent = event.type === 'cut'\n    const isClickEvent = event.type === 'mousedown'\n\n    // ProseMirror tries to drag selectable nodes\n    // even if `draggable` is set to `false`\n    // this fix prevents that\n    if (!isDraggable && isSelectable && isDragEvent) {\n      event.preventDefault()\n    }\n\n    if (isDraggable && isDragEvent && !isDragging) {\n      event.preventDefault()\n      return false\n    }\n\n    // we have to store that dragging started\n    if (isDraggable && isEditable && !isDragging && isClickEvent) {\n      const dragHandle = target.closest('[data-drag-handle]')\n      const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle))\n\n      if (isValidDragHandle) {\n        this.isDragging = true\n\n        document.addEventListener(\n          'dragend',\n          () => {\n            this.isDragging = false\n          },\n          { once: true },\n        )\n\n        document.addEventListener(\n          'drop',\n          () => {\n            this.isDragging = false\n          },\n          { once: true },\n        )\n\n        document.addEventListener(\n          'mouseup',\n          () => {\n            this.isDragging = false\n          },\n          { once: true },\n        )\n      }\n    }\n\n    // these events are handled by prosemirror\n    if (\n      isDragging\n      || isDropEvent\n      || isCopyEvent\n      || isPasteEvent\n      || isCutEvent\n      || (isClickEvent && isSelectable)\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  ignoreMutation(mutation: MutationRecord | { type: 'selection'; target: Element }) {\n    if (!this.dom || !this.contentDOM) {\n      return true\n    }\n\n    if (typeof this.options.ignoreMutation === 'function') {\n      return this.options.ignoreMutation({ mutation })\n    }\n\n    // a leaf/atom node is like a black box for ProseMirror\n    // and should be fully handled by the node view\n    if (this.node.isLeaf || this.node.isAtom) {\n      return true\n    }\n\n    // ProseMirror should handle any selections\n    if (mutation.type === 'selection') {\n      return false\n    }\n\n    // try to prevent a bug on iOS and Android that will break node views on enter\n    // this is because ProseMirror can’t preventDispatch on enter\n    // this will lead to a re-render of the node view on enter\n    // see: https://github.com/ueberdosis/tiptap/issues/1214\n    // see: https://github.com/ueberdosis/tiptap/issues/2534\n    if (\n      this.dom.contains(mutation.target)\n      && mutation.type === 'childList'\n      && (isiOS() || isAndroid())\n      && this.editor.isFocused\n    ) {\n      const changedNodes = [\n        ...Array.from(mutation.addedNodes),\n        ...Array.from(mutation.removedNodes),\n      ] as HTMLElement[]\n\n      // we’ll check if every changed node is contentEditable\n      // to make sure it’s probably mutated by ProseMirror\n      if (changedNodes.every(node => node.isContentEditable)) {\n        return false\n      }\n    }\n\n    // we will allow mutation contentDOM with attributes\n    // so we can for example adding classes within our node view\n    if (this.contentDOM === mutation.target && mutation.type === 'attributes') {\n      return true\n    }\n\n    // ProseMirror should handle any changes within contentDOM\n    if (this.contentDOM.contains(mutation.target)) {\n      return false\n    }\n\n    return true\n  }\n\n  updateAttributes(attributes: {}) {\n    this.editor.commands.command(({ tr }) => {\n      const pos = this.getPos()\n\n      tr.setNodeMarkup(pos, undefined, {\n        ...this.node.attrs,\n        ...attributes,\n      })\n\n      return true\n    })\n  }\n\n  deleteNode(): void {\n    const from = this.getPos()\n    const to = from + this.node.nodeSize\n\n    this.editor.commands.deleteRange({ from, to })\n  }\n}\n","import { MarkType } from '@tiptap/pm/model'\n\nimport { getMarksBetween } from '../helpers/getMarksBetween.js'\nimport { PasteRule, PasteRuleFinder } from '../PasteRule.js'\nimport { ExtendedRegExpMatchArray } from '../types.js'\nimport { callOrReturn } from '../utilities/callOrReturn.js'\n\n/**\n * Build an paste rule that adds a mark when the\n * matched text is pasted into it.\n */\nexport function markPasteRule(config: {\n  find: PasteRuleFinder\n  type: MarkType\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray, event: ClipboardEvent) => Record<string, any>)\n    | false\n    | null\n}) {\n  return new PasteRule({\n    find: config.find,\n    handler: ({\n      state, range, match, pasteEvent,\n    }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match, pasteEvent)\n\n      if (attributes === false || attributes === null) {\n        return null\n      }\n\n      const { tr } = state\n      const captureGroup = match[match.length - 1]\n      const fullMatch = match[0]\n      let markEnd = range.to\n\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/)\n        const textStart = range.from + fullMatch.indexOf(captureGroup)\n        const textEnd = textStart + captureGroup.length\n\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc)\n          .filter(item => {\n            // @ts-ignore\n            const excluded = item.mark.type.excluded as MarkType[]\n\n            return excluded.find(type => type === config.type && type !== item.mark.type)\n          })\n          .filter(item => item.to > textStart)\n\n        if (excludedMarks.length) {\n          return null\n        }\n\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to)\n        }\n\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart)\n        }\n\n        markEnd = range.from + startSpaces + captureGroup.length\n\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}))\n\n        tr.removeStoredMark(config.type)\n      }\n    },\n  })\n}\n","// source: https://stackoverflow.com/a/6969486\nexport function escapeForRegEx(string: string): string {\n  return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n}\n","export function isString(value: any): value is string {\n  return typeof value === 'string'\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { PasteRule, PasteRuleFinder } from '../PasteRule.js'\nimport { ExtendedRegExpMatchArray } from '../types.js'\nimport { callOrReturn } from '../utilities/index.js'\n\n/**\n * Build an paste rule that adds a node when the\n * matched text is pasted into it.\n */\nexport function nodePasteRule(config: {\n  find: PasteRuleFinder\n  type: NodeType\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray, event: ClipboardEvent) => Record<string, any>)\n    | false\n    | null\n}) {\n  return new PasteRule({\n    find: config.find,\n    handler({\n      match, chain, range, pasteEvent,\n    }) {\n      const attributes = callOrReturn(config.getAttributes, undefined, match, pasteEvent)\n\n      if (attributes === false || attributes === null) {\n        return null\n      }\n\n      if (match.input) {\n        chain().deleteRange(range).insertContentAt(range.from, {\n          type: config.type.name,\n          attrs: attributes,\n        })\n      }\n    },\n  })\n}\n","import { PasteRule, PasteRuleFinder } from '../PasteRule.js'\n\n/**\n * Build an paste rule that replaces text when the\n * matched text is pasted into it.\n */\nexport function textPasteRule(config: {\n  find: PasteRuleFinder,\n  replace: string,\n}) {\n  return new PasteRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      let insert = config.replace\n      let start = range.from\n      const end = range.to\n\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1])\n\n        insert += match[0].slice(offset + match[1].length)\n        start += offset\n\n        const cutOff = start - end\n\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert\n          start = end\n        }\n      }\n\n      state.tr.insertText(insert, start, end)\n    },\n  })\n}\n","import { Transaction } from '@tiptap/pm/state'\n\nexport interface TrackerResult {\n  position: number\n  deleted: boolean\n}\n\nexport class Tracker {\n  transaction: Transaction\n\n  currentStep: number\n\n  constructor(transaction: Transaction) {\n    this.transaction = transaction\n    this.currentStep = this.transaction.steps.length\n  }\n\n  map(position: number): TrackerResult {\n    let deleted = false\n\n    const mappedPosition = this.transaction.steps\n      .slice(this.currentStep)\n      .reduce((newPosition, step) => {\n        const mapResult = step.getMap().mapResult(newPosition)\n\n        if (mapResult.deleted) {\n          deleted = true\n        }\n\n        return mapResult.pos\n      }, position)\n\n    return {\n      position: mappedPosition,\n      deleted,\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}