{"ast":null,"code":"import { Mark, mergeAttributes, markPasteRule } from '@tiptap/core';\nimport { Plugin, PluginKey } from 'prosemirror-state';\nimport { find } from 'linkifyjs';\nconst Link = Mark.create({\n  name: 'link',\n  priority: 1000,\n  inclusive: false,\n  addOptions() {\n    return {\n      openOnClick: true,\n      linkOnPaste: true,\n      HTMLAttributes: {\n        target: '_blank',\n        rel: 'noopener noreferrer nofollow'\n      }\n    };\n  },\n  addAttributes() {\n    return {\n      href: {\n        default: null\n      },\n      target: {\n        default: this.options.HTMLAttributes.target\n      }\n    };\n  },\n  parseHTML() {\n    return [{\n      tag: 'a[href]'\n    }];\n  },\n  renderHTML(_ref) {\n    let {\n      HTMLAttributes\n    } = _ref;\n    return ['a', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      setLink: attributes => _ref2 => {\n        let {\n          commands\n        } = _ref2;\n        return commands.setMark('link', attributes);\n      },\n      toggleLink: attributes => _ref3 => {\n        let {\n          commands\n        } = _ref3;\n        return commands.toggleMark('link', attributes, {\n          extendEmptyMarkRange: true\n        });\n      },\n      unsetLink: () => _ref4 => {\n        let {\n          commands\n        } = _ref4;\n        return commands.unsetMark('link', {\n          extendEmptyMarkRange: true\n        });\n      }\n    };\n  },\n  addPasteRules() {\n    return [markPasteRule({\n      find: text => find(text).filter(link => link.isLink).map(link => ({\n        text: link.value,\n        index: link.start,\n        data: link\n      })),\n      type: this.type,\n      getAttributes: match => {\n        var _a;\n        return {\n          href: (_a = match.data) === null || _a === void 0 ? void 0 : _a.href\n        };\n      }\n    })];\n  },\n  addProseMirrorPlugins() {\n    const plugins = [];\n    if (this.options.openOnClick) {\n      plugins.push(new Plugin({\n        key: new PluginKey('handleClickLink'),\n        props: {\n          handleClick: (view, pos, event) => {\n            var _a;\n            const attrs = this.editor.getAttributes('link');\n            const link = (_a = event.target) === null || _a === void 0 ? void 0 : _a.closest('a');\n            if (link && attrs.href) {\n              window.open(attrs.href, attrs.target);\n              return true;\n            }\n            return false;\n          }\n        }\n      }));\n    }\n    if (this.options.linkOnPaste) {\n      plugins.push(new Plugin({\n        key: new PluginKey('handlePasteLink'),\n        props: {\n          handlePaste: (view, event, slice) => {\n            const {\n              state\n            } = view;\n            const {\n              selection\n            } = state;\n            const {\n              empty\n            } = selection;\n            if (empty) {\n              return false;\n            }\n            let textContent = '';\n            slice.content.forEach(node => {\n              textContent += node.textContent;\n            });\n            const link = find(textContent).find(item => item.isLink && item.value === textContent);\n            if (!textContent || !link) {\n              return false;\n            }\n            this.editor.commands.setMark(this.type, {\n              href: link.href\n            });\n            return true;\n          }\n        }\n      }));\n    }\n    return plugins;\n  }\n});\nexport { Link, Link as default };","map":{"version":3,"names":["Link","Mark","create","name","priority","inclusive","addOptions","openOnClick","linkOnPaste","HTMLAttributes","target","rel","addAttributes","href","default","options","parseHTML","tag","renderHTML","_ref","mergeAttributes","addCommands","setLink","attributes","_ref2","commands","setMark","toggleLink","_ref3","toggleMark","extendEmptyMarkRange","unsetLink","_ref4","unsetMark","addPasteRules","markPasteRule","find","text","filter","link","isLink","map","value","index","start","data","type","getAttributes","match","_a","addProseMirrorPlugins","plugins","push","Plugin","key","PluginKey","props","handleClick","view","pos","event","attrs","editor","closest","window","open","handlePaste","slice","state","selection","empty","textContent","content","forEach","node","item"],"sources":["/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/extension-link/src/link.ts"],"sourcesContent":["import {\n  Mark,\n  markPasteRule,\n  mergeAttributes,\n} from '@tiptap/core'\nimport { Plugin, PluginKey } from 'prosemirror-state'\nimport { find } from 'linkifyjs'\n\nexport interface LinkOptions {\n  /**\n   * If enabled, links will be opened on click.\n   */\n  openOnClick: boolean,\n  /**\n   * Adds a link to the current selection if the pasted content only contains an url.\n   */\n  linkOnPaste: boolean,\n  /**\n   * A list of HTML attributes to be rendered.\n   */\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    link: {\n      /**\n       * Set a link mark\n       */\n      setLink: (attributes: { href: string, target?: string }) => ReturnType,\n      /**\n       * Toggle a link mark\n       */\n      toggleLink: (attributes: { href: string, target?: string }) => ReturnType,\n      /**\n       * Unset a link mark\n       */\n      unsetLink: () => ReturnType,\n    }\n  }\n}\n\nexport const Link = Mark.create<LinkOptions>({\n  name: 'link',\n\n  priority: 1000,\n\n  inclusive: false,\n\n  addOptions() {\n    return {\n      openOnClick: true,\n      linkOnPaste: true,\n      HTMLAttributes: {\n        target: '_blank',\n        rel: 'noopener noreferrer nofollow',\n      },\n    }\n  },\n\n  addAttributes() {\n    return {\n      href: {\n        default: null,\n      },\n      target: {\n        default: this.options.HTMLAttributes.target,\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      { tag: 'a[href]' },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['a', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      setLink: attributes => ({ commands }) => {\n        return commands.setMark('link', attributes)\n      },\n      toggleLink: attributes => ({ commands }) => {\n        return commands.toggleMark('link', attributes, { extendEmptyMarkRange: true })\n      },\n      unsetLink: () => ({ commands }) => {\n        return commands.unsetMark('link', { extendEmptyMarkRange: true })\n      },\n    }\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: text => find(text)\n          .filter(link => link.isLink)\n          .map(link => ({\n            text: link.value,\n            index: link.start,\n            data: link,\n          })),\n        type: this.type,\n        getAttributes: match => ({\n          href: match.data?.href,\n        }),\n      }),\n    ]\n  },\n\n  addProseMirrorPlugins() {\n    const plugins = []\n\n    if (this.options.openOnClick) {\n      plugins.push(\n        new Plugin({\n          key: new PluginKey('handleClickLink'),\n          props: {\n            handleClick: (view, pos, event) => {\n              const attrs = this.editor.getAttributes('link')\n              const link = (event.target as HTMLElement)?.closest('a')\n\n              if (link && attrs.href) {\n                window.open(attrs.href, attrs.target)\n\n                return true\n              }\n\n              return false\n            },\n          },\n        }),\n      )\n    }\n\n    if (this.options.linkOnPaste) {\n      plugins.push(\n        new Plugin({\n          key: new PluginKey('handlePasteLink'),\n          props: {\n            handlePaste: (view, event, slice) => {\n              const { state } = view\n              const { selection } = state\n              const { empty } = selection\n\n              if (empty) {\n                return false\n              }\n\n              let textContent = ''\n\n              slice.content.forEach(node => {\n                textContent += node.textContent\n              })\n\n              const link = find(textContent)\n                .find(item => item.isLink && item.value === textContent)\n\n              if (!textContent || !link) {\n                return false\n              }\n\n              this.editor.commands.setMark(this.type, {\n                href: link.href,\n              })\n\n              return true\n            },\n          },\n        }),\n      )\n    }\n\n    return plugins\n  },\n})\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}