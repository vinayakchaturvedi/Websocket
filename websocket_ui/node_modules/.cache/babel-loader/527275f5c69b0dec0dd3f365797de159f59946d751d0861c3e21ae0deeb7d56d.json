{"ast":null,"code":"import { Plugin, PluginKey, TextSelection, Selection, NodeSelection, EditorState } from '@tiptap/pm/state';\nimport { EditorView } from '@tiptap/pm/view';\nimport { keymap } from '@tiptap/pm/keymap';\nimport { Schema, Fragment, DOMParser, DOMSerializer, Node as Node$1, Slice } from '@tiptap/pm/model';\nimport { liftTarget, ReplaceStep, ReplaceAroundStep, joinPoint, Transform, canSplit, canJoin, findWrapping } from '@tiptap/pm/transform';\nimport { createParagraphNear as createParagraphNear$1, deleteSelection as deleteSelection$1, exitCode as exitCode$1, joinUp as joinUp$1, joinDown as joinDown$1, joinBackward as joinBackward$1, joinForward as joinForward$1, lift as lift$1, liftEmptyBlock as liftEmptyBlock$1, newlineInCode as newlineInCode$1, selectNodeBackward as selectNodeBackward$1, selectNodeForward as selectNodeForward$1, selectParentNode as selectParentNode$1, selectTextblockEnd as selectTextblockEnd$1, selectTextblockStart as selectTextblockStart$1, setBlockType, wrapIn as wrapIn$1 } from '@tiptap/pm/commands';\nimport { liftListItem as liftListItem$1, sinkListItem as sinkListItem$1, wrapInList as wrapInList$1 } from '@tiptap/pm/schema-list';\nfunction createChainableState(config) {\n  const {\n    state,\n    transaction\n  } = config;\n  let {\n    selection\n  } = transaction;\n  let {\n    doc\n  } = transaction;\n  let {\n    storedMarks\n  } = transaction;\n  return {\n    ...state,\n    apply: state.apply.bind(state),\n    applyTransaction: state.applyTransaction.bind(state),\n    filterTransaction: state.filterTransaction,\n    plugins: state.plugins,\n    schema: state.schema,\n    reconfigure: state.reconfigure.bind(state),\n    toJSON: state.toJSON.bind(state),\n    get storedMarks() {\n      return storedMarks;\n    },\n    get selection() {\n      return selection;\n    },\n    get doc() {\n      return doc;\n    },\n    get tr() {\n      selection = transaction.selection;\n      doc = transaction.doc;\n      storedMarks = transaction.storedMarks;\n      return transaction;\n    }\n  };\n}\nclass CommandManager {\n  constructor(props) {\n    this.editor = props.editor;\n    this.rawCommands = this.editor.extensionManager.commands;\n    this.customState = props.state;\n  }\n  get hasCustomState() {\n    return !!this.customState;\n  }\n  get state() {\n    return this.customState || this.editor.state;\n  }\n  get commands() {\n    var _this = this;\n    const {\n      rawCommands,\n      editor,\n      state\n    } = this;\n    const {\n      view\n    } = editor;\n    const {\n      tr\n    } = state;\n    const props = this.buildProps(tr);\n    return Object.fromEntries(Object.entries(rawCommands).map(_ref => {\n      let [name, command] = _ref;\n      const method = function () {\n        const callback = command(...arguments)(props);\n        if (!tr.getMeta('preventDispatch') && !_this.hasCustomState) {\n          view.dispatch(tr);\n        }\n        return callback;\n      };\n      return [name, method];\n    }));\n  }\n  get chain() {\n    return () => this.createChain();\n  }\n  get can() {\n    return () => this.createCan();\n  }\n  createChain(startTr) {\n    var _this2 = this;\n    let shouldDispatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const {\n      rawCommands,\n      editor,\n      state\n    } = this;\n    const {\n      view\n    } = editor;\n    const callbacks = [];\n    const hasStartTransaction = !!startTr;\n    const tr = startTr || state.tr;\n    const run = () => {\n      if (!hasStartTransaction && shouldDispatch && !tr.getMeta('preventDispatch') && !this.hasCustomState) {\n        view.dispatch(tr);\n      }\n      return callbacks.every(callback => callback === true);\n    };\n    const chain = {\n      ...Object.fromEntries(Object.entries(rawCommands).map(_ref2 => {\n        let [name, command] = _ref2;\n        const chainedCommand = function () {\n          const props = _this2.buildProps(tr, shouldDispatch);\n          const callback = command(...arguments)(props);\n          callbacks.push(callback);\n          return chain;\n        };\n        return [name, chainedCommand];\n      })),\n      run\n    };\n    return chain;\n  }\n  createCan(startTr) {\n    const {\n      rawCommands,\n      state\n    } = this;\n    const dispatch = false;\n    const tr = startTr || state.tr;\n    const props = this.buildProps(tr, dispatch);\n    const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(_ref3 => {\n      let [name, command] = _ref3;\n      return [name, function () {\n        return command(...arguments)({\n          ...props,\n          dispatch: undefined\n        });\n      }];\n    }));\n    return {\n      ...formattedCommands,\n      chain: () => this.createChain(tr, dispatch)\n    };\n  }\n  buildProps(tr) {\n    let shouldDispatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const {\n      rawCommands,\n      editor,\n      state\n    } = this;\n    const {\n      view\n    } = editor;\n    const props = {\n      tr,\n      editor,\n      view,\n      state: createChainableState({\n        state,\n        transaction: tr\n      }),\n      dispatch: shouldDispatch ? () => undefined : undefined,\n      chain: () => this.createChain(tr, shouldDispatch),\n      can: () => this.createCan(tr),\n      get commands() {\n        return Object.fromEntries(Object.entries(rawCommands).map(_ref4 => {\n          let [name, command] = _ref4;\n          return [name, function () {\n            return command(...arguments)(props);\n          }];\n        }));\n      }\n    };\n    return props;\n  }\n}\nclass EventEmitter {\n  constructor() {\n    this.callbacks = {};\n  }\n  on(event, fn) {\n    if (!this.callbacks[event]) {\n      this.callbacks[event] = [];\n    }\n    this.callbacks[event].push(fn);\n    return this;\n  }\n  emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    const callbacks = this.callbacks[event];\n    if (callbacks) {\n      callbacks.forEach(callback => callback.apply(this, args));\n    }\n    return this;\n  }\n  off(event, fn) {\n    const callbacks = this.callbacks[event];\n    if (callbacks) {\n      if (fn) {\n        this.callbacks[event] = callbacks.filter(callback => callback !== fn);\n      } else {\n        delete this.callbacks[event];\n      }\n    }\n    return this;\n  }\n  removeAllListeners() {\n    this.callbacks = {};\n  }\n}\nfunction getExtensionField(extension, field, context) {\n  if (extension.config[field] === undefined && extension.parent) {\n    return getExtensionField(extension.parent, field, context);\n  }\n  if (typeof extension.config[field] === 'function') {\n    const value = extension.config[field].bind({\n      ...context,\n      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null\n    });\n    return value;\n  }\n  return extension.config[field];\n}\nfunction splitExtensions(extensions) {\n  const baseExtensions = extensions.filter(extension => extension.type === 'extension');\n  const nodeExtensions = extensions.filter(extension => extension.type === 'node');\n  const markExtensions = extensions.filter(extension => extension.type === 'mark');\n  return {\n    baseExtensions,\n    nodeExtensions,\n    markExtensions\n  };\n}\n\n/**\r\n * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.\r\n * @param extensions List of extensions\r\n */\nfunction getAttributesFromExtensions(extensions) {\n  const extensionAttributes = [];\n  const {\n    nodeExtensions,\n    markExtensions\n  } = splitExtensions(extensions);\n  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];\n  const defaultAttribute = {\n    default: null,\n    rendered: true,\n    renderHTML: null,\n    parseHTML: null,\n    keepOnSplit: true,\n    isRequired: false\n  };\n  extensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    const addGlobalAttributes = getExtensionField(extension, 'addGlobalAttributes', context);\n    if (!addGlobalAttributes) {\n      return;\n    }\n    // TODO: remove `as GlobalAttributes`\n    const globalAttributes = addGlobalAttributes();\n    globalAttributes.forEach(globalAttribute => {\n      globalAttribute.types.forEach(type => {\n        Object.entries(globalAttribute.attributes).forEach(_ref5 => {\n          let [name, attribute] = _ref5;\n          extensionAttributes.push({\n            type,\n            name,\n            attribute: {\n              ...defaultAttribute,\n              ...attribute\n            }\n          });\n        });\n      });\n    });\n  });\n  nodeAndMarkExtensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    const addAttributes = getExtensionField(extension, 'addAttributes', context);\n    if (!addAttributes) {\n      return;\n    }\n    // TODO: remove `as Attributes`\n    const attributes = addAttributes();\n    Object.entries(attributes).forEach(_ref6 => {\n      let [name, attribute] = _ref6;\n      const mergedAttr = {\n        ...defaultAttribute,\n        ...attribute\n      };\n      if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === 'function') {\n        mergedAttr.default = mergedAttr.default();\n      }\n      if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === undefined) {\n        delete mergedAttr.default;\n      }\n      extensionAttributes.push({\n        type: extension.name,\n        name,\n        attribute: mergedAttr\n      });\n    });\n  });\n  return extensionAttributes;\n}\nfunction getNodeType(nameOrType, schema) {\n  if (typeof nameOrType === 'string') {\n    if (!schema.nodes[nameOrType]) {\n      throw Error(\"There is no node type named '\".concat(nameOrType, \"'. Maybe you forgot to add the extension?\"));\n    }\n    return schema.nodes[nameOrType];\n  }\n  return nameOrType;\n}\nfunction mergeAttributes() {\n  for (var _len2 = arguments.length, objects = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    objects[_key2] = arguments[_key2];\n  }\n  return objects.filter(item => !!item).reduce((items, item) => {\n    const mergedAttributes = {\n      ...items\n    };\n    Object.entries(item).forEach(_ref7 => {\n      let [key, value] = _ref7;\n      const exists = mergedAttributes[key];\n      if (!exists) {\n        mergedAttributes[key] = value;\n        return;\n      }\n      if (key === 'class') {\n        const valueClasses = value ? value.split(' ') : [];\n        const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(' ') : [];\n        const insertClasses = valueClasses.filter(valueClass => !existingClasses.includes(valueClass));\n        mergedAttributes[key] = [...existingClasses, ...insertClasses].join(' ');\n      } else if (key === 'style') {\n        mergedAttributes[key] = [mergedAttributes[key], value].join('; ');\n      } else {\n        mergedAttributes[key] = value;\n      }\n    });\n    return mergedAttributes;\n  }, {});\n}\nfunction getRenderedAttributes(nodeOrMark, extensionAttributes) {\n  return extensionAttributes.filter(item => item.attribute.rendered).map(item => {\n    if (!item.attribute.renderHTML) {\n      return {\n        [item.name]: nodeOrMark.attrs[item.name]\n      };\n    }\n    return item.attribute.renderHTML(nodeOrMark.attrs) || {};\n  }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});\n}\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n\n/**\r\n * Optionally calls `value` as a function.\r\n * Otherwise it is returned directly.\r\n * @param value Function or any value.\r\n * @param context Optional context to bind to function.\r\n * @param props Optional props to pass to function.\r\n */\nfunction callOrReturn(value) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  if (isFunction(value)) {\n    for (var _len3 = arguments.length, props = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      props[_key3 - 2] = arguments[_key3];\n    }\n    if (context) {\n      return value.bind(context)(...props);\n    }\n    return value(...props);\n  }\n  return value;\n}\nfunction isEmptyObject() {\n  let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return Object.keys(value).length === 0 && value.constructor === Object;\n}\nfunction fromString(value) {\n  if (typeof value !== 'string') {\n    return value;\n  }\n  if (value.match(/^[+-]?(?:\\d*\\.)?\\d+$/)) {\n    return Number(value);\n  }\n  if (value === 'true') {\n    return true;\n  }\n  if (value === 'false') {\n    return false;\n  }\n  return value;\n}\n\n/**\r\n * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).\r\n * Cancels when `getAttrs` returned `false`.\r\n * @param parseRule ProseMirror ParseRule\r\n * @param extensionAttributes List of attributes to inject\r\n */\nfunction injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {\n  if (parseRule.style) {\n    return parseRule;\n  }\n  return {\n    ...parseRule,\n    getAttrs: node => {\n      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;\n      if (oldAttributes === false) {\n        return false;\n      }\n      const newAttributes = extensionAttributes.reduce((items, item) => {\n        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));\n        if (value === null || value === undefined) {\n          return items;\n        }\n        return {\n          ...items,\n          [item.name]: value\n        };\n      }, {});\n      return {\n        ...oldAttributes,\n        ...newAttributes\n      };\n    }\n  };\n}\nfunction cleanUpSchemaItem(data) {\n  return Object.fromEntries(\n  // @ts-ignore\n  Object.entries(data).filter(_ref8 => {\n    let [key, value] = _ref8;\n    if (key === 'attrs' && isEmptyObject(value)) {\n      return false;\n    }\n    return value !== null && value !== undefined;\n  }));\n}\nfunction getSchemaByResolvedExtensions(extensions, editor) {\n  var _a;\n  const allAttributes = getAttributesFromExtensions(extensions);\n  const {\n    nodeExtensions,\n    markExtensions\n  } = splitExtensions(extensions);\n  const topNode = (_a = nodeExtensions.find(extension => getExtensionField(extension, 'topNode'))) === null || _a === void 0 ? void 0 : _a.name;\n  const nodes = Object.fromEntries(nodeExtensions.map(extension => {\n    const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name);\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n      editor\n    };\n    const extraNodeFields = extensions.reduce((fields, e) => {\n      const extendNodeSchema = getExtensionField(e, 'extendNodeSchema', context);\n      return {\n        ...fields,\n        ...(extendNodeSchema ? extendNodeSchema(extension) : {})\n      };\n    }, {});\n    const schema = cleanUpSchemaItem({\n      ...extraNodeFields,\n      content: callOrReturn(getExtensionField(extension, 'content', context)),\n      marks: callOrReturn(getExtensionField(extension, 'marks', context)),\n      group: callOrReturn(getExtensionField(extension, 'group', context)),\n      inline: callOrReturn(getExtensionField(extension, 'inline', context)),\n      atom: callOrReturn(getExtensionField(extension, 'atom', context)),\n      selectable: callOrReturn(getExtensionField(extension, 'selectable', context)),\n      draggable: callOrReturn(getExtensionField(extension, 'draggable', context)),\n      code: callOrReturn(getExtensionField(extension, 'code', context)),\n      defining: callOrReturn(getExtensionField(extension, 'defining', context)),\n      isolating: callOrReturn(getExtensionField(extension, 'isolating', context)),\n      attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\n        var _a;\n        return [extensionAttribute.name, {\n          default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default\n        }];\n      }))\n    });\n    const parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));\n    if (parseHTML) {\n      schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\n    }\n    const renderHTML = getExtensionField(extension, 'renderHTML', context);\n    if (renderHTML) {\n      schema.toDOM = node => renderHTML({\n        node,\n        HTMLAttributes: getRenderedAttributes(node, extensionAttributes)\n      });\n    }\n    const renderText = getExtensionField(extension, 'renderText', context);\n    if (renderText) {\n      schema.toText = renderText;\n    }\n    return [extension.name, schema];\n  }));\n  const marks = Object.fromEntries(markExtensions.map(extension => {\n    const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name);\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n      editor\n    };\n    const extraMarkFields = extensions.reduce((fields, e) => {\n      const extendMarkSchema = getExtensionField(e, 'extendMarkSchema', context);\n      return {\n        ...fields,\n        ...(extendMarkSchema ? extendMarkSchema(extension) : {})\n      };\n    }, {});\n    const schema = cleanUpSchemaItem({\n      ...extraMarkFields,\n      inclusive: callOrReturn(getExtensionField(extension, 'inclusive', context)),\n      excludes: callOrReturn(getExtensionField(extension, 'excludes', context)),\n      group: callOrReturn(getExtensionField(extension, 'group', context)),\n      spanning: callOrReturn(getExtensionField(extension, 'spanning', context)),\n      code: callOrReturn(getExtensionField(extension, 'code', context)),\n      attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\n        var _a;\n        return [extensionAttribute.name, {\n          default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default\n        }];\n      }))\n    });\n    const parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));\n    if (parseHTML) {\n      schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\n    }\n    const renderHTML = getExtensionField(extension, 'renderHTML', context);\n    if (renderHTML) {\n      schema.toDOM = mark => renderHTML({\n        mark,\n        HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)\n      });\n    }\n    return [extension.name, schema];\n  }));\n  return new Schema({\n    topNode,\n    nodes,\n    marks\n  });\n}\nfunction getSchemaTypeByName(name, schema) {\n  return schema.nodes[name] || schema.marks[name] || null;\n}\nfunction isExtensionRulesEnabled(extension, enabled) {\n  if (Array.isArray(enabled)) {\n    return enabled.some(enabledExtension => {\n      const name = typeof enabledExtension === 'string' ? enabledExtension : enabledExtension.name;\n      return name === extension.name;\n    });\n  }\n  return enabled;\n}\nconst getTextContentFromNodes = function ($from) {\n  let maxMatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;\n  let textBefore = '';\n  const sliceEndPos = $from.parentOffset;\n  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index) => {\n    var _a, _b;\n    const chunk = ((_b = (_a = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a, {\n      node,\n      pos,\n      parent,\n      index\n    })) || node.textContent || '%leaf%';\n    textBefore += chunk.slice(0, Math.max(0, sliceEndPos - pos));\n  });\n  return textBefore;\n};\nfunction isRegExp(value) {\n  return Object.prototype.toString.call(value) === '[object RegExp]';\n}\nclass InputRule {\n  constructor(config) {\n    this.find = config.find;\n    this.handler = config.handler;\n  }\n}\nconst inputRuleMatcherHandler = (text, find) => {\n  if (isRegExp(find)) {\n    return find.exec(text);\n  }\n  const inputRuleMatch = find(text);\n  if (!inputRuleMatch) {\n    return null;\n  }\n  const result = [inputRuleMatch.text];\n  result.index = inputRuleMatch.index;\n  result.input = text;\n  result.data = inputRuleMatch.data;\n  if (inputRuleMatch.replaceWith) {\n    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {\n      console.warn('[tiptap warn]: \"inputRuleMatch.replaceWith\" must be part of \"inputRuleMatch.text\".');\n    }\n    result.push(inputRuleMatch.replaceWith);\n  }\n  return result;\n};\nfunction run$1(config) {\n  var _a;\n  const {\n    editor,\n    from,\n    to,\n    text,\n    rules,\n    plugin\n  } = config;\n  const {\n    view\n  } = editor;\n  if (view.composing) {\n    return false;\n  }\n  const $from = view.state.doc.resolve(from);\n  if (\n  // check for code node\n  $from.parent.type.spec.code\n  // check for code mark\n  || !!((_a = $from.nodeBefore || $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.marks.find(mark => mark.type.spec.code))) {\n    return false;\n  }\n  let matched = false;\n  const textBefore = getTextContentFromNodes($from) + text;\n  rules.forEach(rule => {\n    if (matched) {\n      return;\n    }\n    const match = inputRuleMatcherHandler(textBefore, rule.find);\n    if (!match) {\n      return;\n    }\n    const tr = view.state.tr;\n    const state = createChainableState({\n      state: view.state,\n      transaction: tr\n    });\n    const range = {\n      from: from - (match[0].length - text.length),\n      to\n    };\n    const {\n      commands,\n      chain,\n      can\n    } = new CommandManager({\n      editor,\n      state\n    });\n    const handler = rule.handler({\n      state,\n      range,\n      match,\n      commands,\n      chain,\n      can\n    });\n    // stop if there are no changes\n    if (handler === null || !tr.steps.length) {\n      return;\n    }\n    // store transform as meta data\n    // so we can undo input rules within the `undoInputRules` command\n    tr.setMeta(plugin, {\n      transform: tr,\n      from,\n      to,\n      text\n    });\n    view.dispatch(tr);\n    matched = true;\n  });\n  return matched;\n}\n/**\r\n * Create an input rules plugin. When enabled, it will cause text\r\n * input that matches any of the given rules to trigger the rule’s\r\n * action.\r\n */\nfunction inputRulesPlugin(props) {\n  const {\n    editor,\n    rules\n  } = props;\n  const plugin = new Plugin({\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, prev) {\n        const stored = tr.getMeta(plugin);\n        if (stored) {\n          return stored;\n        }\n        return tr.selectionSet || tr.docChanged ? null : prev;\n      }\n    },\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run$1({\n          editor,\n          from,\n          to,\n          text,\n          rules,\n          plugin\n        });\n      },\n      handleDOMEvents: {\n        compositionend: view => {\n          setTimeout(() => {\n            const {\n              $cursor\n            } = view.state.selection;\n            if ($cursor) {\n              run$1({\n                editor,\n                from: $cursor.pos,\n                to: $cursor.pos,\n                text: '',\n                rules,\n                plugin\n              });\n            }\n          });\n          return false;\n        }\n      },\n      // add support for input rules to trigger on enter\n      // this is useful for example for code blocks\n      handleKeyDown(view, event) {\n        if (event.key !== 'Enter') {\n          return false;\n        }\n        const {\n          $cursor\n        } = view.state.selection;\n        if ($cursor) {\n          return run$1({\n            editor,\n            from: $cursor.pos,\n            to: $cursor.pos,\n            text: '\\n',\n            rules,\n            plugin\n          });\n        }\n        return false;\n      }\n    },\n    // @ts-ignore\n    isInputRules: true\n  });\n  return plugin;\n}\nfunction isNumber(value) {\n  return typeof value === 'number';\n}\nclass PasteRule {\n  constructor(config) {\n    this.find = config.find;\n    this.handler = config.handler;\n  }\n}\nconst pasteRuleMatcherHandler = (text, find) => {\n  if (isRegExp(find)) {\n    return [...text.matchAll(find)];\n  }\n  const matches = find(text);\n  if (!matches) {\n    return [];\n  }\n  return matches.map(pasteRuleMatch => {\n    const result = [pasteRuleMatch.text];\n    result.index = pasteRuleMatch.index;\n    result.input = text;\n    result.data = pasteRuleMatch.data;\n    if (pasteRuleMatch.replaceWith) {\n      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {\n        console.warn('[tiptap warn]: \"pasteRuleMatch.replaceWith\" must be part of \"pasteRuleMatch.text\".');\n      }\n      result.push(pasteRuleMatch.replaceWith);\n    }\n    return result;\n  });\n};\nfunction run(config) {\n  const {\n    editor,\n    state,\n    from,\n    to,\n    rule,\n    pasteEvent,\n    dropEvent\n  } = config;\n  const {\n    commands,\n    chain,\n    can\n  } = new CommandManager({\n    editor,\n    state\n  });\n  const handlers = [];\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isTextblock || node.type.spec.code) {\n      return;\n    }\n    const resolvedFrom = Math.max(from, pos);\n    const resolvedTo = Math.min(to, pos + node.content.size);\n    const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, undefined, '\\ufffc');\n    const matches = pasteRuleMatcherHandler(textToMatch, rule.find);\n    matches.forEach(match => {\n      if (match.index === undefined) {\n        return;\n      }\n      const start = resolvedFrom + match.index + 1;\n      const end = start + match[0].length;\n      const range = {\n        from: state.tr.mapping.map(start),\n        to: state.tr.mapping.map(end)\n      };\n      const handler = rule.handler({\n        state,\n        range,\n        match,\n        commands,\n        chain,\n        can,\n        pasteEvent,\n        dropEvent\n      });\n      handlers.push(handler);\n    });\n  });\n  const success = handlers.every(handler => handler !== null);\n  return success;\n}\n/**\r\n * Create an paste rules plugin. When enabled, it will cause pasted\r\n * text that matches any of the given rules to trigger the rule’s\r\n * action.\r\n */\nfunction pasteRulesPlugin(props) {\n  const {\n    editor,\n    rules\n  } = props;\n  let dragSourceElement = null;\n  let isPastedFromProseMirror = false;\n  let isDroppedFromProseMirror = false;\n  let pasteEvent = new ClipboardEvent('paste');\n  let dropEvent = new DragEvent('drop');\n  const plugins = rules.map(rule => {\n    return new Plugin({\n      // we register a global drag handler to track the current drag source element\n      view(view) {\n        const handleDragstart = event => {\n          var _a;\n          dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;\n        };\n        window.addEventListener('dragstart', handleDragstart);\n        return {\n          destroy() {\n            window.removeEventListener('dragstart', handleDragstart);\n          }\n        };\n      },\n      props: {\n        handleDOMEvents: {\n          drop: (view, event) => {\n            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;\n            dropEvent = event;\n            return false;\n          },\n          paste: (_view, event) => {\n            var _a;\n            const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData('text/html');\n            pasteEvent = event;\n            isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes('data-pm-slice'));\n            return false;\n          }\n        }\n      },\n      appendTransaction: (transactions, oldState, state) => {\n        const transaction = transactions[0];\n        const isPaste = transaction.getMeta('uiEvent') === 'paste' && !isPastedFromProseMirror;\n        const isDrop = transaction.getMeta('uiEvent') === 'drop' && !isDroppedFromProseMirror;\n        if (!isPaste && !isDrop) {\n          return;\n        }\n        // stop if there is no changed range\n        const from = oldState.doc.content.findDiffStart(state.doc.content);\n        const to = oldState.doc.content.findDiffEnd(state.doc.content);\n        if (!isNumber(from) || !to || from === to.b) {\n          return;\n        }\n        // build a chainable state\n        // so we can use a single transaction for all paste rules\n        const tr = state.tr;\n        const chainableState = createChainableState({\n          state,\n          transaction: tr\n        });\n        const handler = run({\n          editor,\n          state: chainableState,\n          from: Math.max(from - 1, 0),\n          to: to.b - 1,\n          rule,\n          pasteEvent,\n          dropEvent\n        });\n        // stop if there are no changes\n        if (!handler || !tr.steps.length) {\n          return;\n        }\n        dropEvent = new DragEvent('drop');\n        pasteEvent = new ClipboardEvent('paste');\n        return tr;\n      }\n    });\n  });\n  return plugins;\n}\nfunction findDuplicates(items) {\n  const filtered = items.filter((el, index) => items.indexOf(el) !== index);\n  return [...new Set(filtered)];\n}\nclass ExtensionManager {\n  constructor(extensions, editor) {\n    this.splittableMarks = [];\n    this.editor = editor;\n    this.extensions = ExtensionManager.resolve(extensions);\n    this.schema = getSchemaByResolvedExtensions(this.extensions, editor);\n    this.extensions.forEach(extension => {\n      var _a;\n      // store extension storage in editor\n      this.editor.extensionStorage[extension.name] = extension.storage;\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      if (extension.type === 'mark') {\n        const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, 'keepOnSplit', context))) !== null && _a !== void 0 ? _a : true;\n        if (keepOnSplit) {\n          this.splittableMarks.push(extension.name);\n        }\n      }\n      const onBeforeCreate = getExtensionField(extension, 'onBeforeCreate', context);\n      if (onBeforeCreate) {\n        this.editor.on('beforeCreate', onBeforeCreate);\n      }\n      const onCreate = getExtensionField(extension, 'onCreate', context);\n      if (onCreate) {\n        this.editor.on('create', onCreate);\n      }\n      const onUpdate = getExtensionField(extension, 'onUpdate', context);\n      if (onUpdate) {\n        this.editor.on('update', onUpdate);\n      }\n      const onSelectionUpdate = getExtensionField(extension, 'onSelectionUpdate', context);\n      if (onSelectionUpdate) {\n        this.editor.on('selectionUpdate', onSelectionUpdate);\n      }\n      const onTransaction = getExtensionField(extension, 'onTransaction', context);\n      if (onTransaction) {\n        this.editor.on('transaction', onTransaction);\n      }\n      const onFocus = getExtensionField(extension, 'onFocus', context);\n      if (onFocus) {\n        this.editor.on('focus', onFocus);\n      }\n      const onBlur = getExtensionField(extension, 'onBlur', context);\n      if (onBlur) {\n        this.editor.on('blur', onBlur);\n      }\n      const onDestroy = getExtensionField(extension, 'onDestroy', context);\n      if (onDestroy) {\n        this.editor.on('destroy', onDestroy);\n      }\n    });\n  }\n  static resolve(extensions) {\n    const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions));\n    const duplicatedNames = findDuplicates(resolvedExtensions.map(extension => extension.name));\n    if (duplicatedNames.length) {\n      console.warn(\"[tiptap warn]: Duplicate extension names found: [\".concat(duplicatedNames.map(item => \"'\".concat(item, \"'\")).join(', '), \"]. This can lead to issues.\"));\n    }\n    return resolvedExtensions;\n  }\n  static flatten(extensions) {\n    return extensions.map(extension => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage\n      };\n      const addExtensions = getExtensionField(extension, 'addExtensions', context);\n      if (addExtensions) {\n        return [extension, ...this.flatten(addExtensions())];\n      }\n      return extension;\n    })\n    // `Infinity` will break TypeScript so we set a number that is probably high enough\n    .flat(10);\n  }\n  static sort(extensions) {\n    const defaultPriority = 100;\n    return extensions.sort((a, b) => {\n      const priorityA = getExtensionField(a, 'priority') || defaultPriority;\n      const priorityB = getExtensionField(b, 'priority') || defaultPriority;\n      if (priorityA > priorityB) {\n        return -1;\n      }\n      if (priorityA < priorityB) {\n        return 1;\n      }\n      return 0;\n    });\n  }\n  get commands() {\n    return this.extensions.reduce((commands, extension) => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      const addCommands = getExtensionField(extension, 'addCommands', context);\n      if (!addCommands) {\n        return commands;\n      }\n      return {\n        ...commands,\n        ...addCommands()\n      };\n    }, {});\n  }\n  get plugins() {\n    const {\n      editor\n    } = this;\n    // With ProseMirror, first plugins within an array are executed first.\n    // In Tiptap, we provide the ability to override plugins,\n    // so it feels more natural to run plugins at the end of an array first.\n    // That’s why we have to reverse the `extensions` array and sort again\n    // based on the `priority` option.\n    const extensions = ExtensionManager.sort([...this.extensions].reverse());\n    const inputRules = [];\n    const pasteRules = [];\n    const allPlugins = extensions.map(extension => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      const plugins = [];\n      const addKeyboardShortcuts = getExtensionField(extension, 'addKeyboardShortcuts', context);\n      let defaultBindings = {};\n      // bind exit handling\n      if (extension.type === 'mark' && extension.config.exitable) {\n        defaultBindings.ArrowRight = () => Mark.handleExit({\n          editor,\n          mark: extension\n        });\n      }\n      if (addKeyboardShortcuts) {\n        const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(_ref9 => {\n          let [shortcut, method] = _ref9;\n          return [shortcut, () => method({\n            editor\n          })];\n        }));\n        defaultBindings = {\n          ...defaultBindings,\n          ...bindings\n        };\n      }\n      const keyMapPlugin = keymap(defaultBindings);\n      plugins.push(keyMapPlugin);\n      const addInputRules = getExtensionField(extension, 'addInputRules', context);\n      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {\n        inputRules.push(...addInputRules());\n      }\n      const addPasteRules = getExtensionField(extension, 'addPasteRules', context);\n      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {\n        pasteRules.push(...addPasteRules());\n      }\n      const addProseMirrorPlugins = getExtensionField(extension, 'addProseMirrorPlugins', context);\n      if (addProseMirrorPlugins) {\n        const proseMirrorPlugins = addProseMirrorPlugins();\n        plugins.push(...proseMirrorPlugins);\n      }\n      return plugins;\n    }).flat();\n    return [inputRulesPlugin({\n      editor,\n      rules: inputRules\n    }), ...pasteRulesPlugin({\n      editor,\n      rules: pasteRules\n    }), ...allPlugins];\n  }\n  get attributes() {\n    return getAttributesFromExtensions(this.extensions);\n  }\n  get nodeViews() {\n    const {\n      editor\n    } = this;\n    const {\n      nodeExtensions\n    } = splitExtensions(this.extensions);\n    return Object.fromEntries(nodeExtensions.filter(extension => !!getExtensionField(extension, 'addNodeView')).map(extension => {\n      const extensionAttributes = this.attributes.filter(attribute => attribute.type === extension.name);\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor,\n        type: getNodeType(extension.name, this.schema)\n      };\n      const addNodeView = getExtensionField(extension, 'addNodeView', context);\n      if (!addNodeView) {\n        return [];\n      }\n      const nodeview = (node, view, getPos, decorations) => {\n        const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);\n        return addNodeView()({\n          editor,\n          node,\n          getPos,\n          decorations,\n          HTMLAttributes,\n          extension\n        });\n      };\n      return [extension.name, nodeview];\n    }));\n  }\n}\n\n// see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts\nfunction getType(value) {\n  return Object.prototype.toString.call(value).slice(8, -1);\n}\nfunction isPlainObject(value) {\n  if (getType(value) !== 'Object') {\n    return false;\n  }\n  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;\n}\nfunction mergeDeep(target, source) {\n  const output = {\n    ...target\n  };\n  if (isPlainObject(target) && isPlainObject(source)) {\n    Object.keys(source).forEach(key => {\n      if (isPlainObject(source[key])) {\n        if (!(key in target)) {\n          Object.assign(output, {\n            [key]: source[key]\n          });\n        } else {\n          output[key] = mergeDeep(target[key], source[key]);\n        }\n      } else {\n        Object.assign(output, {\n          [key]: source[key]\n        });\n      }\n    });\n  }\n  return output;\n}\nclass Extension {\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.type = 'extension';\n    this.name = 'extension';\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = {\n      ...this.config,\n      ...config\n    };\n    this.name = this.config.name;\n    if (config.defaultOptions) {\n      console.warn(\"[tiptap warn]: BREAKING CHANGE: \\\"defaultOptions\\\" is deprecated. Please use \\\"addOptions\\\" instead. Found in extension: \\\"\".concat(this.name, \"\\\".\"));\n    }\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions;\n    if (this.config.addOptions) {\n      this.options = callOrReturn(getExtensionField(this, 'addOptions', {\n        name: this.name\n      }));\n    }\n    this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\n      name: this.name,\n      options: this.options\n    })) || {};\n  }\n  static create() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new Extension(config);\n  }\n  configure() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend();\n    extension.options = mergeDeep(this.options, options);\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n  extend() {\n    let extendedConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const extension = new Extension(extendedConfig);\n    extension.parent = this;\n    this.child = extension;\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n    if (extendedConfig.defaultOptions) {\n      console.warn(\"[tiptap warn]: BREAKING CHANGE: \\\"defaultOptions\\\" is deprecated. Please use \\\"addOptions\\\" instead. Found in extension: \\\"\".concat(extension.name, \"\\\".\"));\n    }\n    extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\n      name: extension.name\n    }));\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n}\nfunction getTextBetween(startNode, range, options) {\n  const {\n    from,\n    to\n  } = range;\n  const {\n    blockSeparator = '\\n\\n',\n    textSerializers = {}\n  } = options || {};\n  let text = '';\n  let separated = true;\n  startNode.nodesBetween(from, to, (node, pos, parent, index) => {\n    var _a;\n    const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];\n    if (textSerializer) {\n      if (node.isBlock && !separated) {\n        text += blockSeparator;\n        separated = true;\n      }\n      if (parent) {\n        text += textSerializer({\n          node,\n          pos,\n          parent,\n          index,\n          range\n        });\n      }\n    } else if (node.isText) {\n      text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from, pos) - pos, to - pos); // eslint-disable-line\n      separated = false;\n    } else if (node.isBlock && !separated) {\n      text += blockSeparator;\n      separated = true;\n    }\n  });\n  return text;\n}\nfunction getTextSerializersFromSchema(schema) {\n  return Object.fromEntries(Object.entries(schema.nodes).filter(_ref10 => {\n    let [, node] = _ref10;\n    return node.spec.toText;\n  }).map(_ref11 => {\n    let [name, node] = _ref11;\n    return [name, node.spec.toText];\n  }));\n}\nconst ClipboardTextSerializer = Extension.create({\n  name: 'clipboardTextSerializer',\n  addProseMirrorPlugins() {\n    return [new Plugin({\n      key: new PluginKey('clipboardTextSerializer'),\n      props: {\n        clipboardTextSerializer: () => {\n          const {\n            editor\n          } = this;\n          const {\n            state,\n            schema\n          } = editor;\n          const {\n            doc,\n            selection\n          } = state;\n          const {\n            ranges\n          } = selection;\n          const from = Math.min(...ranges.map(range => range.$from.pos));\n          const to = Math.max(...ranges.map(range => range.$to.pos));\n          const textSerializers = getTextSerializersFromSchema(schema);\n          const range = {\n            from,\n            to\n          };\n          return getTextBetween(doc, range, {\n            textSerializers\n          });\n        }\n      }\n    })];\n  }\n});\nconst blur = () => _ref12 => {\n  let {\n    editor,\n    view\n  } = _ref12;\n  requestAnimationFrame(() => {\n    var _a;\n    if (!editor.isDestroyed) {\n      view.dom.blur();\n      // Browsers should remove the caret on blur but safari does not.\n      // See: https://github.com/ueberdosis/tiptap/issues/2405\n      (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();\n    }\n  });\n  return true;\n};\nconst clearContent = function () {\n  let emitUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return _ref13 => {\n    let {\n      commands\n    } = _ref13;\n    return commands.setContent('', emitUpdate);\n  };\n};\nconst clearNodes = () => _ref14 => {\n  let {\n    state,\n    tr,\n    dispatch\n  } = _ref14;\n  const {\n    selection\n  } = tr;\n  const {\n    ranges\n  } = selection;\n  if (!dispatch) {\n    return true;\n  }\n  ranges.forEach(_ref15 => {\n    let {\n      $from,\n      $to\n    } = _ref15;\n    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n      if (node.type.isText) {\n        return;\n      }\n      const {\n        doc,\n        mapping\n      } = tr;\n      const $mappedFrom = doc.resolve(mapping.map(pos));\n      const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize));\n      const nodeRange = $mappedFrom.blockRange($mappedTo);\n      if (!nodeRange) {\n        return;\n      }\n      const targetLiftDepth = liftTarget(nodeRange);\n      if (node.type.isTextblock) {\n        const {\n          defaultType\n        } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());\n        tr.setNodeMarkup(nodeRange.start, defaultType);\n      }\n      if (targetLiftDepth || targetLiftDepth === 0) {\n        tr.lift(nodeRange, targetLiftDepth);\n      }\n    });\n  });\n  return true;\n};\nconst command = fn => props => {\n  return fn(props);\n};\nconst createParagraphNear = () => _ref16 => {\n  let {\n    state,\n    dispatch\n  } = _ref16;\n  return createParagraphNear$1(state, dispatch);\n};\nconst cut = (originRange, targetPos) => _ref17 => {\n  let {\n    editor,\n    tr\n  } = _ref17;\n  const {\n    state\n  } = editor;\n  const contentSlice = state.doc.slice(originRange.from, originRange.to);\n  tr.deleteRange(originRange.from, originRange.to);\n  const newPos = tr.mapping.map(targetPos);\n  tr.insert(newPos, contentSlice.content);\n  tr.setSelection(new TextSelection(tr.doc.resolve(newPos - 1)));\n  return true;\n};\nconst deleteCurrentNode = () => _ref18 => {\n  let {\n    tr,\n    dispatch\n  } = _ref18;\n  const {\n    selection\n  } = tr;\n  const currentNode = selection.$anchor.node();\n  // if there is content inside the current node, break out of this command\n  if (currentNode.content.size > 0) {\n    return false;\n  }\n  const $pos = tr.selection.$anchor;\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth);\n    if (node.type === currentNode.type) {\n      if (dispatch) {\n        const from = $pos.before(depth);\n        const to = $pos.after(depth);\n        tr.delete(from, to).scrollIntoView();\n      }\n      return true;\n    }\n  }\n  return false;\n};\nconst deleteNode = typeOrName => _ref19 => {\n  let {\n    tr,\n    state,\n    dispatch\n  } = _ref19;\n  const type = getNodeType(typeOrName, state.schema);\n  const $pos = tr.selection.$anchor;\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth);\n    if (node.type === type) {\n      if (dispatch) {\n        const from = $pos.before(depth);\n        const to = $pos.after(depth);\n        tr.delete(from, to).scrollIntoView();\n      }\n      return true;\n    }\n  }\n  return false;\n};\nconst deleteRange = range => _ref20 => {\n  let {\n    tr,\n    dispatch\n  } = _ref20;\n  const {\n    from,\n    to\n  } = range;\n  if (dispatch) {\n    tr.delete(from, to);\n  }\n  return true;\n};\nconst deleteSelection = () => _ref21 => {\n  let {\n    state,\n    dispatch\n  } = _ref21;\n  return deleteSelection$1(state, dispatch);\n};\nconst enter = () => _ref22 => {\n  let {\n    commands\n  } = _ref22;\n  return commands.keyboardShortcut('Enter');\n};\nconst exitCode = () => _ref23 => {\n  let {\n    state,\n    dispatch\n  } = _ref23;\n  return exitCode$1(state, dispatch);\n};\n\n/**\r\n * Check if object1 includes object2\r\n * @param object1 Object\r\n * @param object2 Object\r\n */\nfunction objectIncludes(object1, object2) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    strict: true\n  };\n  const keys = Object.keys(object2);\n  if (!keys.length) {\n    return true;\n  }\n  return keys.every(key => {\n    if (options.strict) {\n      return object2[key] === object1[key];\n    }\n    if (isRegExp(object2[key])) {\n      return object2[key].test(object1[key]);\n    }\n    return object2[key] === object1[key];\n  });\n}\nfunction findMarkInSet(marks, type) {\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return marks.find(item => {\n    return item.type === type && objectIncludes(item.attrs, attributes);\n  });\n}\nfunction isMarkInSet(marks, type) {\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return !!findMarkInSet(marks, type, attributes);\n}\nfunction getMarkRange($pos, type) {\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!$pos || !type) {\n    return;\n  }\n  let start = $pos.parent.childAfter($pos.parentOffset);\n  if ($pos.parentOffset === start.offset && start.offset !== 0) {\n    start = $pos.parent.childBefore($pos.parentOffset);\n  }\n  if (!start.node) {\n    return;\n  }\n  const mark = findMarkInSet([...start.node.marks], type, attributes);\n  if (!mark) {\n    return;\n  }\n  let startIndex = start.index;\n  let startPos = $pos.start() + start.offset;\n  let endIndex = startIndex + 1;\n  let endPos = startPos + start.node.nodeSize;\n  findMarkInSet([...start.node.marks], type, attributes);\n  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {\n    startIndex -= 1;\n    startPos -= $pos.parent.child(startIndex).nodeSize;\n  }\n  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {\n    endPos += $pos.parent.child(endIndex).nodeSize;\n    endIndex += 1;\n  }\n  return {\n    from: startPos,\n    to: endPos\n  };\n}\nfunction getMarkType(nameOrType, schema) {\n  if (typeof nameOrType === 'string') {\n    if (!schema.marks[nameOrType]) {\n      throw Error(\"There is no mark type named '\".concat(nameOrType, \"'. Maybe you forgot to add the extension?\"));\n    }\n    return schema.marks[nameOrType];\n  }\n  return nameOrType;\n}\nconst extendMarkRange = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref24 => {\n    let {\n      tr,\n      state,\n      dispatch\n    } = _ref24;\n    const type = getMarkType(typeOrName, state.schema);\n    const {\n      doc,\n      selection\n    } = tr;\n    const {\n      $from,\n      from,\n      to\n    } = selection;\n    if (dispatch) {\n      const range = getMarkRange($from, type, attributes);\n      if (range && range.from <= from && range.to >= to) {\n        const newSelection = TextSelection.create(doc, range.from, range.to);\n        tr.setSelection(newSelection);\n      }\n    }\n    return true;\n  };\n};\nconst first = commands => props => {\n  const items = typeof commands === 'function' ? commands(props) : commands;\n  for (let i = 0; i < items.length; i += 1) {\n    if (items[i](props)) {\n      return true;\n    }\n  }\n  return false;\n};\nfunction isTextSelection(value) {\n  return value instanceof TextSelection;\n}\nfunction minMax() {\n  let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  let min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return Math.min(Math.max(value, min), max);\n}\nfunction resolveFocusPosition(doc) {\n  let position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (!position) {\n    return null;\n  }\n  const selectionAtStart = Selection.atStart(doc);\n  const selectionAtEnd = Selection.atEnd(doc);\n  if (position === 'start' || position === true) {\n    return selectionAtStart;\n  }\n  if (position === 'end') {\n    return selectionAtEnd;\n  }\n  const minPos = selectionAtStart.from;\n  const maxPos = selectionAtEnd.to;\n  if (position === 'all') {\n    return TextSelection.create(doc, minMax(0, minPos, maxPos), minMax(doc.content.size, minPos, maxPos));\n  }\n  return TextSelection.create(doc, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));\n}\nfunction isiOS() {\n  return ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].includes(navigator.platform)\n  // iPad on iOS 13 detection\n  || navigator.userAgent.includes('Mac') && 'ontouchend' in document;\n}\nconst focus = function () {\n  let position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref25 => {\n    let {\n      editor,\n      view,\n      tr,\n      dispatch\n    } = _ref25;\n    options = {\n      scrollIntoView: true,\n      ...options\n    };\n    const delayedFocus = () => {\n      // focus within `requestAnimationFrame` breaks focus on iOS\n      // so we have to call this\n      if (isiOS()) {\n        view.dom.focus();\n      }\n      // For React we have to focus asynchronously. Otherwise wild things happen.\n      // see: https://github.com/ueberdosis/tiptap/issues/1520\n      requestAnimationFrame(() => {\n        if (!editor.isDestroyed) {\n          view.focus();\n          if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {\n            editor.commands.scrollIntoView();\n          }\n        }\n      });\n    };\n    if (view.hasFocus() && position === null || position === false) {\n      return true;\n    }\n    // we don’t try to resolve a NodeSelection or CellSelection\n    if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\n      delayedFocus();\n      return true;\n    }\n    // pass through tr.doc instead of editor.state.doc\n    // since transactions could change the editors state before this command has been run\n    const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;\n    const isSameSelection = editor.state.selection.eq(selection);\n    if (dispatch) {\n      if (!isSameSelection) {\n        tr.setSelection(selection);\n      }\n      // `tr.setSelection` resets the stored marks\n      // so we’ll restore them if the selection is the same as before\n      if (isSameSelection && tr.storedMarks) {\n        tr.setStoredMarks(tr.storedMarks);\n      }\n      delayedFocus();\n    }\n    return true;\n  };\n};\nconst forEach = (items, fn) => props => {\n  return items.every((item, index) => fn(item, {\n    ...props,\n    index\n  }));\n};\nconst insertContent = (value, options) => _ref26 => {\n  let {\n    tr,\n    commands\n  } = _ref26;\n  return commands.insertContentAt({\n    from: tr.selection.from,\n    to: tr.selection.to\n  }, value, options);\n};\nfunction elementFromString(value) {\n  // add a wrapper to preserve leading and trailing whitespace\n  const wrappedValue = \"<body>\".concat(value, \"</body>\");\n  return new window.DOMParser().parseFromString(wrappedValue, 'text/html').body;\n}\nfunction createNodeFromContent(content, schema, options) {\n  options = {\n    slice: true,\n    parseOptions: {},\n    ...options\n  };\n  if (typeof content === 'object' && content !== null) {\n    try {\n      if (Array.isArray(content) && content.length > 0) {\n        return Fragment.fromArray(content.map(item => schema.nodeFromJSON(item)));\n      }\n      return schema.nodeFromJSON(content);\n    } catch (error) {\n      console.warn('[tiptap warn]: Invalid content.', 'Passed value:', content, 'Error:', error);\n      return createNodeFromContent('', schema, options);\n    }\n  }\n  if (typeof content === 'string') {\n    const parser = DOMParser.fromSchema(schema);\n    return options.slice ? parser.parseSlice(elementFromString(content), options.parseOptions).content : parser.parse(elementFromString(content), options.parseOptions);\n  }\n  return createNodeFromContent('', schema, options);\n}\n\n// source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  const last = tr.steps.length - 1;\n  if (last < startLen) {\n    return;\n  }\n  const step = tr.steps[last];\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {\n    return;\n  }\n  const map = tr.mapping.maps[last];\n  let end = 0;\n  map.forEach((_from, _to, _newFrom, newTo) => {\n    if (end === 0) {\n      end = newTo;\n    }\n  });\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n}\nconst isFragment = nodeOrFragment => {\n  return nodeOrFragment.toString().startsWith('<');\n};\nconst insertContentAt = (position, value, options) => _ref27 => {\n  let {\n    tr,\n    dispatch,\n    editor\n  } = _ref27;\n  if (dispatch) {\n    options = {\n      parseOptions: {},\n      updateSelection: true,\n      ...options\n    };\n    const content = createNodeFromContent(value, editor.schema, {\n      parseOptions: {\n        preserveWhitespace: 'full',\n        ...options.parseOptions\n      }\n    });\n    // don’t dispatch an empty fragment because this can lead to strange errors\n    if (content.toString() === '<>') {\n      return true;\n    }\n    let {\n      from,\n      to\n    } = typeof position === 'number' ? {\n      from: position,\n      to: position\n    } : {\n      from: position.from,\n      to: position.to\n    };\n    let isOnlyTextContent = true;\n    let isOnlyBlockContent = true;\n    const nodes = isFragment(content) ? content : [content];\n    nodes.forEach(node => {\n      // check if added node is valid\n      node.check();\n      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;\n      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;\n    });\n    // check if we can replace the wrapping node by\n    // the newly inserted content\n    // example:\n    // replace an empty paragraph by an inserted image\n    // instead of inserting the image below the paragraph\n    if (from === to && isOnlyBlockContent) {\n      const {\n        parent\n      } = tr.doc.resolve(from);\n      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;\n      if (isEmptyTextBlock) {\n        from -= 1;\n        to += 1;\n      }\n    }\n    // if there is only plain text we have to use `insertText`\n    // because this will keep the current marks\n    if (isOnlyTextContent) {\n      // if value is string, we can use it directly\n      // otherwise if it is an array, we have to join it\n      if (Array.isArray(value)) {\n        tr.insertText(value.map(v => v.text || '').join(''), from, to);\n      } else if (typeof value === 'object' && !!value && !!value.text) {\n        tr.insertText(value.text, from, to);\n      } else {\n        tr.insertText(value, from, to);\n      }\n    } else {\n      tr.replaceWith(from, to, content);\n    }\n    // set cursor at end of inserted content\n    if (options.updateSelection) {\n      selectionToInsertionEnd(tr, tr.steps.length - 1, -1);\n    }\n  }\n  return true;\n};\nconst joinUp = () => _ref28 => {\n  let {\n    state,\n    dispatch\n  } = _ref28;\n  return joinUp$1(state, dispatch);\n};\nconst joinDown = () => _ref29 => {\n  let {\n    state,\n    dispatch\n  } = _ref29;\n  return joinDown$1(state, dispatch);\n};\nconst joinBackward = () => _ref30 => {\n  let {\n    state,\n    dispatch\n  } = _ref30;\n  return joinBackward$1(state, dispatch);\n};\nconst joinForward = () => _ref31 => {\n  let {\n    state,\n    dispatch\n  } = _ref31;\n  return joinForward$1(state, dispatch);\n};\nconst joinItemBackward = () => _ref32 => {\n  let {\n    tr,\n    state,\n    dispatch\n  } = _ref32;\n  try {\n    const point = joinPoint(state.doc, state.selection.$from.pos, -1);\n    if (point === null || point === undefined) {\n      return false;\n    }\n    tr.join(point, 2);\n    if (dispatch) {\n      dispatch(tr);\n    }\n    return true;\n  } catch {\n    return false;\n  }\n};\nconst joinItemForward = () => _ref33 => {\n  let {\n    state,\n    dispatch,\n    tr\n  } = _ref33;\n  try {\n    const point = joinPoint(state.doc, state.selection.$from.pos, +1);\n    if (point === null || point === undefined) {\n      return false;\n    }\n    tr.join(point, 2);\n    if (dispatch) {\n      dispatch(tr);\n    }\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\nfunction isMacOS() {\n  return typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;\n}\nfunction normalizeKeyName(name) {\n  const parts = name.split(/-(?!$)/);\n  let result = parts[parts.length - 1];\n  if (result === 'Space') {\n    result = ' ';\n  }\n  let alt;\n  let ctrl;\n  let shift;\n  let meta;\n  for (let i = 0; i < parts.length - 1; i += 1) {\n    const mod = parts[i];\n    if (/^(cmd|meta|m)$/i.test(mod)) {\n      meta = true;\n    } else if (/^a(lt)?$/i.test(mod)) {\n      alt = true;\n    } else if (/^(c|ctrl|control)$/i.test(mod)) {\n      ctrl = true;\n    } else if (/^s(hift)?$/i.test(mod)) {\n      shift = true;\n    } else if (/^mod$/i.test(mod)) {\n      if (isiOS() || isMacOS()) {\n        meta = true;\n      } else {\n        ctrl = true;\n      }\n    } else {\n      throw new Error(\"Unrecognized modifier name: \".concat(mod));\n    }\n  }\n  if (alt) {\n    result = \"Alt-\".concat(result);\n  }\n  if (ctrl) {\n    result = \"Ctrl-\".concat(result);\n  }\n  if (meta) {\n    result = \"Meta-\".concat(result);\n  }\n  if (shift) {\n    result = \"Shift-\".concat(result);\n  }\n  return result;\n}\nconst keyboardShortcut = name => _ref34 => {\n  let {\n    editor,\n    view,\n    tr,\n    dispatch\n  } = _ref34;\n  const keys = normalizeKeyName(name).split(/-(?!$)/);\n  const key = keys.find(item => !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(item));\n  const event = new KeyboardEvent('keydown', {\n    key: key === 'Space' ? ' ' : key,\n    altKey: keys.includes('Alt'),\n    ctrlKey: keys.includes('Ctrl'),\n    metaKey: keys.includes('Meta'),\n    shiftKey: keys.includes('Shift'),\n    bubbles: true,\n    cancelable: true\n  });\n  const capturedTransaction = editor.captureTransaction(() => {\n    view.someProp('handleKeyDown', f => f(view, event));\n  });\n  capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach(step => {\n    const newStep = step.map(tr.mapping);\n    if (newStep && dispatch) {\n      tr.maybeStep(newStep);\n    }\n  });\n  return true;\n};\nfunction isNodeActive(state, typeOrName) {\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    from,\n    to,\n    empty\n  } = state.selection;\n  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;\n  const nodeRanges = [];\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isText) {\n      return;\n    }\n    const relativeFrom = Math.max(from, pos);\n    const relativeTo = Math.min(to, pos + node.nodeSize);\n    nodeRanges.push({\n      node,\n      from: relativeFrom,\n      to: relativeTo\n    });\n  });\n  const selectionRange = to - from;\n  const matchedNodeRanges = nodeRanges.filter(nodeRange => {\n    if (!type) {\n      return true;\n    }\n    return type.name === nodeRange.node.type.name;\n  }).filter(nodeRange => objectIncludes(nodeRange.node.attrs, attributes, {\n    strict: false\n  }));\n  if (empty) {\n    return !!matchedNodeRanges.length;\n  }\n  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);\n  return range >= selectionRange;\n}\nconst lift = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref35 => {\n    let {\n      state,\n      dispatch\n    } = _ref35;\n    const type = getNodeType(typeOrName, state.schema);\n    const isActive = isNodeActive(state, type, attributes);\n    if (!isActive) {\n      return false;\n    }\n    return lift$1(state, dispatch);\n  };\n};\nconst liftEmptyBlock = () => _ref36 => {\n  let {\n    state,\n    dispatch\n  } = _ref36;\n  return liftEmptyBlock$1(state, dispatch);\n};\nconst liftListItem = typeOrName => _ref37 => {\n  let {\n    state,\n    dispatch\n  } = _ref37;\n  const type = getNodeType(typeOrName, state.schema);\n  return liftListItem$1(type)(state, dispatch);\n};\nconst newlineInCode = () => _ref38 => {\n  let {\n    state,\n    dispatch\n  } = _ref38;\n  return newlineInCode$1(state, dispatch);\n};\nfunction getSchemaTypeNameByName(name, schema) {\n  if (schema.nodes[name]) {\n    return 'node';\n  }\n  if (schema.marks[name]) {\n    return 'mark';\n  }\n  return null;\n}\n\n/**\r\n * Remove a property or an array of properties from an object\r\n * @param obj Object\r\n * @param key Key to remove\r\n */\nfunction deleteProps(obj, propOrProps) {\n  const props = typeof propOrProps === 'string' ? [propOrProps] : propOrProps;\n  return Object.keys(obj).reduce((newObj, prop) => {\n    if (!props.includes(prop)) {\n      newObj[prop] = obj[prop];\n    }\n    return newObj;\n  }, {});\n}\nconst resetAttributes = (typeOrName, attributes) => _ref39 => {\n  let {\n    tr,\n    state,\n    dispatch\n  } = _ref39;\n  let nodeType = null;\n  let markType = null;\n  const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n  if (!schemaType) {\n    return false;\n  }\n  if (schemaType === 'node') {\n    nodeType = getNodeType(typeOrName, state.schema);\n  }\n  if (schemaType === 'mark') {\n    markType = getMarkType(typeOrName, state.schema);\n  }\n  if (dispatch) {\n    tr.selection.ranges.forEach(range => {\n      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes));\n        }\n        if (markType && node.marks.length) {\n          node.marks.forEach(mark => {\n            if (markType === mark.type) {\n              tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));\n            }\n          });\n        }\n      });\n    });\n  }\n  return true;\n};\nconst scrollIntoView = () => _ref40 => {\n  let {\n    tr,\n    dispatch\n  } = _ref40;\n  if (dispatch) {\n    tr.scrollIntoView();\n  }\n  return true;\n};\nconst selectAll = () => _ref41 => {\n  let {\n    tr,\n    commands\n  } = _ref41;\n  return commands.setTextSelection({\n    from: 0,\n    to: tr.doc.content.size\n  });\n};\nconst selectNodeBackward = () => _ref42 => {\n  let {\n    state,\n    dispatch\n  } = _ref42;\n  return selectNodeBackward$1(state, dispatch);\n};\nconst selectNodeForward = () => _ref43 => {\n  let {\n    state,\n    dispatch\n  } = _ref43;\n  return selectNodeForward$1(state, dispatch);\n};\nconst selectParentNode = () => _ref44 => {\n  let {\n    state,\n    dispatch\n  } = _ref44;\n  return selectParentNode$1(state, dispatch);\n};\n\n// @ts-ignore\nconst selectTextblockEnd = () => _ref45 => {\n  let {\n    state,\n    dispatch\n  } = _ref45;\n  return selectTextblockEnd$1(state, dispatch);\n};\n\n// @ts-ignore\nconst selectTextblockStart = () => _ref46 => {\n  let {\n    state,\n    dispatch\n  } = _ref46;\n  return selectTextblockStart$1(state, dispatch);\n};\nfunction createDocument(content, schema) {\n  let parseOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return createNodeFromContent(content, schema, {\n    slice: false,\n    parseOptions\n  });\n}\nconst setContent = function (content) {\n  let emitUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let parseOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return _ref47 => {\n    let {\n      tr,\n      editor,\n      dispatch\n    } = _ref47;\n    const {\n      doc\n    } = tr;\n    const document = createDocument(content, editor.schema, parseOptions);\n    if (dispatch) {\n      tr.replaceWith(0, doc.content.size, document).setMeta('preventUpdate', !emitUpdate);\n    }\n    return true;\n  };\n};\nfunction getMarkAttributes(state, typeOrName) {\n  const type = getMarkType(typeOrName, state.schema);\n  const {\n    from,\n    to,\n    empty\n  } = state.selection;\n  const marks = [];\n  if (empty) {\n    if (state.storedMarks) {\n      marks.push(...state.storedMarks);\n    }\n    marks.push(...state.selection.$head.marks());\n  } else {\n    state.doc.nodesBetween(from, to, node => {\n      marks.push(...node.marks);\n    });\n  }\n  const mark = marks.find(markItem => markItem.type.name === type.name);\n  if (!mark) {\n    return {};\n  }\n  return {\n    ...mark.attrs\n  };\n}\n\n/**\r\n * Returns a new `Transform` based on all steps of the passed transactions.\r\n */\nfunction combineTransactionSteps(oldDoc, transactions) {\n  const transform = new Transform(oldDoc);\n  transactions.forEach(transaction => {\n    transaction.steps.forEach(step => {\n      transform.step(step);\n    });\n  });\n  return transform;\n}\nfunction defaultBlockAt(match) {\n  for (let i = 0; i < match.edgeCount; i += 1) {\n    const {\n      type\n    } = match.edge(i);\n    if (type.isTextblock && !type.hasRequiredAttrs()) {\n      return type;\n    }\n  }\n  return null;\n}\nfunction findChildren(node, predicate) {\n  const nodesWithPos = [];\n  node.descendants((child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos\n      });\n    }\n  });\n  return nodesWithPos;\n}\n\n/**\r\n * Same as `findChildren` but searches only within a `range`.\r\n */\nfunction findChildrenInRange(node, range, predicate) {\n  const nodesWithPos = [];\n  // if (range.from === range.to) {\n  //   const nodeAt = node.nodeAt(range.from)\n  //   if (nodeAt) {\n  //     nodesWithPos.push({\n  //       node: nodeAt,\n  //       pos: range.from,\n  //     })\n  //   }\n  // }\n  node.nodesBetween(range.from, range.to, (child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos\n      });\n    }\n  });\n  return nodesWithPos;\n}\nfunction findParentNodeClosestToPos($pos, predicate) {\n  for (let i = $pos.depth; i > 0; i -= 1) {\n    const node = $pos.node(i);\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node\n      };\n    }\n  }\n}\nfunction findParentNode(predicate) {\n  return selection => findParentNodeClosestToPos(selection.$from, predicate);\n}\nfunction getHTMLFromFragment(fragment, schema) {\n  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);\n  const temporaryDocument = document.implementation.createHTMLDocument();\n  const container = temporaryDocument.createElement('div');\n  container.appendChild(documentFragment);\n  return container.innerHTML;\n}\nfunction getSchema(extensions, editor) {\n  const resolvedExtensions = ExtensionManager.resolve(extensions);\n  return getSchemaByResolvedExtensions(resolvedExtensions, editor);\n}\nfunction generateHTML(doc, extensions) {\n  const schema = getSchema(extensions);\n  const contentNode = Node$1.fromJSON(schema, doc);\n  return getHTMLFromFragment(contentNode.content, schema);\n}\nfunction generateJSON(html, extensions) {\n  const schema = getSchema(extensions);\n  const dom = elementFromString(html);\n  return DOMParser.fromSchema(schema).parse(dom).toJSON();\n}\nfunction getText(node, options) {\n  const range = {\n    from: 0,\n    to: node.content.size\n  };\n  return getTextBetween(node, range, options);\n}\nfunction generateText(doc, extensions, options) {\n  const {\n    blockSeparator = '\\n\\n',\n    textSerializers = {}\n  } = options || {};\n  const schema = getSchema(extensions);\n  const contentNode = Node$1.fromJSON(schema, doc);\n  return getText(contentNode, {\n    blockSeparator,\n    textSerializers: {\n      ...getTextSerializersFromSchema(schema),\n      ...textSerializers\n    }\n  });\n}\nfunction getNodeAttributes(state, typeOrName) {\n  const type = getNodeType(typeOrName, state.schema);\n  const {\n    from,\n    to\n  } = state.selection;\n  const nodes = [];\n  state.doc.nodesBetween(from, to, node => {\n    nodes.push(node);\n  });\n  const node = nodes.reverse().find(nodeItem => nodeItem.type.name === type.name);\n  if (!node) {\n    return {};\n  }\n  return {\n    ...node.attrs\n  };\n}\nfunction getAttributes(state, typeOrName) {\n  const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n  if (schemaType === 'node') {\n    return getNodeAttributes(state, typeOrName);\n  }\n  if (schemaType === 'mark') {\n    return getMarkAttributes(state, typeOrName);\n  }\n  return {};\n}\n\n/**\r\n * Removes duplicated values within an array.\r\n * Supports numbers, strings and objects.\r\n */\nfunction removeDuplicates(array) {\n  let by = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : JSON.stringify;\n  const seen = {};\n  return array.filter(item => {\n    const key = by(item);\n    return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;\n  });\n}\n\n/**\r\n * Removes duplicated ranges and ranges that are\r\n * fully captured by other ranges.\r\n */\nfunction simplifyChangedRanges(changes) {\n  const uniqueChanges = removeDuplicates(changes);\n  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index) => {\n    const rest = uniqueChanges.filter((_, i) => i !== index);\n    return !rest.some(otherChange => {\n      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;\n    });\n  });\n}\n/**\r\n * Returns a list of changed ranges\r\n * based on the first and last state of all steps.\r\n */\nfunction getChangedRanges(transform) {\n  const {\n    mapping,\n    steps\n  } = transform;\n  const changes = [];\n  mapping.maps.forEach((stepMap, index) => {\n    const ranges = [];\n    // This accounts for step changes where no range was actually altered\n    // e.g. when setting a mark, node attribute, etc.\n    // @ts-ignore\n    if (!stepMap.ranges.length) {\n      const {\n        from,\n        to\n      } = steps[index];\n      if (from === undefined || to === undefined) {\n        return;\n      }\n      ranges.push({\n        from,\n        to\n      });\n    } else {\n      stepMap.forEach((from, to) => {\n        ranges.push({\n          from,\n          to\n        });\n      });\n    }\n    ranges.forEach(_ref48 => {\n      let {\n        from,\n        to\n      } = _ref48;\n      const newStart = mapping.slice(index).map(from, -1);\n      const newEnd = mapping.slice(index).map(to);\n      const oldStart = mapping.invert().map(newStart, -1);\n      const oldEnd = mapping.invert().map(newEnd);\n      changes.push({\n        oldRange: {\n          from: oldStart,\n          to: oldEnd\n        },\n        newRange: {\n          from: newStart,\n          to: newEnd\n        }\n      });\n    });\n  });\n  return simplifyChangedRanges(changes);\n}\nfunction getDebugJSON(node) {\n  let startOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const isTopNode = node.type === node.type.schema.topNodeType;\n  const increment = isTopNode ? 0 : 1;\n  const from = startOffset;\n  const to = from + node.nodeSize;\n  const marks = node.marks.map(mark => {\n    const output = {\n      type: mark.type.name\n    };\n    if (Object.keys(mark.attrs).length) {\n      output.attrs = {\n        ...mark.attrs\n      };\n    }\n    return output;\n  });\n  const attrs = {\n    ...node.attrs\n  };\n  const output = {\n    type: node.type.name,\n    from,\n    to\n  };\n  if (Object.keys(attrs).length) {\n    output.attrs = attrs;\n  }\n  if (marks.length) {\n    output.marks = marks;\n  }\n  if (node.content.childCount) {\n    output.content = [];\n    node.forEach((child, offset) => {\n      var _a;\n      (_a = output.content) === null || _a === void 0 ? void 0 : _a.push(getDebugJSON(child, startOffset + offset + increment));\n    });\n  }\n  if (node.text) {\n    output.text = node.text;\n  }\n  return output;\n}\nfunction getMarksBetween(from, to, doc) {\n  const marks = [];\n  // get all inclusive marks on empty selection\n  if (from === to) {\n    doc.resolve(from).marks().forEach(mark => {\n      const $pos = doc.resolve(from - 1);\n      const range = getMarkRange($pos, mark.type);\n      if (!range) {\n        return;\n      }\n      marks.push({\n        mark,\n        ...range\n      });\n    });\n  } else {\n    doc.nodesBetween(from, to, (node, pos) => {\n      marks.push(...node.marks.map(mark => ({\n        from: pos,\n        to: pos + node.nodeSize,\n        mark\n      })));\n    });\n  }\n  return marks;\n}\n\n/**\r\n * Finds the first node of a given type or name in the current selection.\r\n * @param state The editor state.\r\n * @param typeOrName The node type or name.\r\n * @param pos The position to start searching from.\r\n * @param maxDepth The maximum depth to search.\r\n * @returns The node and the depth as an array.\r\n */\nconst getNodeAtPosition = function (state, typeOrName, pos) {\n  let maxDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 20;\n  const $pos = state.doc.resolve(pos);\n  let currentDepth = maxDepth;\n  let node = null;\n  while (currentDepth > 0 && node === null) {\n    const currentNode = $pos.node(currentDepth);\n    if ((currentNode === null || currentNode === void 0 ? void 0 : currentNode.type.name) === typeOrName) {\n      node = currentNode;\n    } else {\n      currentDepth -= 1;\n    }\n  }\n  return [node, currentDepth];\n};\nfunction getSplittedAttributes(extensionAttributes, typeName, attributes) {\n  return Object.fromEntries(Object.entries(attributes).filter(_ref49 => {\n    let [name] = _ref49;\n    const extensionAttribute = extensionAttributes.find(item => {\n      return item.type === typeName && item.name === name;\n    });\n    if (!extensionAttribute) {\n      return false;\n    }\n    return extensionAttribute.attribute.keepOnSplit;\n  }));\n}\nfunction isMarkActive(state, typeOrName) {\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    empty,\n    ranges\n  } = state.selection;\n  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;\n  if (empty) {\n    return !!(state.storedMarks || state.selection.$from.marks()).filter(mark => {\n      if (!type) {\n        return true;\n      }\n      return type.name === mark.type.name;\n    }).find(mark => objectIncludes(mark.attrs, attributes, {\n      strict: false\n    }));\n  }\n  let selectionRange = 0;\n  const markRanges = [];\n  ranges.forEach(_ref50 => {\n    let {\n      $from,\n      $to\n    } = _ref50;\n    const from = $from.pos;\n    const to = $to.pos;\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (!node.isText && !node.marks.length) {\n        return;\n      }\n      const relativeFrom = Math.max(from, pos);\n      const relativeTo = Math.min(to, pos + node.nodeSize);\n      const range = relativeTo - relativeFrom;\n      selectionRange += range;\n      markRanges.push(...node.marks.map(mark => ({\n        mark,\n        from: relativeFrom,\n        to: relativeTo\n      })));\n    });\n  });\n  if (selectionRange === 0) {\n    return false;\n  }\n  // calculate range of matched mark\n  const matchedRange = markRanges.filter(markRange => {\n    if (!type) {\n      return true;\n    }\n    return type.name === markRange.mark.type.name;\n  }).filter(markRange => objectIncludes(markRange.mark.attrs, attributes, {\n    strict: false\n  })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);\n  // calculate range of marks that excludes the searched mark\n  // for example `code` doesn’t allow any other marks\n  const excludedRange = markRanges.filter(markRange => {\n    if (!type) {\n      return true;\n    }\n    return markRange.mark.type !== type && markRange.mark.type.excludes(type);\n  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);\n  // we only include the result of `excludedRange`\n  // if there is a match at all\n  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;\n  return range >= selectionRange;\n}\nfunction isActive(state, name) {\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!name) {\n    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);\n  }\n  const schemaType = getSchemaTypeNameByName(name, state.schema);\n  if (schemaType === 'node') {\n    return isNodeActive(state, name, attributes);\n  }\n  if (schemaType === 'mark') {\n    return isMarkActive(state, name, attributes);\n  }\n  return false;\n}\nconst isAtEndOfNode = (state, nodeType) => {\n  const {\n    $from,\n    $to,\n    $anchor\n  } = state.selection;\n  if (nodeType) {\n    const parentNode = findParentNode(node => node.type.name === nodeType)(state.selection);\n    if (!parentNode) {\n      return false;\n    }\n    const $parentPos = state.doc.resolve(parentNode.pos + 1);\n    if ($anchor.pos + 1 === $parentPos.end()) {\n      return true;\n    }\n    return false;\n  }\n  if ($to.parentOffset < $to.parent.nodeSize - 2 || $from.pos !== $to.pos) {\n    return false;\n  }\n  return true;\n};\nconst isAtStartOfNode = state => {\n  const {\n    $from,\n    $to\n  } = state.selection;\n  if ($from.parentOffset > 0 || $from.pos !== $to.pos) {\n    return false;\n  }\n  return true;\n};\nfunction isList(name, extensions) {\n  const {\n    nodeExtensions\n  } = splitExtensions(extensions);\n  const extension = nodeExtensions.find(item => item.name === name);\n  if (!extension) {\n    return false;\n  }\n  const context = {\n    name: extension.name,\n    options: extension.options,\n    storage: extension.storage\n  };\n  const group = callOrReturn(getExtensionField(extension, 'group', context));\n  if (typeof group !== 'string') {\n    return false;\n  }\n  return group.split(' ').includes('list');\n}\nfunction isNodeEmpty(node) {\n  var _a;\n  const defaultContent = (_a = node.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();\n  const content = node.toJSON();\n  return JSON.stringify(defaultContent) === JSON.stringify(content);\n}\nfunction isNodeSelection(value) {\n  return value instanceof NodeSelection;\n}\nfunction posToDOMRect(view, from, to) {\n  const minPos = 0;\n  const maxPos = view.state.doc.content.size;\n  const resolvedFrom = minMax(from, minPos, maxPos);\n  const resolvedEnd = minMax(to, minPos, maxPos);\n  const start = view.coordsAtPos(resolvedFrom);\n  const end = view.coordsAtPos(resolvedEnd, -1);\n  const top = Math.min(start.top, end.top);\n  const bottom = Math.max(start.bottom, end.bottom);\n  const left = Math.min(start.left, end.left);\n  const right = Math.max(start.right, end.right);\n  const width = right - left;\n  const height = bottom - top;\n  const x = left;\n  const y = top;\n  const data = {\n    top,\n    bottom,\n    left,\n    right,\n    width,\n    height,\n    x,\n    y\n  };\n  return {\n    ...data,\n    toJSON: () => data\n  };\n}\nfunction canSetMark(state, tr, newMarkType) {\n  var _a;\n  const {\n    selection\n  } = tr;\n  let cursor = null;\n  if (isTextSelection(selection)) {\n    cursor = selection.$cursor;\n  }\n  if (cursor) {\n    const currentMarks = (_a = state.storedMarks) !== null && _a !== void 0 ? _a : cursor.marks();\n    // There can be no current marks that exclude the new mark\n    return !!newMarkType.isInSet(currentMarks) || !currentMarks.some(mark => mark.type.excludes(newMarkType));\n  }\n  const {\n    ranges\n  } = selection;\n  return ranges.some(_ref51 => {\n    let {\n      $from,\n      $to\n    } = _ref51;\n    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;\n    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {\n      // If we already found a mark that we can enable, return false to bypass the remaining search\n      if (someNodeSupportsMark) {\n        return false;\n      }\n      if (node.isInline) {\n        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);\n        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some(otherMark => otherMark.type.excludes(newMarkType));\n        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;\n      }\n      return !someNodeSupportsMark;\n    });\n    return someNodeSupportsMark;\n  });\n}\nconst setMark = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref52 => {\n    let {\n      tr,\n      state,\n      dispatch\n    } = _ref52;\n    const {\n      selection\n    } = tr;\n    const {\n      empty,\n      ranges\n    } = selection;\n    const type = getMarkType(typeOrName, state.schema);\n    if (dispatch) {\n      if (empty) {\n        const oldAttributes = getMarkAttributes(state, type);\n        tr.addStoredMark(type.create({\n          ...oldAttributes,\n          ...attributes\n        }));\n      } else {\n        ranges.forEach(range => {\n          const from = range.$from.pos;\n          const to = range.$to.pos;\n          state.doc.nodesBetween(from, to, (node, pos) => {\n            const trimmedFrom = Math.max(pos, from);\n            const trimmedTo = Math.min(pos + node.nodeSize, to);\n            const someHasMark = node.marks.find(mark => mark.type === type);\n            // if there is already a mark of this type\n            // we know that we have to merge its attributes\n            // otherwise we add a fresh new mark\n            if (someHasMark) {\n              node.marks.forEach(mark => {\n                if (type === mark.type) {\n                  tr.addMark(trimmedFrom, trimmedTo, type.create({\n                    ...mark.attrs,\n                    ...attributes\n                  }));\n                }\n              });\n            } else {\n              tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));\n            }\n          });\n        });\n      }\n    }\n    return canSetMark(state, tr, type);\n  };\n};\nconst setMeta = (key, value) => _ref53 => {\n  let {\n    tr\n  } = _ref53;\n  tr.setMeta(key, value);\n  return true;\n};\nconst setNode = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref54 => {\n    let {\n      state,\n      dispatch,\n      chain\n    } = _ref54;\n    const type = getNodeType(typeOrName, state.schema);\n    // TODO: use a fallback like insertContent?\n    if (!type.isTextblock) {\n      console.warn('[tiptap warn]: Currently \"setNode()\" only supports text block nodes.');\n      return false;\n    }\n    return chain()\n    // try to convert node to default node if needed\n    .command(_ref55 => {\n      let {\n        commands\n      } = _ref55;\n      const canSetBlock = setBlockType(type, attributes)(state);\n      if (canSetBlock) {\n        return true;\n      }\n      return commands.clearNodes();\n    }).command(_ref56 => {\n      let {\n        state: updatedState\n      } = _ref56;\n      return setBlockType(type, attributes)(updatedState, dispatch);\n    }).run();\n  };\n};\nconst setNodeSelection = position => _ref57 => {\n  let {\n    tr,\n    dispatch\n  } = _ref57;\n  if (dispatch) {\n    const {\n      doc\n    } = tr;\n    const from = minMax(position, 0, doc.content.size);\n    const selection = NodeSelection.create(doc, from);\n    tr.setSelection(selection);\n  }\n  return true;\n};\nconst setTextSelection = position => _ref58 => {\n  let {\n    tr,\n    dispatch\n  } = _ref58;\n  if (dispatch) {\n    const {\n      doc\n    } = tr;\n    const {\n      from,\n      to\n    } = typeof position === 'number' ? {\n      from: position,\n      to: position\n    } : position;\n    const minPos = TextSelection.atStart(doc).from;\n    const maxPos = TextSelection.atEnd(doc).to;\n    const resolvedFrom = minMax(from, minPos, maxPos);\n    const resolvedEnd = minMax(to, minPos, maxPos);\n    const selection = TextSelection.create(doc, resolvedFrom, resolvedEnd);\n    tr.setSelection(selection);\n  }\n  return true;\n};\nconst sinkListItem = typeOrName => _ref59 => {\n  let {\n    state,\n    dispatch\n  } = _ref59;\n  const type = getNodeType(typeOrName, state.schema);\n  return sinkListItem$1(type)(state, dispatch);\n};\nfunction ensureMarks(state, splittableMarks) {\n  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n  if (marks) {\n    const filteredMarks = marks.filter(mark => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));\n    state.tr.ensureMarks(filteredMarks);\n  }\n}\nconst splitBlock = function () {\n  let {\n    keepMarks = true\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return _ref60 => {\n    let {\n      tr,\n      state,\n      dispatch,\n      editor\n    } = _ref60;\n    const {\n      selection,\n      doc\n    } = tr;\n    const {\n      $from,\n      $to\n    } = selection;\n    const extensionAttributes = editor.extensionManager.attributes;\n    const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n    if (selection instanceof NodeSelection && selection.node.isBlock) {\n      if (!$from.parentOffset || !canSplit(doc, $from.pos)) {\n        return false;\n      }\n      if (dispatch) {\n        if (keepMarks) {\n          ensureMarks(state, editor.extensionManager.splittableMarks);\n        }\n        tr.split($from.pos).scrollIntoView();\n      }\n      return true;\n    }\n    if (!$from.parent.isBlock) {\n      return false;\n    }\n    if (dispatch) {\n      const atEnd = $to.parentOffset === $to.parent.content.size;\n      if (selection instanceof TextSelection) {\n        tr.deleteSelection();\n      }\n      const deflt = $from.depth === 0 ? undefined : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n      let types = atEnd && deflt ? [{\n        type: deflt,\n        attrs: newAttributes\n      }] : undefined;\n      let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);\n      if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{\n        type: deflt\n      }] : undefined)) {\n        can = true;\n        types = deflt ? [{\n          type: deflt,\n          attrs: newAttributes\n        }] : undefined;\n      }\n      if (can) {\n        tr.split(tr.mapping.map($from.pos), 1, types);\n        if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {\n          const first = tr.mapping.map($from.before());\n          const $first = tr.doc.resolve(first);\n          if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {\n            tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n          }\n        }\n      }\n      if (keepMarks) {\n        ensureMarks(state, editor.extensionManager.splittableMarks);\n      }\n      tr.scrollIntoView();\n    }\n    return true;\n  };\n};\nconst splitListItem = typeOrName => _ref61 => {\n  let {\n    tr,\n    state,\n    dispatch,\n    editor\n  } = _ref61;\n  var _a;\n  const type = getNodeType(typeOrName, state.schema);\n  const {\n    $from,\n    $to\n  } = state.selection;\n  // @ts-ignore\n  // eslint-disable-next-line\n  const node = state.selection.node;\n  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {\n    return false;\n  }\n  const grandParent = $from.node(-1);\n  if (grandParent.type !== type) {\n    return false;\n  }\n  const extensionAttributes = editor.extensionManager.attributes;\n  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n    // In an empty block. If this is a nested list, the wrapping\n    // list item should be split. Otherwise, bail out and let next\n    // command handle lifting.\n    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {\n      return false;\n    }\n    if (dispatch) {\n      let wrap = Fragment.empty;\n      // eslint-disable-next-line\n      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n      // Build a fragment containing empty versions of the structure\n      // from the outer list item to the parent node of the cursor\n      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {\n        wrap = Fragment.from($from.node(d).copy(wrap));\n      }\n      // eslint-disable-next-line\n      const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n      // Add a second list item with an empty default start node\n      const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n      const nextType = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes)) || undefined;\n      wrap = wrap.append(Fragment.from(type.createAndFill(null, nextType) || undefined));\n      const start = $from.before($from.depth - (depthBefore - 1));\n      tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0));\n      let sel = -1;\n      tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {\n        if (sel > -1) {\n          return false;\n        }\n        if (n.isTextblock && n.content.size === 0) {\n          sel = pos + 1;\n        }\n      });\n      if (sel > -1) {\n        tr.setSelection(TextSelection.near(tr.doc.resolve(sel)));\n      }\n      tr.scrollIntoView();\n    }\n    return true;\n  }\n  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n  const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);\n  const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n  tr.delete($from.pos, $to.pos);\n  const types = nextType ? [{\n    type,\n    attrs: newTypeAttributes\n  }, {\n    type: nextType,\n    attrs: newNextTypeAttributes\n  }] : [{\n    type,\n    attrs: newTypeAttributes\n  }];\n  if (!canSplit(tr.doc, $from.pos, 2)) {\n    return false;\n  }\n  if (dispatch) {\n    const {\n      selection,\n      storedMarks\n    } = state;\n    const {\n      splittableMarks\n    } = editor.extensionManager;\n    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n    tr.split($from.pos, 2, types).scrollIntoView();\n    if (!marks || !dispatch) {\n      return true;\n    }\n    const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name));\n    tr.ensureMarks(filteredMarks);\n  }\n  return true;\n};\nconst joinListBackwards = (tr, listType) => {\n  const list = findParentNode(node => node.type === listType)(tr.selection);\n  if (!list) {\n    return true;\n  }\n  const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);\n  if (before === undefined) {\n    return true;\n  }\n  const nodeBefore = tr.doc.nodeAt(before);\n  const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr.doc, list.pos);\n  if (!canJoinBackwards) {\n    return true;\n  }\n  tr.join(list.pos);\n  return true;\n};\nconst joinListForwards = (tr, listType) => {\n  const list = findParentNode(node => node.type === listType)(tr.selection);\n  if (!list) {\n    return true;\n  }\n  const after = tr.doc.resolve(list.start).after(list.depth);\n  if (after === undefined) {\n    return true;\n  }\n  const nodeAfter = tr.doc.nodeAt(after);\n  const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr.doc, after);\n  if (!canJoinForwards) {\n    return true;\n  }\n  tr.join(after);\n  return true;\n};\nconst toggleList = function (listTypeOrName, itemTypeOrName, keepMarks) {\n  let attributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return _ref62 => {\n    let {\n      editor,\n      tr,\n      state,\n      dispatch,\n      chain,\n      commands,\n      can\n    } = _ref62;\n    const {\n      extensions,\n      splittableMarks\n    } = editor.extensionManager;\n    const listType = getNodeType(listTypeOrName, state.schema);\n    const itemType = getNodeType(itemTypeOrName, state.schema);\n    const {\n      selection,\n      storedMarks\n    } = state;\n    const {\n      $from,\n      $to\n    } = selection;\n    const range = $from.blockRange($to);\n    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n    if (!range) {\n      return false;\n    }\n    const parentList = findParentNode(node => isList(node.type.name, extensions))(selection);\n    if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n      // remove list\n      if (parentList.node.type === listType) {\n        return commands.liftListItem(itemType);\n      }\n      // change list type\n      if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {\n        return chain().command(() => {\n          tr.setNodeMarkup(parentList.pos, listType);\n          return true;\n        }).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();\n      }\n    }\n    if (!keepMarks || !marks || !dispatch) {\n      return chain()\n      // try to convert node to default node if needed\n      .command(() => {\n        const canWrapInList = can().wrapInList(listType, attributes);\n        if (canWrapInList) {\n          return true;\n        }\n        return commands.clearNodes();\n      }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();\n    }\n    return chain()\n    // try to convert node to default node if needed\n    .command(() => {\n      const canWrapInList = can().wrapInList(listType, attributes);\n      const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name));\n      tr.ensureMarks(filteredMarks);\n      if (canWrapInList) {\n        return true;\n      }\n      return commands.clearNodes();\n    }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();\n  };\n};\nconst toggleMark = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return _ref63 => {\n    let {\n      state,\n      commands\n    } = _ref63;\n    const {\n      extendEmptyMarkRange = false\n    } = options;\n    const type = getMarkType(typeOrName, state.schema);\n    const isActive = isMarkActive(state, type, attributes);\n    if (isActive) {\n      return commands.unsetMark(type, {\n        extendEmptyMarkRange\n      });\n    }\n    return commands.setMark(type, attributes);\n  };\n};\nconst toggleNode = function (typeOrName, toggleTypeOrName) {\n  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return _ref64 => {\n    let {\n      state,\n      commands\n    } = _ref64;\n    const type = getNodeType(typeOrName, state.schema);\n    const toggleType = getNodeType(toggleTypeOrName, state.schema);\n    const isActive = isNodeActive(state, type, attributes);\n    if (isActive) {\n      return commands.setNode(toggleType);\n    }\n    return commands.setNode(type, attributes);\n  };\n};\nconst toggleWrap = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref65 => {\n    let {\n      state,\n      commands\n    } = _ref65;\n    const type = getNodeType(typeOrName, state.schema);\n    const isActive = isNodeActive(state, type, attributes);\n    if (isActive) {\n      return commands.lift(type);\n    }\n    return commands.wrapIn(type, attributes);\n  };\n};\nconst undoInputRule = () => _ref66 => {\n  let {\n    state,\n    dispatch\n  } = _ref66;\n  const plugins = state.plugins;\n  for (let i = 0; i < plugins.length; i += 1) {\n    const plugin = plugins[i];\n    let undoable;\n    // @ts-ignore\n    // eslint-disable-next-line\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        const tr = state.tr;\n        const toUndo = undoable.transform;\n        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {\n          tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n        }\n        if (undoable.text) {\n          const marks = tr.doc.resolve(undoable.from).marks();\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n        } else {\n          tr.delete(undoable.from, undoable.to);\n        }\n      }\n      return true;\n    }\n  }\n  return false;\n};\nconst unsetAllMarks = () => _ref67 => {\n  let {\n    tr,\n    dispatch\n  } = _ref67;\n  const {\n    selection\n  } = tr;\n  const {\n    empty,\n    ranges\n  } = selection;\n  if (empty) {\n    return true;\n  }\n  if (dispatch) {\n    ranges.forEach(range => {\n      tr.removeMark(range.$from.pos, range.$to.pos);\n    });\n  }\n  return true;\n};\nconst unsetMark = function (typeOrName) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref68 => {\n    let {\n      tr,\n      state,\n      dispatch\n    } = _ref68;\n    var _a;\n    const {\n      extendEmptyMarkRange = false\n    } = options;\n    const {\n      selection\n    } = tr;\n    const type = getMarkType(typeOrName, state.schema);\n    const {\n      $from,\n      empty,\n      ranges\n    } = selection;\n    if (!dispatch) {\n      return true;\n    }\n    if (empty && extendEmptyMarkRange) {\n      let {\n        from,\n        to\n      } = selection;\n      const attrs = (_a = $from.marks().find(mark => mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;\n      const range = getMarkRange($from, type, attrs);\n      if (range) {\n        from = range.from;\n        to = range.to;\n      }\n      tr.removeMark(from, to, type);\n    } else {\n      ranges.forEach(range => {\n        tr.removeMark(range.$from.pos, range.$to.pos, type);\n      });\n    }\n    tr.removeStoredMark(type);\n    return true;\n  };\n};\nconst updateAttributes = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref69 => {\n    let {\n      tr,\n      state,\n      dispatch\n    } = _ref69;\n    let nodeType = null;\n    let markType = null;\n    const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n    if (!schemaType) {\n      return false;\n    }\n    if (schemaType === 'node') {\n      nodeType = getNodeType(typeOrName, state.schema);\n    }\n    if (schemaType === 'mark') {\n      markType = getMarkType(typeOrName, state.schema);\n    }\n    if (dispatch) {\n      tr.selection.ranges.forEach(range => {\n        const from = range.$from.pos;\n        const to = range.$to.pos;\n        state.doc.nodesBetween(from, to, (node, pos) => {\n          if (nodeType && nodeType === node.type) {\n            tr.setNodeMarkup(pos, undefined, {\n              ...node.attrs,\n              ...attributes\n            });\n          }\n          if (markType && node.marks.length) {\n            node.marks.forEach(mark => {\n              if (markType === mark.type) {\n                const trimmedFrom = Math.max(pos, from);\n                const trimmedTo = Math.min(pos + node.nodeSize, to);\n                tr.addMark(trimmedFrom, trimmedTo, markType.create({\n                  ...mark.attrs,\n                  ...attributes\n                }));\n              }\n            });\n          }\n        });\n      });\n    }\n    return true;\n  };\n};\nconst wrapIn = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref70 => {\n    let {\n      state,\n      dispatch\n    } = _ref70;\n    const type = getNodeType(typeOrName, state.schema);\n    return wrapIn$1(type, attributes)(state, dispatch);\n  };\n};\nconst wrapInList = function (typeOrName) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _ref71 => {\n    let {\n      state,\n      dispatch\n    } = _ref71;\n    const type = getNodeType(typeOrName, state.schema);\n    return wrapInList$1(type, attributes)(state, dispatch);\n  };\n};\nvar commands = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  blur: blur,\n  clearContent: clearContent,\n  clearNodes: clearNodes,\n  command: command,\n  createParagraphNear: createParagraphNear,\n  cut: cut,\n  deleteCurrentNode: deleteCurrentNode,\n  deleteNode: deleteNode,\n  deleteRange: deleteRange,\n  deleteSelection: deleteSelection,\n  enter: enter,\n  exitCode: exitCode,\n  extendMarkRange: extendMarkRange,\n  first: first,\n  focus: focus,\n  forEach: forEach,\n  insertContent: insertContent,\n  insertContentAt: insertContentAt,\n  joinUp: joinUp,\n  joinDown: joinDown,\n  joinBackward: joinBackward,\n  joinForward: joinForward,\n  joinItemBackward: joinItemBackward,\n  joinItemForward: joinItemForward,\n  keyboardShortcut: keyboardShortcut,\n  lift: lift,\n  liftEmptyBlock: liftEmptyBlock,\n  liftListItem: liftListItem,\n  newlineInCode: newlineInCode,\n  resetAttributes: resetAttributes,\n  scrollIntoView: scrollIntoView,\n  selectAll: selectAll,\n  selectNodeBackward: selectNodeBackward,\n  selectNodeForward: selectNodeForward,\n  selectParentNode: selectParentNode,\n  selectTextblockEnd: selectTextblockEnd,\n  selectTextblockStart: selectTextblockStart,\n  setContent: setContent,\n  setMark: setMark,\n  setMeta: setMeta,\n  setNode: setNode,\n  setNodeSelection: setNodeSelection,\n  setTextSelection: setTextSelection,\n  sinkListItem: sinkListItem,\n  splitBlock: splitBlock,\n  splitListItem: splitListItem,\n  toggleList: toggleList,\n  toggleMark: toggleMark,\n  toggleNode: toggleNode,\n  toggleWrap: toggleWrap,\n  undoInputRule: undoInputRule,\n  unsetAllMarks: unsetAllMarks,\n  unsetMark: unsetMark,\n  updateAttributes: updateAttributes,\n  wrapIn: wrapIn,\n  wrapInList: wrapInList\n});\nconst Commands = Extension.create({\n  name: 'commands',\n  addCommands() {\n    return {\n      ...commands\n    };\n  }\n});\nconst Editable = Extension.create({\n  name: 'editable',\n  addProseMirrorPlugins() {\n    return [new Plugin({\n      key: new PluginKey('editable'),\n      props: {\n        editable: () => this.editor.options.editable\n      }\n    })];\n  }\n});\nconst FocusEvents = Extension.create({\n  name: 'focusEvents',\n  addProseMirrorPlugins() {\n    const {\n      editor\n    } = this;\n    return [new Plugin({\n      key: new PluginKey('focusEvents'),\n      props: {\n        handleDOMEvents: {\n          focus: (view, event) => {\n            editor.isFocused = true;\n            const transaction = editor.state.tr.setMeta('focus', {\n              event\n            }).setMeta('addToHistory', false);\n            view.dispatch(transaction);\n            return false;\n          },\n          blur: (view, event) => {\n            editor.isFocused = false;\n            const transaction = editor.state.tr.setMeta('blur', {\n              event\n            }).setMeta('addToHistory', false);\n            view.dispatch(transaction);\n            return false;\n          }\n        }\n      }\n    })];\n  }\n});\nconst Keymap = Extension.create({\n  name: 'keymap',\n  addKeyboardShortcuts() {\n    const handleBackspace = () => this.editor.commands.first(_ref72 => {\n      let {\n        commands\n      } = _ref72;\n      return [() => commands.undoInputRule(),\n      // maybe convert first text block node to default node\n      () => commands.command(_ref73 => {\n        let {\n          tr\n        } = _ref73;\n        const {\n          selection,\n          doc\n        } = tr;\n        const {\n          empty,\n          $anchor\n        } = selection;\n        const {\n          pos,\n          parent\n        } = $anchor;\n        const $parentPos = $anchor.parent.isTextblock ? tr.doc.resolve(pos - 1) : $anchor;\n        const parentIsIsolating = $parentPos.parent.type.spec.isolating;\n        const parentPos = $anchor.pos - $anchor.parentOffset;\n        const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc).from === pos;\n        if (!empty || !isAtStart || !parent.type.isTextblock || parent.textContent.length) {\n          return false;\n        }\n        return commands.clearNodes();\n      }), () => commands.deleteSelection(), () => commands.joinBackward(), () => commands.selectNodeBackward()];\n    });\n    const handleDelete = () => this.editor.commands.first(_ref74 => {\n      let {\n        commands\n      } = _ref74;\n      return [() => commands.deleteSelection(), () => commands.deleteCurrentNode(), () => commands.joinForward(), () => commands.selectNodeForward()];\n    });\n    const handleEnter = () => this.editor.commands.first(_ref75 => {\n      let {\n        commands\n      } = _ref75;\n      return [() => commands.newlineInCode(), () => commands.createParagraphNear(), () => commands.liftEmptyBlock(), () => commands.splitBlock()];\n    });\n    const baseKeymap = {\n      Enter: handleEnter,\n      'Mod-Enter': () => this.editor.commands.exitCode(),\n      Backspace: handleBackspace,\n      'Mod-Backspace': handleBackspace,\n      'Shift-Backspace': handleBackspace,\n      Delete: handleDelete,\n      'Mod-Delete': handleDelete,\n      'Mod-a': () => this.editor.commands.selectAll()\n    };\n    const pcKeymap = {\n      ...baseKeymap\n    };\n    const macKeymap = {\n      ...baseKeymap,\n      'Ctrl-h': handleBackspace,\n      'Alt-Backspace': handleBackspace,\n      'Ctrl-d': handleDelete,\n      'Ctrl-Alt-Backspace': handleDelete,\n      'Alt-Delete': handleDelete,\n      'Alt-d': handleDelete,\n      'Ctrl-a': () => this.editor.commands.selectTextblockStart(),\n      'Ctrl-e': () => this.editor.commands.selectTextblockEnd()\n    };\n    if (isiOS() || isMacOS()) {\n      return macKeymap;\n    }\n    return pcKeymap;\n  },\n  addProseMirrorPlugins() {\n    return [\n    // With this plugin we check if the whole document was selected and deleted.\n    // In this case we will additionally call `clearNodes()` to convert e.g. a heading\n    // to a paragraph if necessary.\n    // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well\n    // with many other commands.\n    new Plugin({\n      key: new PluginKey('clearDocument'),\n      appendTransaction: (transactions, oldState, newState) => {\n        const docChanges = transactions.some(transaction => transaction.docChanged) && !oldState.doc.eq(newState.doc);\n        if (!docChanges) {\n          return;\n        }\n        const {\n          empty,\n          from,\n          to\n        } = oldState.selection;\n        const allFrom = Selection.atStart(oldState.doc).from;\n        const allEnd = Selection.atEnd(oldState.doc).to;\n        const allWasSelected = from === allFrom && to === allEnd;\n        if (empty || !allWasSelected) {\n          return;\n        }\n        const isEmpty = newState.doc.textBetween(0, newState.doc.content.size, ' ', ' ').length === 0;\n        if (!isEmpty) {\n          return;\n        }\n        const tr = newState.tr;\n        const state = createChainableState({\n          state: newState,\n          transaction: tr\n        });\n        const {\n          commands\n        } = new CommandManager({\n          editor: this.editor,\n          state\n        });\n        commands.clearNodes();\n        if (!tr.steps.length) {\n          return;\n        }\n        return tr;\n      }\n    })];\n  }\n});\nconst Tabindex = Extension.create({\n  name: 'tabindex',\n  addProseMirrorPlugins() {\n    return [new Plugin({\n      key: new PluginKey('tabindex'),\n      props: {\n        attributes: this.editor.isEditable ? {\n          tabindex: '0'\n        } : {}\n      }\n    })];\n  }\n});\nvar extensions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ClipboardTextSerializer: ClipboardTextSerializer,\n  Commands: Commands,\n  Editable: Editable,\n  FocusEvents: FocusEvents,\n  Keymap: Keymap,\n  Tabindex: Tabindex\n});\nconst style = \".ProseMirror {\\n  position: relative;\\n}\\n\\n.ProseMirror {\\n  word-wrap: break-word;\\n  white-space: pre-wrap;\\n  white-space: break-spaces;\\n  -webkit-font-variant-ligatures: none;\\n  font-variant-ligatures: none;\\n  font-feature-settings: \\\"liga\\\" 0; /* the above doesn't seem to work in Edge */\\n}\\n\\n.ProseMirror [contenteditable=\\\"false\\\"] {\\n  white-space: normal;\\n}\\n\\n.ProseMirror [contenteditable=\\\"false\\\"] [contenteditable=\\\"true\\\"] {\\n  white-space: pre-wrap;\\n}\\n\\n.ProseMirror pre {\\n  white-space: pre-wrap;\\n}\\n\\nimg.ProseMirror-separator {\\n  display: inline !important;\\n  border: none !important;\\n  margin: 0 !important;\\n  width: 1px !important;\\n  height: 1px !important;\\n}\\n\\n.ProseMirror-gapcursor {\\n  display: none;\\n  pointer-events: none;\\n  position: absolute;\\n  margin: 0;\\n}\\n\\n.ProseMirror-gapcursor:after {\\n  content: \\\"\\\";\\n  display: block;\\n  position: absolute;\\n  top: -2px;\\n  width: 20px;\\n  border-top: 1px solid black;\\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\\n}\\n\\n@keyframes ProseMirror-cursor-blink {\\n  to {\\n    visibility: hidden;\\n  }\\n}\\n\\n.ProseMirror-hideselection *::selection {\\n  background: transparent;\\n}\\n\\n.ProseMirror-hideselection *::-moz-selection {\\n  background: transparent;\\n}\\n\\n.ProseMirror-hideselection * {\\n  caret-color: transparent;\\n}\\n\\n.ProseMirror-focused .ProseMirror-gapcursor {\\n  display: block;\\n}\\n\\n.tippy-box[data-animation=fade][data-state=hidden] {\\n  opacity: 0\\n}\";\nfunction createStyleTag(style, nonce, suffix) {\n  const tiptapStyleTag = document.querySelector(\"style[data-tiptap-style\".concat(suffix ? \"-\".concat(suffix) : '', \"]\"));\n  if (tiptapStyleTag !== null) {\n    return tiptapStyleTag;\n  }\n  const styleNode = document.createElement('style');\n  if (nonce) {\n    styleNode.setAttribute('nonce', nonce);\n  }\n  styleNode.setAttribute(\"data-tiptap-style\".concat(suffix ? \"-\".concat(suffix) : ''), '');\n  styleNode.innerHTML = style;\n  document.getElementsByTagName('head')[0].appendChild(styleNode);\n  return styleNode;\n}\nclass Editor extends EventEmitter {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this.isFocused = false;\n    this.extensionStorage = {};\n    this.options = {\n      element: document.createElement('div'),\n      content: '',\n      injectCSS: true,\n      injectNonce: undefined,\n      extensions: [],\n      autofocus: false,\n      editable: true,\n      editorProps: {},\n      parseOptions: {},\n      enableInputRules: true,\n      enablePasteRules: true,\n      enableCoreExtensions: true,\n      onBeforeCreate: () => null,\n      onCreate: () => null,\n      onUpdate: () => null,\n      onSelectionUpdate: () => null,\n      onTransaction: () => null,\n      onFocus: () => null,\n      onBlur: () => null,\n      onDestroy: () => null\n    };\n    this.isCapturingTransaction = false;\n    this.capturedTransaction = null;\n    this.setOptions(options);\n    this.createExtensionManager();\n    this.createCommandManager();\n    this.createSchema();\n    this.on('beforeCreate', this.options.onBeforeCreate);\n    this.emit('beforeCreate', {\n      editor: this\n    });\n    this.createView();\n    this.injectCSS();\n    this.on('create', this.options.onCreate);\n    this.on('update', this.options.onUpdate);\n    this.on('selectionUpdate', this.options.onSelectionUpdate);\n    this.on('transaction', this.options.onTransaction);\n    this.on('focus', this.options.onFocus);\n    this.on('blur', this.options.onBlur);\n    this.on('destroy', this.options.onDestroy);\n    window.setTimeout(() => {\n      if (this.isDestroyed) {\n        return;\n      }\n      this.commands.focus(this.options.autofocus);\n      this.emit('create', {\n        editor: this\n      });\n    }, 0);\n  }\n  /**\r\n   * Returns the editor storage.\r\n   */\n  get storage() {\n    return this.extensionStorage;\n  }\n  /**\r\n   * An object of all registered commands.\r\n   */\n  get commands() {\n    return this.commandManager.commands;\n  }\n  /**\r\n   * Create a command chain to call multiple commands at once.\r\n   */\n  chain() {\n    return this.commandManager.chain();\n  }\n  /**\r\n   * Check if a command or a command chain can be executed. Without executing it.\r\n   */\n  can() {\n    return this.commandManager.can();\n  }\n  /**\r\n   * Inject CSS styles.\r\n   */\n  injectCSS() {\n    if (this.options.injectCSS && document) {\n      this.css = createStyleTag(style, this.options.injectNonce);\n    }\n  }\n  /**\r\n   * Update editor options.\r\n   *\r\n   * @param options A list of options\r\n   */\n  setOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.options = {\n      ...this.options,\n      ...options\n    };\n    if (!this.view || !this.state || this.isDestroyed) {\n      return;\n    }\n    if (this.options.editorProps) {\n      this.view.setProps(this.options.editorProps);\n    }\n    this.view.updateState(this.state);\n  }\n  /**\r\n   * Update editable state of the editor.\r\n   */\n  setEditable(editable) {\n    let emitUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.setOptions({\n      editable\n    });\n    if (emitUpdate) {\n      this.emit('update', {\n        editor: this,\n        transaction: this.state.tr\n      });\n    }\n  }\n  /**\r\n   * Returns whether the editor is editable.\r\n   */\n  get isEditable() {\n    // since plugins are applied after creating the view\n    // `editable` is always `true` for one tick.\n    // that’s why we also have to check for `options.editable`\n    return this.options.editable && this.view && this.view.editable;\n  }\n  /**\r\n   * Returns the editor state.\r\n   */\n  get state() {\n    return this.view.state;\n  }\n  /**\r\n   * Register a ProseMirror plugin.\r\n   *\r\n   * @param plugin A ProseMirror plugin\r\n   * @param handlePlugins Control how to merge the plugin into the existing plugins.\r\n   */\n  registerPlugin(plugin, handlePlugins) {\n    const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];\n    const state = this.state.reconfigure({\n      plugins\n    });\n    this.view.updateState(state);\n  }\n  /**\r\n   * Unregister a ProseMirror plugin.\r\n   *\r\n   * @param nameOrPluginKey The plugins name\r\n   */\n  unregisterPlugin(nameOrPluginKey) {\n    if (this.isDestroyed) {\n      return;\n    }\n    // @ts-ignore\n    const name = typeof nameOrPluginKey === 'string' ? \"\".concat(nameOrPluginKey, \"$\") : nameOrPluginKey.key;\n    const state = this.state.reconfigure({\n      // @ts-ignore\n      plugins: this.state.plugins.filter(plugin => !plugin.key.startsWith(name))\n    });\n    this.view.updateState(state);\n  }\n  /**\r\n   * Creates an extension manager.\r\n   */\n  createExtensionManager() {\n    const coreExtensions = this.options.enableCoreExtensions ? Object.values(extensions) : [];\n    const allExtensions = [...coreExtensions, ...this.options.extensions].filter(extension => {\n      return ['extension', 'node', 'mark'].includes(extension === null || extension === void 0 ? void 0 : extension.type);\n    });\n    this.extensionManager = new ExtensionManager(allExtensions, this);\n  }\n  /**\r\n   * Creates an command manager.\r\n   */\n  createCommandManager() {\n    this.commandManager = new CommandManager({\n      editor: this\n    });\n  }\n  /**\r\n   * Creates a ProseMirror schema.\r\n   */\n  createSchema() {\n    this.schema = this.extensionManager.schema;\n  }\n  /**\r\n   * Creates a ProseMirror view.\r\n   */\n  createView() {\n    const doc = createDocument(this.options.content, this.schema, this.options.parseOptions);\n    const selection = resolveFocusPosition(doc, this.options.autofocus);\n    this.view = new EditorView(this.options.element, {\n      ...this.options.editorProps,\n      dispatchTransaction: this.dispatchTransaction.bind(this),\n      state: EditorState.create({\n        doc,\n        selection: selection || undefined\n      })\n    });\n    // `editor.view` is not yet available at this time.\n    // Therefore we will add all plugins and node views directly afterwards.\n    const newState = this.state.reconfigure({\n      plugins: this.extensionManager.plugins\n    });\n    this.view.updateState(newState);\n    this.createNodeViews();\n    this.prependClass();\n    // Let’s store the editor instance in the DOM element.\n    // So we’ll have access to it for tests.\n    const dom = this.view.dom;\n    dom.editor = this;\n  }\n  /**\r\n   * Creates all node views.\r\n   */\n  createNodeViews() {\n    this.view.setProps({\n      nodeViews: this.extensionManager.nodeViews\n    });\n  }\n  /**\r\n   * Prepend class name to element.\r\n   */\n  prependClass() {\n    this.view.dom.className = \"tiptap \".concat(this.view.dom.className);\n  }\n  captureTransaction(fn) {\n    this.isCapturingTransaction = true;\n    fn();\n    this.isCapturingTransaction = false;\n    const tr = this.capturedTransaction;\n    this.capturedTransaction = null;\n    return tr;\n  }\n  /**\r\n   * The callback over which to send transactions (state updates) produced by the view.\r\n   *\r\n   * @param transaction An editor state transaction\r\n   */\n  dispatchTransaction(transaction) {\n    // if the editor / the view of the editor was destroyed\n    // the transaction should not be dispatched as there is no view anymore.\n    if (this.view.isDestroyed) {\n      return;\n    }\n    if (this.isCapturingTransaction) {\n      if (!this.capturedTransaction) {\n        this.capturedTransaction = transaction;\n        return;\n      }\n      transaction.steps.forEach(step => {\n        var _a;\n        return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step);\n      });\n      return;\n    }\n    const state = this.state.apply(transaction);\n    const selectionHasChanged = !this.state.selection.eq(state.selection);\n    this.view.updateState(state);\n    this.emit('transaction', {\n      editor: this,\n      transaction\n    });\n    if (selectionHasChanged) {\n      this.emit('selectionUpdate', {\n        editor: this,\n        transaction\n      });\n    }\n    const focus = transaction.getMeta('focus');\n    const blur = transaction.getMeta('blur');\n    if (focus) {\n      this.emit('focus', {\n        editor: this,\n        event: focus.event,\n        transaction\n      });\n    }\n    if (blur) {\n      this.emit('blur', {\n        editor: this,\n        event: blur.event,\n        transaction\n      });\n    }\n    if (!transaction.docChanged || transaction.getMeta('preventUpdate')) {\n      return;\n    }\n    this.emit('update', {\n      editor: this,\n      transaction\n    });\n  }\n  /**\r\n   * Get attributes of the currently selected node or mark.\r\n   */\n  getAttributes(nameOrType) {\n    return getAttributes(this.state, nameOrType);\n  }\n  isActive(nameOrAttributes, attributesOrUndefined) {\n    const name = typeof nameOrAttributes === 'string' ? nameOrAttributes : null;\n    const attributes = typeof nameOrAttributes === 'string' ? attributesOrUndefined : nameOrAttributes;\n    return isActive(this.state, name, attributes);\n  }\n  /**\r\n   * Get the document as JSON.\r\n   */\n  getJSON() {\n    return this.state.doc.toJSON();\n  }\n  /**\r\n   * Get the document as HTML.\r\n   */\n  getHTML() {\n    return getHTMLFromFragment(this.state.doc.content, this.schema);\n  }\n  /**\r\n   * Get the document as text.\r\n   */\n  getText(options) {\n    const {\n      blockSeparator = '\\n\\n',\n      textSerializers = {}\n    } = options || {};\n    return getText(this.state.doc, {\n      blockSeparator,\n      textSerializers: {\n        ...getTextSerializersFromSchema(this.schema),\n        ...textSerializers\n      }\n    });\n  }\n  /**\r\n   * Check if there is no content.\r\n   */\n  get isEmpty() {\n    return isNodeEmpty(this.state.doc);\n  }\n  /**\r\n   * Get the number of characters for the current document.\r\n   *\r\n   * @deprecated\r\n   */\n  getCharacterCount() {\n    console.warn('[tiptap warn]: \"editor.getCharacterCount()\" is deprecated. Please use \"editor.storage.characterCount.characters()\" instead.');\n    return this.state.doc.content.size - 2;\n  }\n  /**\r\n   * Destroy the editor.\r\n   */\n  destroy() {\n    this.emit('destroy');\n    if (this.view) {\n      this.view.destroy();\n    }\n    this.removeAllListeners();\n  }\n  /**\r\n   * Check if the editor is already destroyed.\r\n   */\n  get isDestroyed() {\n    var _a;\n    // @ts-ignore\n    return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);\n  }\n}\n\n/**\r\n * Build an input rule that adds a mark when the\r\n * matched text is typed into it.\r\n */\nfunction markInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: _ref76 => {\n      let {\n        state,\n        range,\n        match\n      } = _ref76;\n      const attributes = callOrReturn(config.getAttributes, undefined, match);\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n      const {\n        tr\n      } = state;\n      const captureGroup = match[match.length - 1];\n      const fullMatch = match[0];\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/);\n        const textStart = range.from + fullMatch.indexOf(captureGroup);\n        const textEnd = textStart + captureGroup.length;\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter(item => {\n          // @ts-ignore\n          const excluded = item.mark.type.excluded;\n          return excluded.find(type => type === config.type && type !== item.mark.type);\n        }).filter(item => item.to > textStart);\n        if (excludedMarks.length) {\n          return null;\n        }\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to);\n        }\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart);\n        }\n        const markEnd = range.from + startSpaces + captureGroup.length;\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n        tr.removeStoredMark(config.type);\n      }\n    }\n  });\n}\n\n/**\r\n * Build an input rule that adds a node when the\r\n * matched text is typed into it.\r\n */\nfunction nodeInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: _ref77 => {\n      let {\n        state,\n        range,\n        match\n      } = _ref77;\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n      const {\n        tr\n      } = state;\n      const start = range.from;\n      let end = range.to;\n      const newNode = config.type.create(attributes);\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        let matchStart = start + offset;\n        if (matchStart > end) {\n          matchStart = end;\n        } else {\n          end = matchStart + match[1].length;\n        }\n        // insert last typed character\n        const lastChar = match[0][match[0].length - 1];\n        tr.insertText(lastChar, start + match[0].length - 1);\n        // insert node from input rule\n        tr.replaceWith(matchStart, end, newNode);\n      } else if (match[0]) {\n        tr.insert(start - 1, config.type.create(attributes)).delete(tr.mapping.map(start), tr.mapping.map(end));\n      }\n      tr.scrollIntoView();\n    }\n  });\n}\n\n/**\r\n * Build an input rule that changes the type of a textblock when the\r\n * matched text is typed into it. When using a regular expresion you’ll\r\n * probably want the regexp to start with `^`, so that the pattern can\r\n * only occur at the start of a textblock.\r\n */\nfunction textblockTypeInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: _ref78 => {\n      let {\n        state,\n        range,\n        match\n      } = _ref78;\n      const $start = state.doc.resolve(range.from);\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {\n        return null;\n      }\n      state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);\n    }\n  });\n}\n\n/**\r\n * Build an input rule that replaces text when the\r\n * matched text is typed into it.\r\n */\nfunction textInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: _ref79 => {\n      let {\n        state,\n        range,\n        match\n      } = _ref79;\n      let insert = config.replace;\n      let start = range.from;\n      const end = range.to;\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        insert += match[0].slice(offset + match[1].length);\n        start += offset;\n        const cutOff = start - end;\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert;\n          start = end;\n        }\n      }\n      state.tr.insertText(insert, start, end);\n    }\n  });\n}\n\n/**\r\n * Build an input rule for automatically wrapping a textblock when a\r\n * given string is typed. When using a regular expresion you’ll\r\n * probably want the regexp to start with `^`, so that the pattern can\r\n * only occur at the start of a textblock.\r\n *\r\n * `type` is the type of node to wrap in.\r\n *\r\n * By default, if there’s a node with the same type above the newly\r\n * wrapped node, the rule will try to join those\r\n * two nodes. You can pass a join predicate, which takes a regular\r\n * expression match and the node before the wrapped node, and can\r\n * return a boolean to indicate whether a join should happen.\r\n */\nfunction wrappingInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: _ref80 => {\n      let {\n        state,\n        range,\n        match,\n        chain\n      } = _ref80;\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n      const tr = state.tr.delete(range.from, range.to);\n      const $start = tr.doc.resolve(range.from);\n      const blockRange = $start.blockRange();\n      const wrapping = blockRange && findWrapping(blockRange, config.type, attributes);\n      if (!wrapping) {\n        return null;\n      }\n      tr.wrap(blockRange, wrapping);\n      if (config.keepMarks && config.editor) {\n        const {\n          selection,\n          storedMarks\n        } = state;\n        const {\n          splittableMarks\n        } = config.editor.extensionManager;\n        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n        if (marks) {\n          const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name));\n          tr.ensureMarks(filteredMarks);\n        }\n      }\n      if (config.keepAttributes) {\n        /** If the nodeType is `bulletList` or `orderedList` set the `nodeType` as `listItem` */\n        const nodeType = config.type.name === 'bulletList' || config.type.name === 'orderedList' ? 'listItem' : 'taskList';\n        chain().updateAttributes(nodeType, attributes).run();\n      }\n      const before = tr.doc.resolve(range.from - 1).nodeBefore;\n      if (before && before.type === config.type && canJoin(tr.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {\n        tr.join(range.from - 1);\n      }\n    }\n  });\n}\nclass Mark {\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.type = 'mark';\n    this.name = 'mark';\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = {\n      ...this.config,\n      ...config\n    };\n    this.name = this.config.name;\n    if (config.defaultOptions) {\n      console.warn(\"[tiptap warn]: BREAKING CHANGE: \\\"defaultOptions\\\" is deprecated. Please use \\\"addOptions\\\" instead. Found in extension: \\\"\".concat(this.name, \"\\\".\"));\n    }\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions;\n    if (this.config.addOptions) {\n      this.options = callOrReturn(getExtensionField(this, 'addOptions', {\n        name: this.name\n      }));\n    }\n    this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\n      name: this.name,\n      options: this.options\n    })) || {};\n  }\n  static create() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new Mark(config);\n  }\n  configure() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend();\n    extension.options = mergeDeep(this.options, options);\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n  extend() {\n    let extendedConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const extension = new Mark(extendedConfig);\n    extension.parent = this;\n    this.child = extension;\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n    if (extendedConfig.defaultOptions) {\n      console.warn(\"[tiptap warn]: BREAKING CHANGE: \\\"defaultOptions\\\" is deprecated. Please use \\\"addOptions\\\" instead. Found in extension: \\\"\".concat(extension.name, \"\\\".\"));\n    }\n    extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\n      name: extension.name\n    }));\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n  static handleExit(_ref81) {\n    let {\n      editor,\n      mark\n    } = _ref81;\n    const {\n      tr\n    } = editor.state;\n    const currentPos = editor.state.selection.$from;\n    const isAtEnd = currentPos.pos === currentPos.end();\n    if (isAtEnd) {\n      const currentMarks = currentPos.marks();\n      const isInMark = !!currentMarks.find(m => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);\n      if (!isInMark) {\n        return false;\n      }\n      const removeMark = currentMarks.find(m => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);\n      if (removeMark) {\n        tr.removeStoredMark(removeMark);\n      }\n      tr.insertText(' ', currentPos.pos);\n      editor.view.dispatch(tr);\n      return true;\n    }\n    return false;\n  }\n}\nclass Node {\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.type = 'node';\n    this.name = 'node';\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = {\n      ...this.config,\n      ...config\n    };\n    this.name = this.config.name;\n    if (config.defaultOptions) {\n      console.warn(\"[tiptap warn]: BREAKING CHANGE: \\\"defaultOptions\\\" is deprecated. Please use \\\"addOptions\\\" instead. Found in extension: \\\"\".concat(this.name, \"\\\".\"));\n    }\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions;\n    if (this.config.addOptions) {\n      this.options = callOrReturn(getExtensionField(this, 'addOptions', {\n        name: this.name\n      }));\n    }\n    this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\n      name: this.name,\n      options: this.options\n    })) || {};\n  }\n  static create() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new Node(config);\n  }\n  configure() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend();\n    extension.options = mergeDeep(this.options, options);\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n  extend() {\n    let extendedConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const extension = new Node(extendedConfig);\n    extension.parent = this;\n    this.child = extension;\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n    if (extendedConfig.defaultOptions) {\n      console.warn(\"[tiptap warn]: BREAKING CHANGE: \\\"defaultOptions\\\" is deprecated. Please use \\\"addOptions\\\" instead. Found in extension: \\\"\".concat(extension.name, \"\\\".\"));\n    }\n    extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\n      name: extension.name\n    }));\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n}\nfunction isAndroid() {\n  return navigator.platform === 'Android' || /android/i.test(navigator.userAgent);\n}\nclass NodeView {\n  constructor(component, props, options) {\n    this.isDragging = false;\n    this.component = component;\n    this.editor = props.editor;\n    this.options = {\n      stopEvent: null,\n      ignoreMutation: null,\n      ...options\n    };\n    this.extension = props.extension;\n    this.node = props.node;\n    this.decorations = props.decorations;\n    this.getPos = props.getPos;\n    this.mount();\n  }\n  mount() {\n    // eslint-disable-next-line\n    return;\n  }\n  get dom() {\n    return this.editor.view.dom;\n  }\n  get contentDOM() {\n    return null;\n  }\n  onDragStart(event) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const {\n      view\n    } = this.editor;\n    const target = event.target;\n    // get the drag handle element\n    // `closest` is not available for text nodes so we may have to use its parent\n    const dragHandle = target.nodeType === 3 ? (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.closest('[data-drag-handle]') : target.closest('[data-drag-handle]');\n    if (!this.dom || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target)) || !dragHandle) {\n      return;\n    }\n    let x = 0;\n    let y = 0;\n    // calculate offset for drag element if we use a different drag handle element\n    if (this.dom !== dragHandle) {\n      const domBox = this.dom.getBoundingClientRect();\n      const handleBox = dragHandle.getBoundingClientRect();\n      // In React, we have to go through nativeEvent to reach offsetX/offsetY.\n      const offsetX = (_c = event.offsetX) !== null && _c !== void 0 ? _c : (_d = event.nativeEvent) === null || _d === void 0 ? void 0 : _d.offsetX;\n      const offsetY = (_e = event.offsetY) !== null && _e !== void 0 ? _e : (_f = event.nativeEvent) === null || _f === void 0 ? void 0 : _f.offsetY;\n      x = handleBox.x - domBox.x + offsetX;\n      y = handleBox.y - domBox.y + offsetY;\n    }\n    (_g = event.dataTransfer) === null || _g === void 0 ? void 0 : _g.setDragImage(this.dom, x, y);\n    // we need to tell ProseMirror that we want to move the whole node\n    // so we create a NodeSelection\n    const selection = NodeSelection.create(view.state.doc, this.getPos());\n    const transaction = view.state.tr.setSelection(selection);\n    view.dispatch(transaction);\n  }\n  stopEvent(event) {\n    var _a;\n    if (!this.dom) {\n      return false;\n    }\n    if (typeof this.options.stopEvent === 'function') {\n      return this.options.stopEvent({\n        event\n      });\n    }\n    const target = event.target;\n    const isInElement = this.dom.contains(target) && !((_a = this.contentDOM) === null || _a === void 0 ? void 0 : _a.contains(target));\n    // any event from child nodes should be handled by ProseMirror\n    if (!isInElement) {\n      return false;\n    }\n    const isDragEvent = event.type.startsWith('drag');\n    const isDropEvent = event.type === 'drop';\n    const isInput = ['INPUT', 'BUTTON', 'SELECT', 'TEXTAREA'].includes(target.tagName) || target.isContentEditable;\n    // any input event within node views should be ignored by ProseMirror\n    if (isInput && !isDropEvent && !isDragEvent) {\n      return true;\n    }\n    const {\n      isEditable\n    } = this.editor;\n    const {\n      isDragging\n    } = this;\n    const isDraggable = !!this.node.type.spec.draggable;\n    const isSelectable = NodeSelection.isSelectable(this.node);\n    const isCopyEvent = event.type === 'copy';\n    const isPasteEvent = event.type === 'paste';\n    const isCutEvent = event.type === 'cut';\n    const isClickEvent = event.type === 'mousedown';\n    // ProseMirror tries to drag selectable nodes\n    // even if `draggable` is set to `false`\n    // this fix prevents that\n    if (!isDraggable && isSelectable && isDragEvent) {\n      event.preventDefault();\n    }\n    if (isDraggable && isDragEvent && !isDragging) {\n      event.preventDefault();\n      return false;\n    }\n    // we have to store that dragging started\n    if (isDraggable && isEditable && !isDragging && isClickEvent) {\n      const dragHandle = target.closest('[data-drag-handle]');\n      const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));\n      if (isValidDragHandle) {\n        this.isDragging = true;\n        document.addEventListener('dragend', () => {\n          this.isDragging = false;\n        }, {\n          once: true\n        });\n        document.addEventListener('drop', () => {\n          this.isDragging = false;\n        }, {\n          once: true\n        });\n        document.addEventListener('mouseup', () => {\n          this.isDragging = false;\n        }, {\n          once: true\n        });\n      }\n    }\n    // these events are handled by prosemirror\n    if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {\n      return false;\n    }\n    return true;\n  }\n  ignoreMutation(mutation) {\n    if (!this.dom || !this.contentDOM) {\n      return true;\n    }\n    if (typeof this.options.ignoreMutation === 'function') {\n      return this.options.ignoreMutation({\n        mutation\n      });\n    }\n    // a leaf/atom node is like a black box for ProseMirror\n    // and should be fully handled by the node view\n    if (this.node.isLeaf || this.node.isAtom) {\n      return true;\n    }\n    // ProseMirror should handle any selections\n    if (mutation.type === 'selection') {\n      return false;\n    }\n    // try to prevent a bug on iOS and Android that will break node views on enter\n    // this is because ProseMirror can’t preventDispatch on enter\n    // this will lead to a re-render of the node view on enter\n    // see: https://github.com/ueberdosis/tiptap/issues/1214\n    // see: https://github.com/ueberdosis/tiptap/issues/2534\n    if (this.dom.contains(mutation.target) && mutation.type === 'childList' && (isiOS() || isAndroid()) && this.editor.isFocused) {\n      const changedNodes = [...Array.from(mutation.addedNodes), ...Array.from(mutation.removedNodes)];\n      // we’ll check if every changed node is contentEditable\n      // to make sure it’s probably mutated by ProseMirror\n      if (changedNodes.every(node => node.isContentEditable)) {\n        return false;\n      }\n    }\n    // we will allow mutation contentDOM with attributes\n    // so we can for example adding classes within our node view\n    if (this.contentDOM === mutation.target && mutation.type === 'attributes') {\n      return true;\n    }\n    // ProseMirror should handle any changes within contentDOM\n    if (this.contentDOM.contains(mutation.target)) {\n      return false;\n    }\n    return true;\n  }\n  updateAttributes(attributes) {\n    this.editor.commands.command(_ref82 => {\n      let {\n        tr\n      } = _ref82;\n      const pos = this.getPos();\n      tr.setNodeMarkup(pos, undefined, {\n        ...this.node.attrs,\n        ...attributes\n      });\n      return true;\n    });\n  }\n  deleteNode() {\n    const from = this.getPos();\n    const to = from + this.node.nodeSize;\n    this.editor.commands.deleteRange({\n      from,\n      to\n    });\n  }\n}\n\n/**\r\n * Build an paste rule that adds a mark when the\r\n * matched text is pasted into it.\r\n */\nfunction markPasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler: _ref83 => {\n      let {\n        state,\n        range,\n        match,\n        pasteEvent\n      } = _ref83;\n      const attributes = callOrReturn(config.getAttributes, undefined, match, pasteEvent);\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n      const {\n        tr\n      } = state;\n      const captureGroup = match[match.length - 1];\n      const fullMatch = match[0];\n      let markEnd = range.to;\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/);\n        const textStart = range.from + fullMatch.indexOf(captureGroup);\n        const textEnd = textStart + captureGroup.length;\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter(item => {\n          // @ts-ignore\n          const excluded = item.mark.type.excluded;\n          return excluded.find(type => type === config.type && type !== item.mark.type);\n        }).filter(item => item.to > textStart);\n        if (excludedMarks.length) {\n          return null;\n        }\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to);\n        }\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart);\n        }\n        markEnd = range.from + startSpaces + captureGroup.length;\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n        tr.removeStoredMark(config.type);\n      }\n    }\n  });\n}\n\n// source: https://stackoverflow.com/a/6969486\nfunction escapeForRegEx(string) {\n  return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\n/**\r\n * Build an paste rule that adds a node when the\r\n * matched text is pasted into it.\r\n */\nfunction nodePasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler(_ref84) {\n      let {\n        match,\n        chain,\n        range,\n        pasteEvent\n      } = _ref84;\n      const attributes = callOrReturn(config.getAttributes, undefined, match, pasteEvent);\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n      if (match.input) {\n        chain().deleteRange(range).insertContentAt(range.from, {\n          type: config.type.name,\n          attrs: attributes\n        });\n      }\n    }\n  });\n}\n\n/**\r\n * Build an paste rule that replaces text when the\r\n * matched text is pasted into it.\r\n */\nfunction textPasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler: _ref85 => {\n      let {\n        state,\n        range,\n        match\n      } = _ref85;\n      let insert = config.replace;\n      let start = range.from;\n      const end = range.to;\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        insert += match[0].slice(offset + match[1].length);\n        start += offset;\n        const cutOff = start - end;\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert;\n          start = end;\n        }\n      }\n      state.tr.insertText(insert, start, end);\n    }\n  });\n}\nclass Tracker {\n  constructor(transaction) {\n    this.transaction = transaction;\n    this.currentStep = this.transaction.steps.length;\n  }\n  map(position) {\n    let deleted = false;\n    const mappedPosition = this.transaction.steps.slice(this.currentStep).reduce((newPosition, step) => {\n      const mapResult = step.getMap().mapResult(newPosition);\n      if (mapResult.deleted) {\n        deleted = true;\n      }\n      return mapResult.pos;\n    }, position);\n    return {\n      position: mappedPosition,\n      deleted\n    };\n  }\n}\nexport { CommandManager, Editor, Extension, InputRule, Mark, Node, NodeView, PasteRule, Tracker, callOrReturn, combineTransactionSteps, createChainableState, createDocument, createNodeFromContent, createStyleTag, defaultBlockAt, deleteProps, elementFromString, escapeForRegEx, extensions, findChildren, findChildrenInRange, findDuplicates, findParentNode, findParentNodeClosestToPos, fromString, generateHTML, generateJSON, generateText, getAttributes, getAttributesFromExtensions, getChangedRanges, getDebugJSON, getExtensionField, getHTMLFromFragment, getMarkAttributes, getMarkRange, getMarkType, getMarksBetween, getNodeAtPosition, getNodeAttributes, getNodeType, getRenderedAttributes, getSchema, getSchemaByResolvedExtensions, getSchemaTypeByName, getSchemaTypeNameByName, getSplittedAttributes, getText, getTextBetween, getTextContentFromNodes, getTextSerializersFromSchema, injectExtensionAttributesToParseRule, inputRulesPlugin, isActive, isAtEndOfNode, isAtStartOfNode, isEmptyObject, isExtensionRulesEnabled, isFunction, isList, isMacOS, isMarkActive, isNodeActive, isNodeEmpty, isNodeSelection, isNumber, isPlainObject, isRegExp, isString, isTextSelection, isiOS, markInputRule, markPasteRule, mergeAttributes, mergeDeep, minMax, nodeInputRule, nodePasteRule, objectIncludes, pasteRulesPlugin, posToDOMRect, removeDuplicates, resolveFocusPosition, selectionToInsertionEnd, splitExtensions, textInputRule, textPasteRule, textblockTypeInputRule, wrappingInputRule };","map":{"version":3,"names":["createChainableState","config","state","transaction","selection","doc","storedMarks","apply","bind","applyTransaction","filterTransaction","plugins","schema","reconfigure","toJSON","tr","CommandManager","constructor","props","editor","rawCommands","extensionManager","commands","customState","hasCustomState","_this","view","buildProps","Object","fromEntries","entries","map","_ref","name","command","method","callback","arguments","getMeta","dispatch","chain","createChain","can","createCan","startTr","_this2","shouldDispatch","length","undefined","callbacks","hasStartTransaction","run","every","_ref2","chainedCommand","push","formattedCommands","_ref3","_ref4","EventEmitter","on","event","fn","emit","_len","args","Array","_key","forEach","off","filter","removeAllListeners","getExtensionField","extension","field","context","parent","value","splitExtensions","extensions","baseExtensions","type","nodeExtensions","markExtensions","getAttributesFromExtensions","extensionAttributes","nodeAndMarkExtensions","defaultAttribute","default","rendered","renderHTML","parseHTML","keepOnSplit","isRequired","options","storage","addGlobalAttributes","globalAttributes","globalAttribute","types","attributes","_ref5","attribute","addAttributes","_ref6","mergedAttr","getNodeType","nameOrType","nodes","Error","concat","mergeAttributes","_len2","objects","_key2","item","reduce","items","mergedAttributes","_ref7","key","exists","valueClasses","split","existingClasses","insertClasses","valueClass","includes","join","getRenderedAttributes","nodeOrMark","attrs","isFunction","callOrReturn","_len3","_key3","isEmptyObject","keys","fromString","match","Number","injectExtensionAttributesToParseRule","parseRule","style","getAttrs","node","oldAttributes","newAttributes","getAttribute","cleanUpSchemaItem","data","_ref8","getSchemaByResolvedExtensions","allAttributes","topNode","_a","find","extraNodeFields","fields","e","extendNodeSchema","content","marks","group","inline","atom","selectable","draggable","code","defining","isolating","extensionAttribute","parseDOM","toDOM","HTMLAttributes","renderText","toText","extraMarkFields","extendMarkSchema","inclusive","excludes","spanning","mark","Schema","getSchemaTypeByName","isExtensionRulesEnabled","enabled","isArray","some","enabledExtension","getTextContentFromNodes","$from","maxMatch","textBefore","sliceEndPos","parentOffset","nodesBetween","Math","max","pos","index","chunk","_b","spec","call","textContent","slice","isRegExp","prototype","toString","InputRule","handler","inputRuleMatcherHandler","text","exec","inputRuleMatch","result","input","replaceWith","console","warn","run$1","from","to","rules","plugin","composing","resolve","nodeBefore","nodeAfter","matched","rule","range","steps","setMeta","transform","inputRulesPlugin","Plugin","init","prev","stored","selectionSet","docChanged","handleTextInput","handleDOMEvents","compositionend","setTimeout","$cursor","handleKeyDown","isInputRules","isNumber","PasteRule","pasteRuleMatcherHandler","matchAll","matches","pasteRuleMatch","pasteEvent","dropEvent","handlers","isTextblock","resolvedFrom","resolvedTo","min","size","textToMatch","textBetween","start","end","mapping","success","pasteRulesPlugin","dragSourceElement","isPastedFromProseMirror","isDroppedFromProseMirror","ClipboardEvent","DragEvent","handleDragstart","dom","parentElement","contains","target","window","addEventListener","destroy","removeEventListener","drop","paste","_view","html","clipboardData","getData","appendTransaction","transactions","oldState","isPaste","isDrop","findDiffStart","findDiffEnd","b","chainableState","findDuplicates","filtered","el","indexOf","Set","ExtensionManager","splittableMarks","extensionStorage","onBeforeCreate","onCreate","onUpdate","onSelectionUpdate","onTransaction","onFocus","onBlur","onDestroy","resolvedExtensions","sort","flatten","duplicatedNames","addExtensions","flat","defaultPriority","a","priorityA","priorityB","addCommands","reverse","inputRules","pasteRules","allPlugins","addKeyboardShortcuts","defaultBindings","exitable","ArrowRight","Mark","handleExit","bindings","_ref9","shortcut","keyMapPlugin","keymap","addInputRules","enableInputRules","addPasteRules","enablePasteRules","addProseMirrorPlugins","proseMirrorPlugins","nodeViews","addNodeView","nodeview","getPos","decorations","getType","isPlainObject","getPrototypeOf","mergeDeep","source","output","assign","Extension","child","defaultOptions","addOptions","create","configure","extend","extendedConfig","getTextBetween","startNode","blockSeparator","textSerializers","separated","textSerializer","isBlock","isText","getTextSerializersFromSchema","_ref10","_ref11","ClipboardTextSerializer","PluginKey","clipboardTextSerializer","ranges","$to","blur","_ref12","requestAnimationFrame","isDestroyed","getSelection","removeAllRanges","clearContent","emitUpdate","_ref13","setContent","clearNodes","_ref14","_ref15","$mappedFrom","$mappedTo","nodeSize","nodeRange","blockRange","targetLiftDepth","liftTarget","defaultType","contentMatchAt","setNodeMarkup","lift","createParagraphNear","_ref16","createParagraphNear$1","cut","originRange","targetPos","_ref17","contentSlice","deleteRange","newPos","insert","setSelection","TextSelection","deleteCurrentNode","_ref18","currentNode","$anchor","$pos","depth","before","after","delete","scrollIntoView","deleteNode","typeOrName","_ref19","_ref20","deleteSelection","_ref21","deleteSelection$1","enter","_ref22","keyboardShortcut","exitCode","_ref23","exitCode$1","objectIncludes","object1","object2","strict","test","findMarkInSet","isMarkInSet","getMarkRange","childAfter","offset","childBefore","startIndex","startPos","endIndex","endPos","isInSet","childCount","getMarkType","extendMarkRange","_ref24","newSelection","first","i","isTextSelection","minMax","resolveFocusPosition","position","selectionAtStart","Selection","atStart","selectionAtEnd","atEnd","minPos","maxPos","isiOS","navigator","platform","userAgent","document","focus","_ref25","delayedFocus","hasFocus","isSameSelection","eq","setStoredMarks","insertContent","_ref26","insertContentAt","elementFromString","wrappedValue","DOMParser","parseFromString","body","createNodeFromContent","parseOptions","Fragment","fromArray","nodeFromJSON","error","parser","fromSchema","parseSlice","parse","selectionToInsertionEnd","startLen","bias","last","step","ReplaceStep","ReplaceAroundStep","maps","_from","_to","_newFrom","newTo","near","isFragment","nodeOrFragment","startsWith","_ref27","updateSelection","preserveWhitespace","isOnlyTextContent","isOnlyBlockContent","check","isEmptyTextBlock","insertText","v","joinUp","_ref28","joinUp$1","joinDown","_ref29","joinDown$1","joinBackward","_ref30","joinBackward$1","joinForward","_ref31","joinForward$1","joinItemBackward","_ref32","point","joinPoint","joinItemForward","_ref33","isMacOS","normalizeKeyName","parts","alt","ctrl","shift","meta","mod","_ref34","KeyboardEvent","altKey","ctrlKey","metaKey","shiftKey","bubbles","cancelable","capturedTransaction","captureTransaction","someProp","f","newStep","maybeStep","isNodeActive","empty","nodeRanges","relativeFrom","relativeTo","selectionRange","matchedNodeRanges","sum","_ref35","isActive","lift$1","liftEmptyBlock","_ref36","liftEmptyBlock$1","liftListItem","_ref37","liftListItem$1","newlineInCode","_ref38","newlineInCode$1","getSchemaTypeNameByName","deleteProps","obj","propOrProps","newObj","prop","resetAttributes","_ref39","nodeType","markType","schemaType","addMark","_ref40","selectAll","_ref41","setTextSelection","selectNodeBackward","_ref42","selectNodeBackward$1","selectNodeForward","_ref43","selectNodeForward$1","selectParentNode","_ref44","selectParentNode$1","selectTextblockEnd","_ref45","selectTextblockEnd$1","selectTextblockStart","_ref46","selectTextblockStart$1","createDocument","_ref47","getMarkAttributes","$head","markItem","combineTransactionSteps","oldDoc","Transform","defaultBlockAt","edgeCount","edge","hasRequiredAttrs","findChildren","predicate","nodesWithPos","descendants","findChildrenInRange","findParentNodeClosestToPos","findParentNode","getHTMLFromFragment","fragment","documentFragment","DOMSerializer","serializeFragment","temporaryDocument","implementation","createHTMLDocument","container","createElement","appendChild","innerHTML","getSchema","generateHTML","contentNode","Node$1","fromJSON","generateJSON","getText","generateText","getNodeAttributes","nodeItem","getAttributes","removeDuplicates","array","by","JSON","stringify","seen","hasOwnProperty","simplifyChangedRanges","changes","uniqueChanges","change","rest","_","otherChange","oldRange","newRange","getChangedRanges","stepMap","_ref48","newStart","newEnd","oldStart","invert","oldEnd","getDebugJSON","startOffset","isTopNode","topNodeType","increment","getMarksBetween","getNodeAtPosition","maxDepth","currentDepth","getSplittedAttributes","typeName","_ref49","isMarkActive","markRanges","_ref50","matchedRange","markRange","excludedRange","isAtEndOfNode","parentNode","$parentPos","isAtStartOfNode","isList","isNodeEmpty","defaultContent","createAndFill","isNodeSelection","NodeSelection","posToDOMRect","resolvedEnd","coordsAtPos","top","bottom","left","right","width","height","x","y","canSetMark","newMarkType","cursor","currentMarks","_ref51","someNodeSupportsMark","inlineContent","allowsMarkType","_pos","isInline","parentAllowsMarkType","currentMarksAllowMarkType","otherMark","setMark","_ref52","addStoredMark","trimmedFrom","trimmedTo","someHasMark","_ref53","setNode","_ref54","_ref55","canSetBlock","setBlockType","_ref56","updatedState","setNodeSelection","_ref57","_ref58","sinkListItem","_ref59","sinkListItem$1","ensureMarks","filteredMarks","splitBlock","keepMarks","_ref60","canSplit","deflt","indexAfter","$first","canReplaceWith","splitListItem","_ref61","sameParent","grandParent","wrap","depthBefore","d","copy","depthAfter","newNextTypeAttributes","nextType","contentMatch","append","replace","Slice","sel","n","newTypeAttributes","joinListBackwards","listType","list","nodeAt","canJoinBackwards","canJoin","joinListForwards","canJoinForwards","toggleList","listTypeOrName","itemTypeOrName","_ref62","itemType","parentList","validContent","canWrapInList","wrapInList","toggleMark","_ref63","extendEmptyMarkRange","unsetMark","toggleNode","toggleTypeOrName","_ref64","toggleType","toggleWrap","_ref65","wrapIn","undoInputRule","_ref66","undoable","getState","toUndo","j","docs","unsetAllMarks","_ref67","removeMark","_ref68","removeStoredMark","updateAttributes","_ref69","_ref70","wrapIn$1","_ref71","wrapInList$1","Commands","Editable","editable","FocusEvents","isFocused","Keymap","handleBackspace","_ref72","_ref73","parentIsIsolating","parentPos","isAtStart","handleDelete","_ref74","handleEnter","_ref75","baseKeymap","Enter","Mod-Enter","Backspace","Delete","Mod-a","pcKeymap","macKeymap","Ctrl-a","Ctrl-e","newState","docChanges","allFrom","allEnd","allWasSelected","isEmpty","Tabindex","isEditable","tabindex","createStyleTag","nonce","suffix","tiptapStyleTag","querySelector","styleNode","setAttribute","getElementsByTagName","Editor","element","injectCSS","injectNonce","autofocus","editorProps","enableCoreExtensions","isCapturingTransaction","setOptions","createExtensionManager","createCommandManager","createSchema","createView","commandManager","css","setProps","updateState","setEditable","registerPlugin","handlePlugins","unregisterPlugin","nameOrPluginKey","coreExtensions","values","allExtensions","EditorView","dispatchTransaction","EditorState","createNodeViews","prependClass","className","selectionHasChanged","nameOrAttributes","attributesOrUndefined","getJSON","getHTML","getCharacterCount","docView","markInputRule","_ref76","captureGroup","fullMatch","startSpaces","search","textStart","textEnd","excludedMarks","excluded","markEnd","nodeInputRule","_ref77","newNode","lastIndexOf","matchStart","lastChar","textblockTypeInputRule","_ref78","$start","textInputRule","_ref79","cutOff","wrappingInputRule","_ref80","wrapping","findWrapping","keepAttributes","joinPredicate","_ref81","currentPos","isAtEnd","isInMark","m","Node","isAndroid","NodeView","component","isDragging","stopEvent","ignoreMutation","mount","contentDOM","onDragStart","dragHandle","closest","domBox","getBoundingClientRect","handleBox","offsetX","_c","_d","nativeEvent","offsetY","_e","_f","_g","dataTransfer","setDragImage","isInElement","isDragEvent","isDropEvent","isInput","tagName","isContentEditable","isDraggable","isSelectable","isCopyEvent","isPasteEvent","isCutEvent","isClickEvent","preventDefault","isValidDragHandle","once","mutation","isLeaf","isAtom","changedNodes","addedNodes","removedNodes","_ref82","markPasteRule","_ref83","escapeForRegEx","string","isString","nodePasteRule","_ref84","textPasteRule","_ref85","Tracker","currentStep","deleted","mappedPosition","newPosition","mapResult","getMap"],"sources":["/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/createChainableState.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/CommandManager.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/EventEmitter.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getExtensionField.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/splitExtensions.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getAttributesFromExtensions.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getNodeType.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/mergeAttributes.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getRenderedAttributes.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/isFunction.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/callOrReturn.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/isEmptyObject.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/fromString.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/injectExtensionAttributesToParseRule.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getSchemaByResolvedExtensions.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getSchemaTypeByName.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/isExtensionRulesEnabled.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getTextContentFromNodes.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/isRegExp.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/InputRule.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/isNumber.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/PasteRule.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/findDuplicates.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/ExtensionManager.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/isPlainObject.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/mergeDeep.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/Extension.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getTextBetween.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getTextSerializersFromSchema.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/extensions/clipboardTextSerializer.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/blur.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/clearContent.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/clearNodes.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/command.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/createParagraphNear.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/cut.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/deleteCurrentNode.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/deleteNode.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/deleteRange.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/deleteSelection.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/enter.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/exitCode.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/objectIncludes.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getMarkRange.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getMarkType.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/extendMarkRange.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/first.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/isTextSelection.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/minMax.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/resolveFocusPosition.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/isiOS.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/focus.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/forEach.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/insertContent.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/elementFromString.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/createNodeFromContent.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/selectionToInsertionEnd.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/insertContentAt.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/join.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/joinItemBackward.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/joinItemForward.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/isMacOS.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/keyboardShortcut.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/isNodeActive.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/lift.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/liftEmptyBlock.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/liftListItem.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/newlineInCode.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getSchemaTypeNameByName.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/deleteProps.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/resetAttributes.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/scrollIntoView.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/selectAll.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/selectNodeBackward.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/selectNodeForward.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/selectParentNode.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/selectTextblockEnd.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/selectTextblockStart.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/createDocument.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/setContent.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getMarkAttributes.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/combineTransactionSteps.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/defaultBlockAt.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/findChildren.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/findChildrenInRange.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/findParentNodeClosestToPos.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/findParentNode.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getHTMLFromFragment.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getSchema.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/generateHTML.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/generateJSON.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getText.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/generateText.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getNodeAttributes.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getAttributes.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/removeDuplicates.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getChangedRanges.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getDebugJSON.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getMarksBetween.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getNodeAtPosition.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/getSplittedAttributes.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/isMarkActive.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/isActive.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/isAtEndOfNode.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/isAtStartOfNode.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/isList.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/isNodeEmpty.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/isNodeSelection.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/helpers/posToDOMRect.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/setMark.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/setMeta.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/setNode.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/setNodeSelection.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/setTextSelection.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/sinkListItem.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/splitBlock.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/splitListItem.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/toggleList.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/toggleMark.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/toggleNode.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/toggleWrap.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/undoInputRule.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/unsetAllMarks.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/unsetMark.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/updateAttributes.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/wrapIn.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/commands/wrapInList.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/extensions/commands.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/extensions/editable.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/extensions/focusEvents.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/extensions/keymap.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/extensions/tabindex.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/style.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/createStyleTag.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/Editor.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/inputRules/markInputRule.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/inputRules/nodeInputRule.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/inputRules/textblockTypeInputRule.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/inputRules/textInputRule.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/inputRules/wrappingInputRule.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/Mark.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/Node.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/isAndroid.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/NodeView.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/pasteRules/markPasteRule.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/escapeForRegEx.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/utilities/isString.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/pasteRules/nodePasteRule.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/pasteRules/textPasteRule.ts","/home/vinayak/Projects/websocket/ui/websocket_ui/node_modules/@tiptap/core/src/Tracker.ts"],"sourcesContent":["import { EditorState, Transaction } from '@tiptap/pm/state'\n\nexport function createChainableState(config: {\n  transaction: Transaction\n  state: EditorState\n}): EditorState {\n  const { state, transaction } = config\n  let { selection } = transaction\n  let { doc } = transaction\n  let { storedMarks } = transaction\n\n  return {\n    ...state,\n    apply: state.apply.bind(state),\n    applyTransaction: state.applyTransaction.bind(state),\n    filterTransaction: state.filterTransaction,\n    plugins: state.plugins,\n    schema: state.schema,\n    reconfigure: state.reconfigure.bind(state),\n    toJSON: state.toJSON.bind(state),\n    get storedMarks() {\n      return storedMarks\n    },\n    get selection() {\n      return selection\n    },\n    get doc() {\n      return doc\n    },\n    get tr() {\n      selection = transaction.selection\n      doc = transaction.doc\n      storedMarks = transaction.storedMarks\n\n      return transaction\n    },\n  }\n}\n","import { EditorState, Transaction } from '@tiptap/pm/state'\n\nimport { Editor } from './Editor.js'\nimport { createChainableState } from './helpers/createChainableState.js'\nimport {\n  AnyCommands, CanCommands, ChainedCommands, CommandProps, SingleCommands,\n} from './types.js'\n\nexport class CommandManager {\n  editor: Editor\n\n  rawCommands: AnyCommands\n\n  customState?: EditorState\n\n  constructor(props: { editor: Editor; state?: EditorState }) {\n    this.editor = props.editor\n    this.rawCommands = this.editor.extensionManager.commands\n    this.customState = props.state\n  }\n\n  get hasCustomState(): boolean {\n    return !!this.customState\n  }\n\n  get state(): EditorState {\n    return this.customState || this.editor.state\n  }\n\n  get commands(): SingleCommands {\n    const { rawCommands, editor, state } = this\n    const { view } = editor\n    const { tr } = state\n    const props = this.buildProps(tr)\n\n    return Object.fromEntries(\n      Object.entries(rawCommands).map(([name, command]) => {\n        const method = (...args: any[]) => {\n          const callback = command(...args)(props)\n\n          if (!tr.getMeta('preventDispatch') && !this.hasCustomState) {\n            view.dispatch(tr)\n          }\n\n          return callback\n        }\n\n        return [name, method]\n      }),\n    ) as unknown as SingleCommands\n  }\n\n  get chain(): () => ChainedCommands {\n    return () => this.createChain()\n  }\n\n  get can(): () => CanCommands {\n    return () => this.createCan()\n  }\n\n  public createChain(startTr?: Transaction, shouldDispatch = true): ChainedCommands {\n    const { rawCommands, editor, state } = this\n    const { view } = editor\n    const callbacks: boolean[] = []\n    const hasStartTransaction = !!startTr\n    const tr = startTr || state.tr\n\n    const run = () => {\n      if (\n        !hasStartTransaction\n        && shouldDispatch\n        && !tr.getMeta('preventDispatch')\n        && !this.hasCustomState\n      ) {\n        view.dispatch(tr)\n      }\n\n      return callbacks.every(callback => callback === true)\n    }\n\n    const chain = {\n      ...Object.fromEntries(\n        Object.entries(rawCommands).map(([name, command]) => {\n          const chainedCommand = (...args: never[]) => {\n            const props = this.buildProps(tr, shouldDispatch)\n            const callback = command(...args)(props)\n\n            callbacks.push(callback)\n\n            return chain\n          }\n\n          return [name, chainedCommand]\n        }),\n      ),\n      run,\n    } as unknown as ChainedCommands\n\n    return chain\n  }\n\n  public createCan(startTr?: Transaction): CanCommands {\n    const { rawCommands, state } = this\n    const dispatch = false\n    const tr = startTr || state.tr\n    const props = this.buildProps(tr, dispatch)\n    const formattedCommands = Object.fromEntries(\n      Object.entries(rawCommands).map(([name, command]) => {\n        return [name, (...args: never[]) => command(...args)({ ...props, dispatch: undefined })]\n      }),\n    ) as unknown as SingleCommands\n\n    return {\n      ...formattedCommands,\n      chain: () => this.createChain(tr, dispatch),\n    } as CanCommands\n  }\n\n  public buildProps(tr: Transaction, shouldDispatch = true): CommandProps {\n    const { rawCommands, editor, state } = this\n    const { view } = editor\n\n    const props: CommandProps = {\n      tr,\n      editor,\n      view,\n      state: createChainableState({\n        state,\n        transaction: tr,\n      }),\n      dispatch: shouldDispatch ? () => undefined : undefined,\n      chain: () => this.createChain(tr, shouldDispatch),\n      can: () => this.createCan(tr),\n      get commands() {\n        return Object.fromEntries(\n          Object.entries(rawCommands).map(([name, command]) => {\n            return [name, (...args: never[]) => command(...args)(props)]\n          }),\n        ) as unknown as SingleCommands\n      },\n    }\n\n    return props\n  }\n}\n","type StringKeyOf<T> = Extract<keyof T, string>\ntype CallbackType<\n  T extends Record<string, any>,\n  EventName extends StringKeyOf<T>,\n> = T[EventName] extends any[] ? T[EventName] : [T[EventName]]\ntype CallbackFunction<\n  T extends Record<string, any>,\n  EventName extends StringKeyOf<T>,\n> = (...props: CallbackType<T, EventName>) => any\n\nexport class EventEmitter<T extends Record<string, any>> {\n\n  private callbacks: { [key: string]: Function[] } = {}\n\n  public on<EventName extends StringKeyOf<T>>(event: EventName, fn: CallbackFunction<T, EventName>): this {\n    if (!this.callbacks[event]) {\n      this.callbacks[event] = []\n    }\n\n    this.callbacks[event].push(fn)\n\n    return this\n  }\n\n  protected emit<EventName extends StringKeyOf<T>>(event: EventName, ...args: CallbackType<T, EventName>): this {\n    const callbacks = this.callbacks[event]\n\n    if (callbacks) {\n      callbacks.forEach(callback => callback.apply(this, args))\n    }\n\n    return this\n  }\n\n  public off<EventName extends StringKeyOf<T>>(event: EventName, fn?: CallbackFunction<T, EventName>): this {\n    const callbacks = this.callbacks[event]\n\n    if (callbacks) {\n      if (fn) {\n        this.callbacks[event] = callbacks.filter(callback => callback !== fn)\n      } else {\n        delete this.callbacks[event]\n      }\n    }\n\n    return this\n  }\n\n  protected removeAllListeners(): void {\n    this.callbacks = {}\n  }\n}\n","import { AnyExtension, MaybeThisParameterType, RemoveThis } from '../types.js'\n\nexport function getExtensionField<T = any>(\n  extension: AnyExtension,\n  field: string,\n  context?: Omit<MaybeThisParameterType<T>, 'parent'>,\n): RemoveThis<T> {\n\n  if (extension.config[field] === undefined && extension.parent) {\n    return getExtensionField(extension.parent, field, context)\n  }\n\n  if (typeof extension.config[field] === 'function') {\n    const value = extension.config[field].bind({\n      ...context,\n      parent: extension.parent\n        ? getExtensionField(extension.parent, field, context)\n        : null,\n    })\n\n    return value\n  }\n\n  return extension.config[field]\n}\n","import { Extension } from '../Extension.js'\nimport { Mark } from '../Mark.js'\nimport { Node } from '../Node.js'\nimport { Extensions } from '../types.js'\n\nexport function splitExtensions(extensions: Extensions) {\n  const baseExtensions = extensions.filter(extension => extension.type === 'extension') as Extension[]\n  const nodeExtensions = extensions.filter(extension => extension.type === 'node') as Node[]\n  const markExtensions = extensions.filter(extension => extension.type === 'mark') as Mark[]\n\n  return {\n    baseExtensions,\n    nodeExtensions,\n    markExtensions,\n  }\n}\n","import { MarkConfig, NodeConfig } from '../index.js'\nimport {\n  AnyConfig,\n  Attribute,\n  Attributes,\n  ExtensionAttribute,\n  Extensions,\n  GlobalAttributes,\n} from '../types.js'\nimport { getExtensionField } from './getExtensionField.js'\nimport { splitExtensions } from './splitExtensions.js'\n\n/**\n * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.\n * @param extensions List of extensions\n */\nexport function getAttributesFromExtensions(extensions: Extensions): ExtensionAttribute[] {\n  const extensionAttributes: ExtensionAttribute[] = []\n  const { nodeExtensions, markExtensions } = splitExtensions(extensions)\n  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions]\n  const defaultAttribute: Required<Attribute> = {\n    default: null,\n    rendered: true,\n    renderHTML: null,\n    parseHTML: null,\n    keepOnSplit: true,\n    isRequired: false,\n  }\n\n  extensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n    }\n\n    const addGlobalAttributes = getExtensionField<AnyConfig['addGlobalAttributes']>(\n      extension,\n      'addGlobalAttributes',\n      context,\n    )\n\n    if (!addGlobalAttributes) {\n      return\n    }\n\n    // TODO: remove `as GlobalAttributes`\n    const globalAttributes = addGlobalAttributes() as GlobalAttributes\n\n    globalAttributes.forEach(globalAttribute => {\n      globalAttribute.types.forEach(type => {\n        Object\n          .entries(globalAttribute.attributes)\n          .forEach(([name, attribute]) => {\n            extensionAttributes.push({\n              type,\n              name,\n              attribute: {\n                ...defaultAttribute,\n                ...attribute,\n              },\n            })\n          })\n      })\n    })\n  })\n\n  nodeAndMarkExtensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n    }\n\n    const addAttributes = getExtensionField<NodeConfig['addAttributes'] | MarkConfig['addAttributes']>(\n      extension,\n      'addAttributes',\n      context,\n    )\n\n    if (!addAttributes) {\n      return\n    }\n\n    // TODO: remove `as Attributes`\n    const attributes = addAttributes() as Attributes\n\n    Object\n      .entries(attributes)\n      .forEach(([name, attribute]) => {\n        const mergedAttr = {\n          ...defaultAttribute,\n          ...attribute,\n        }\n\n        if (typeof mergedAttr?.default === 'function') {\n          mergedAttr.default = mergedAttr.default()\n        }\n\n        if (mergedAttr?.isRequired && mergedAttr?.default === undefined) {\n          delete mergedAttr.default\n        }\n\n        extensionAttributes.push({\n          type: extension.name,\n          name,\n          attribute: mergedAttr,\n        })\n      })\n  })\n\n  return extensionAttributes\n}\n","import { NodeType, Schema } from '@tiptap/pm/model'\n\nexport function getNodeType(nameOrType: string | NodeType, schema: Schema): NodeType {\n  if (typeof nameOrType === 'string') {\n    if (!schema.nodes[nameOrType]) {\n      throw Error(\n        `There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`,\n      )\n    }\n\n    return schema.nodes[nameOrType]\n  }\n\n  return nameOrType\n}\n","export function mergeAttributes(...objects: Record<string, any>[]): Record<string, any> {\n  return objects\n    .filter(item => !!item)\n    .reduce((items, item) => {\n      const mergedAttributes = { ...items }\n\n      Object.entries(item).forEach(([key, value]) => {\n        const exists = mergedAttributes[key]\n\n        if (!exists) {\n          mergedAttributes[key] = value\n\n          return\n        }\n\n        if (key === 'class') {\n          const valueClasses: string[] = value ? value.split(' ') : []\n          const existingClasses: string[] = mergedAttributes[key] ? mergedAttributes[key].split(' ') : []\n\n          const insertClasses = valueClasses.filter(\n            valueClass => !existingClasses.includes(valueClass),\n          )\n\n          mergedAttributes[key] = [...existingClasses, ...insertClasses].join(' ')\n        } else if (key === 'style') {\n          mergedAttributes[key] = [mergedAttributes[key], value].join('; ')\n        } else {\n          mergedAttributes[key] = value\n        }\n      })\n\n      return mergedAttributes\n    }, {})\n}\n","import { Mark, Node } from '@tiptap/pm/model'\n\nimport { ExtensionAttribute } from '../types.js'\nimport { mergeAttributes } from '../utilities/mergeAttributes.js'\n\nexport function getRenderedAttributes(\n  nodeOrMark: Node | Mark,\n  extensionAttributes: ExtensionAttribute[],\n): Record<string, any> {\n  return extensionAttributes\n    .filter(item => item.attribute.rendered)\n    .map(item => {\n      if (!item.attribute.renderHTML) {\n        return {\n          [item.name]: nodeOrMark.attrs[item.name],\n        }\n      }\n\n      return item.attribute.renderHTML(nodeOrMark.attrs) || {}\n    })\n    .reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {})\n}\n","export function isFunction(value: any): value is Function {\n  return typeof value === 'function'\n}\n","import { MaybeReturnType } from '../types.js'\nimport { isFunction } from './isFunction.js'\n\n/**\n * Optionally calls `value` as a function.\n * Otherwise it is returned directly.\n * @param value Function or any value.\n * @param context Optional context to bind to function.\n * @param props Optional props to pass to function.\n */\nexport function callOrReturn<T>(value: T, context: any = undefined, ...props: any[]): MaybeReturnType<T> {\n  if (isFunction(value)) {\n    if (context) {\n      return value.bind(context)(...props)\n    }\n\n    return value(...props)\n  }\n\n  return value as MaybeReturnType<T>\n}\n","export function isEmptyObject(value = {}): boolean {\n  return Object.keys(value).length === 0 && value.constructor === Object\n}\n","export function fromString(value: any): any {\n  if (typeof value !== 'string') {\n    return value\n  }\n\n  if (value.match(/^[+-]?(?:\\d*\\.)?\\d+$/)) {\n    return Number(value)\n  }\n\n  if (value === 'true') {\n    return true\n  }\n\n  if (value === 'false') {\n    return false\n  }\n\n  return value\n}\n","import { ParseRule } from '@tiptap/pm/model'\n\nimport { ExtensionAttribute } from '../types.js'\nimport { fromString } from '../utilities/fromString.js'\n\n/**\n * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).\n * Cancels when `getAttrs` returned `false`.\n * @param parseRule ProseMirror ParseRule\n * @param extensionAttributes List of attributes to inject\n */\nexport function injectExtensionAttributesToParseRule(\n  parseRule: ParseRule,\n  extensionAttributes: ExtensionAttribute[],\n): ParseRule {\n  if (parseRule.style) {\n    return parseRule\n  }\n\n  return {\n    ...parseRule,\n    getAttrs: node => {\n      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs\n\n      if (oldAttributes === false) {\n        return false\n      }\n\n      const newAttributes = extensionAttributes.reduce((items, item) => {\n        const value = item.attribute.parseHTML\n          ? item.attribute.parseHTML(node as HTMLElement)\n          : fromString((node as HTMLElement).getAttribute(item.name))\n\n        if (value === null || value === undefined) {\n          return items\n        }\n\n        return {\n          ...items,\n          [item.name]: value,\n        }\n      }, {})\n\n      return { ...oldAttributes, ...newAttributes }\n    },\n  }\n}\n","import { MarkSpec, NodeSpec, Schema } from '@tiptap/pm/model'\n\nimport { Editor, MarkConfig, NodeConfig } from '../index.js'\nimport { AnyConfig, Extensions } from '../types.js'\nimport { callOrReturn } from '../utilities/callOrReturn.js'\nimport { isEmptyObject } from '../utilities/isEmptyObject.js'\nimport { getAttributesFromExtensions } from './getAttributesFromExtensions.js'\nimport { getExtensionField } from './getExtensionField.js'\nimport { getRenderedAttributes } from './getRenderedAttributes.js'\nimport { injectExtensionAttributesToParseRule } from './injectExtensionAttributesToParseRule.js'\nimport { splitExtensions } from './splitExtensions.js'\n\nfunction cleanUpSchemaItem<T>(data: T) {\n  return Object.fromEntries(\n    // @ts-ignore\n    Object.entries(data).filter(([key, value]) => {\n      if (key === 'attrs' && isEmptyObject(value as {} | undefined)) {\n        return false\n      }\n\n      return value !== null && value !== undefined\n    }),\n  ) as T\n}\n\nexport function getSchemaByResolvedExtensions(extensions: Extensions, editor?: Editor): Schema {\n  const allAttributes = getAttributesFromExtensions(extensions)\n  const { nodeExtensions, markExtensions } = splitExtensions(extensions)\n  const topNode = nodeExtensions.find(extension => getExtensionField(extension, 'topNode'))?.name\n\n  const nodes = Object.fromEntries(\n    nodeExtensions.map(extension => {\n      const extensionAttributes = allAttributes.filter(\n        attribute => attribute.type === extension.name,\n      )\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor,\n      }\n\n      const extraNodeFields = extensions.reduce((fields, e) => {\n        const extendNodeSchema = getExtensionField<AnyConfig['extendNodeSchema']>(\n          e,\n          'extendNodeSchema',\n          context,\n        )\n\n        return {\n          ...fields,\n          ...(extendNodeSchema ? extendNodeSchema(extension) : {}),\n        }\n      }, {})\n\n      const schema: NodeSpec = cleanUpSchemaItem({\n        ...extraNodeFields,\n        content: callOrReturn(\n          getExtensionField<NodeConfig['content']>(extension, 'content', context),\n        ),\n        marks: callOrReturn(getExtensionField<NodeConfig['marks']>(extension, 'marks', context)),\n        group: callOrReturn(getExtensionField<NodeConfig['group']>(extension, 'group', context)),\n        inline: callOrReturn(getExtensionField<NodeConfig['inline']>(extension, 'inline', context)),\n        atom: callOrReturn(getExtensionField<NodeConfig['atom']>(extension, 'atom', context)),\n        selectable: callOrReturn(\n          getExtensionField<NodeConfig['selectable']>(extension, 'selectable', context),\n        ),\n        draggable: callOrReturn(\n          getExtensionField<NodeConfig['draggable']>(extension, 'draggable', context),\n        ),\n        code: callOrReturn(getExtensionField<NodeConfig['code']>(extension, 'code', context)),\n        defining: callOrReturn(\n          getExtensionField<NodeConfig['defining']>(extension, 'defining', context),\n        ),\n        isolating: callOrReturn(\n          getExtensionField<NodeConfig['isolating']>(extension, 'isolating', context),\n        ),\n        attrs: Object.fromEntries(\n          extensionAttributes.map(extensionAttribute => {\n            return [extensionAttribute.name, { default: extensionAttribute?.attribute?.default }]\n          }),\n        ),\n      })\n\n      const parseHTML = callOrReturn(\n        getExtensionField<NodeConfig['parseHTML']>(extension, 'parseHTML', context),\n      )\n\n      if (parseHTML) {\n        schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes))\n      }\n\n      const renderHTML = getExtensionField<NodeConfig['renderHTML']>(\n        extension,\n        'renderHTML',\n        context,\n      )\n\n      if (renderHTML) {\n        schema.toDOM = node => renderHTML({\n          node,\n          HTMLAttributes: getRenderedAttributes(node, extensionAttributes),\n        })\n      }\n\n      const renderText = getExtensionField<NodeConfig['renderText']>(\n        extension,\n        'renderText',\n        context,\n      )\n\n      if (renderText) {\n        schema.toText = renderText\n      }\n\n      return [extension.name, schema]\n    }),\n  )\n\n  const marks = Object.fromEntries(\n    markExtensions.map(extension => {\n      const extensionAttributes = allAttributes.filter(\n        attribute => attribute.type === extension.name,\n      )\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor,\n      }\n\n      const extraMarkFields = extensions.reduce((fields, e) => {\n        const extendMarkSchema = getExtensionField<AnyConfig['extendMarkSchema']>(\n          e,\n          'extendMarkSchema',\n          context,\n        )\n\n        return {\n          ...fields,\n          ...(extendMarkSchema ? extendMarkSchema(extension) : {}),\n        }\n      }, {})\n\n      const schema: MarkSpec = cleanUpSchemaItem({\n        ...extraMarkFields,\n        inclusive: callOrReturn(\n          getExtensionField<MarkConfig['inclusive']>(extension, 'inclusive', context),\n        ),\n        excludes: callOrReturn(\n          getExtensionField<MarkConfig['excludes']>(extension, 'excludes', context),\n        ),\n        group: callOrReturn(getExtensionField<MarkConfig['group']>(extension, 'group', context)),\n        spanning: callOrReturn(\n          getExtensionField<MarkConfig['spanning']>(extension, 'spanning', context),\n        ),\n        code: callOrReturn(getExtensionField<MarkConfig['code']>(extension, 'code', context)),\n        attrs: Object.fromEntries(\n          extensionAttributes.map(extensionAttribute => {\n            return [extensionAttribute.name, { default: extensionAttribute?.attribute?.default }]\n          }),\n        ),\n      })\n\n      const parseHTML = callOrReturn(\n        getExtensionField<MarkConfig['parseHTML']>(extension, 'parseHTML', context),\n      )\n\n      if (parseHTML) {\n        schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes))\n      }\n\n      const renderHTML = getExtensionField<MarkConfig['renderHTML']>(\n        extension,\n        'renderHTML',\n        context,\n      )\n\n      if (renderHTML) {\n        schema.toDOM = mark => renderHTML({\n          mark,\n          HTMLAttributes: getRenderedAttributes(mark, extensionAttributes),\n        })\n      }\n\n      return [extension.name, schema]\n    }),\n  )\n\n  return new Schema({\n    topNode,\n    nodes,\n    marks,\n  })\n}\n","import { MarkType, NodeType, Schema } from '@tiptap/pm/model'\n\nexport function getSchemaTypeByName(name: string, schema: Schema): NodeType | MarkType | null {\n  return schema.nodes[name] || schema.marks[name] || null\n}\n","import { AnyExtension, EnableRules } from '../types.js'\n\nexport function isExtensionRulesEnabled(extension: AnyExtension, enabled: EnableRules): boolean {\n  if (Array.isArray(enabled)) {\n    return enabled.some(enabledExtension => {\n      const name = typeof enabledExtension === 'string'\n        ? enabledExtension\n        : enabledExtension.name\n\n      return name === extension.name\n    })\n  }\n\n  return enabled\n}\n","import { ResolvedPos } from '@tiptap/pm/model'\n\nexport const getTextContentFromNodes = ($from: ResolvedPos, maxMatch = 500) => {\n  let textBefore = ''\n\n  const sliceEndPos = $from.parentOffset\n\n  $from.parent.nodesBetween(\n    Math.max(0, sliceEndPos - maxMatch),\n    sliceEndPos,\n    (node, pos, parent, index) => {\n      const chunk = node.type.spec.toText?.({\n        node,\n        pos,\n        parent,\n        index,\n      })\n        || node.textContent\n        || '%leaf%'\n\n      textBefore += chunk.slice(0, Math.max(0, sliceEndPos - pos))\n    },\n  )\n\n  return textBefore\n}\n","export function isRegExp(value: any): value is RegExp {\n  return Object.prototype.toString.call(value) === '[object RegExp]'\n}\n","import { EditorState, Plugin, TextSelection } from '@tiptap/pm/state'\n\nimport { CommandManager } from './CommandManager.js'\nimport { Editor } from './Editor.js'\nimport { createChainableState } from './helpers/createChainableState.js'\nimport { getTextContentFromNodes } from './helpers/getTextContentFromNodes.js'\nimport {\n  CanCommands,\n  ChainedCommands,\n  ExtendedRegExpMatchArray,\n  Range,\n  SingleCommands,\n} from './types.js'\nimport { isRegExp } from './utilities/isRegExp.js'\n\nexport type InputRuleMatch = {\n  index: number\n  text: string\n  replaceWith?: string\n  match?: RegExpMatchArray\n  data?: Record<string, any>\n}\n\nexport type InputRuleFinder = RegExp | ((text: string) => InputRuleMatch | null)\n\nexport class InputRule {\n  find: InputRuleFinder\n\n  handler: (props: {\n    state: EditorState\n    range: Range\n    match: ExtendedRegExpMatchArray\n    commands: SingleCommands\n    chain: () => ChainedCommands\n    can: () => CanCommands\n  }) => void | null\n\n  constructor(config: {\n    find: InputRuleFinder\n    handler: (props: {\n      state: EditorState\n      range: Range\n      match: ExtendedRegExpMatchArray\n      commands: SingleCommands\n      chain: () => ChainedCommands\n      can: () => CanCommands\n    }) => void | null\n  }) {\n    this.find = config.find\n    this.handler = config.handler\n  }\n}\n\nconst inputRuleMatcherHandler = (\n  text: string,\n  find: InputRuleFinder,\n): ExtendedRegExpMatchArray | null => {\n  if (isRegExp(find)) {\n    return find.exec(text)\n  }\n\n  const inputRuleMatch = find(text)\n\n  if (!inputRuleMatch) {\n    return null\n  }\n\n  const result: ExtendedRegExpMatchArray = [inputRuleMatch.text]\n\n  result.index = inputRuleMatch.index\n  result.input = text\n  result.data = inputRuleMatch.data\n\n  if (inputRuleMatch.replaceWith) {\n    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {\n      console.warn(\n        '[tiptap warn]: \"inputRuleMatch.replaceWith\" must be part of \"inputRuleMatch.text\".',\n      )\n    }\n\n    result.push(inputRuleMatch.replaceWith)\n  }\n\n  return result\n}\n\nfunction run(config: {\n  editor: Editor\n  from: number\n  to: number\n  text: string\n  rules: InputRule[]\n  plugin: Plugin\n}): boolean {\n  const {\n    editor, from, to, text, rules, plugin,\n  } = config\n  const { view } = editor\n\n  if (view.composing) {\n    return false\n  }\n\n  const $from = view.state.doc.resolve(from)\n\n  if (\n    // check for code node\n    $from.parent.type.spec.code\n    // check for code mark\n    || !!($from.nodeBefore || $from.nodeAfter)?.marks.find(mark => mark.type.spec.code)\n  ) {\n    return false\n  }\n\n  let matched = false\n\n  const textBefore = getTextContentFromNodes($from) + text\n\n  rules.forEach(rule => {\n    if (matched) {\n      return\n    }\n\n    const match = inputRuleMatcherHandler(textBefore, rule.find)\n\n    if (!match) {\n      return\n    }\n\n    const tr = view.state.tr\n    const state = createChainableState({\n      state: view.state,\n      transaction: tr,\n    })\n    const range = {\n      from: from - (match[0].length - text.length),\n      to,\n    }\n\n    const { commands, chain, can } = new CommandManager({\n      editor,\n      state,\n    })\n\n    const handler = rule.handler({\n      state,\n      range,\n      match,\n      commands,\n      chain,\n      can,\n    })\n\n    // stop if there are no changes\n    if (handler === null || !tr.steps.length) {\n      return\n    }\n\n    // store transform as meta data\n    // so we can undo input rules within the `undoInputRules` command\n    tr.setMeta(plugin, {\n      transform: tr,\n      from,\n      to,\n      text,\n    })\n\n    view.dispatch(tr)\n    matched = true\n  })\n\n  return matched\n}\n\n/**\n * Create an input rules plugin. When enabled, it will cause text\n * input that matches any of the given rules to trigger the rule’s\n * action.\n */\nexport function inputRulesPlugin(props: { editor: Editor; rules: InputRule[] }): Plugin {\n  const { editor, rules } = props\n  const plugin = new Plugin({\n    state: {\n      init() {\n        return null\n      },\n      apply(tr, prev) {\n        const stored = tr.getMeta(plugin)\n\n        if (stored) {\n          return stored\n        }\n\n        return tr.selectionSet || tr.docChanged ? null : prev\n      },\n    },\n\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run({\n          editor,\n          from,\n          to,\n          text,\n          rules,\n          plugin,\n        })\n      },\n\n      handleDOMEvents: {\n        compositionend: view => {\n          setTimeout(() => {\n            const { $cursor } = view.state.selection as TextSelection\n\n            if ($cursor) {\n              run({\n                editor,\n                from: $cursor.pos,\n                to: $cursor.pos,\n                text: '',\n                rules,\n                plugin,\n              })\n            }\n          })\n\n          return false\n        },\n      },\n\n      // add support for input rules to trigger on enter\n      // this is useful for example for code blocks\n      handleKeyDown(view, event) {\n        if (event.key !== 'Enter') {\n          return false\n        }\n\n        const { $cursor } = view.state.selection as TextSelection\n\n        if ($cursor) {\n          return run({\n            editor,\n            from: $cursor.pos,\n            to: $cursor.pos,\n            text: '\\n',\n            rules,\n            plugin,\n          })\n        }\n\n        return false\n      },\n    },\n\n    // @ts-ignore\n    isInputRules: true,\n  }) as Plugin\n\n  return plugin\n}\n","export function isNumber(value: any): value is number {\n  return typeof value === 'number'\n}\n","import { EditorState, Plugin } from '@tiptap/pm/state'\n\nimport { CommandManager } from './CommandManager.js'\nimport { Editor } from './Editor.js'\nimport { createChainableState } from './helpers/createChainableState.js'\nimport {\n  CanCommands,\n  ChainedCommands,\n  ExtendedRegExpMatchArray,\n  Range,\n  SingleCommands,\n} from './types.js'\nimport { isNumber } from './utilities/isNumber.js'\nimport { isRegExp } from './utilities/isRegExp.js'\n\nexport type PasteRuleMatch = {\n  index: number\n  text: string\n  replaceWith?: string\n  match?: RegExpMatchArray\n  data?: Record<string, any>\n}\n\nexport type PasteRuleFinder = RegExp | ((text: string) => PasteRuleMatch[] | null | undefined)\n\nexport class PasteRule {\n  find: PasteRuleFinder\n\n  handler: (props: {\n    state: EditorState\n    range: Range\n    match: ExtendedRegExpMatchArray\n    commands: SingleCommands\n    chain: () => ChainedCommands\n    can: () => CanCommands\n    pasteEvent: ClipboardEvent\n    dropEvent: DragEvent\n  }) => void | null\n\n  constructor(config: {\n    find: PasteRuleFinder\n    handler: (props: {\n      can: () => CanCommands\n      chain: () => ChainedCommands\n      commands: SingleCommands\n      dropEvent: DragEvent\n      match: ExtendedRegExpMatchArray\n      pasteEvent: ClipboardEvent\n      range: Range\n      state: EditorState\n    }) => void | null\n  }) {\n    this.find = config.find\n    this.handler = config.handler\n  }\n}\n\nconst pasteRuleMatcherHandler = (\n  text: string,\n  find: PasteRuleFinder,\n): ExtendedRegExpMatchArray[] => {\n  if (isRegExp(find)) {\n    return [...text.matchAll(find)]\n  }\n\n  const matches = find(text)\n\n  if (!matches) {\n    return []\n  }\n\n  return matches.map(pasteRuleMatch => {\n    const result: ExtendedRegExpMatchArray = [pasteRuleMatch.text]\n\n    result.index = pasteRuleMatch.index\n    result.input = text\n    result.data = pasteRuleMatch.data\n\n    if (pasteRuleMatch.replaceWith) {\n      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {\n        console.warn(\n          '[tiptap warn]: \"pasteRuleMatch.replaceWith\" must be part of \"pasteRuleMatch.text\".',\n        )\n      }\n\n      result.push(pasteRuleMatch.replaceWith)\n    }\n\n    return result\n  })\n}\n\nfunction run(config: {\n  editor: Editor\n  state: EditorState\n  from: number\n  to: number\n  rule: PasteRule\n  pasteEvent: ClipboardEvent\n  dropEvent: DragEvent\n}): boolean {\n  const {\n    editor, state, from, to, rule, pasteEvent, dropEvent,\n  } = config\n\n  const { commands, chain, can } = new CommandManager({\n    editor,\n    state,\n  })\n\n  const handlers: (void | null)[] = []\n\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isTextblock || node.type.spec.code) {\n      return\n    }\n\n    const resolvedFrom = Math.max(from, pos)\n    const resolvedTo = Math.min(to, pos + node.content.size)\n    const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, undefined, '\\ufffc')\n\n    const matches = pasteRuleMatcherHandler(textToMatch, rule.find)\n\n    matches.forEach(match => {\n      if (match.index === undefined) {\n        return\n      }\n\n      const start = resolvedFrom + match.index + 1\n      const end = start + match[0].length\n      const range = {\n        from: state.tr.mapping.map(start),\n        to: state.tr.mapping.map(end),\n      }\n\n      const handler = rule.handler({\n        state,\n        range,\n        match,\n        commands,\n        chain,\n        can,\n        pasteEvent,\n        dropEvent,\n      })\n\n      handlers.push(handler)\n    })\n  })\n\n  const success = handlers.every(handler => handler !== null)\n\n  return success\n}\n\n/**\n * Create an paste rules plugin. When enabled, it will cause pasted\n * text that matches any of the given rules to trigger the rule’s\n * action.\n */\nexport function pasteRulesPlugin(props: { editor: Editor; rules: PasteRule[] }): Plugin[] {\n  const { editor, rules } = props\n  let dragSourceElement: Element | null = null\n  let isPastedFromProseMirror = false\n  let isDroppedFromProseMirror = false\n  let pasteEvent = new ClipboardEvent('paste')\n  let dropEvent = new DragEvent('drop')\n\n  const plugins = rules.map(rule => {\n    return new Plugin({\n      // we register a global drag handler to track the current drag source element\n      view(view) {\n        const handleDragstart = (event: DragEvent) => {\n          dragSourceElement = view.dom.parentElement?.contains(event.target as Element)\n            ? view.dom.parentElement\n            : null\n        }\n\n        window.addEventListener('dragstart', handleDragstart)\n\n        return {\n          destroy() {\n            window.removeEventListener('dragstart', handleDragstart)\n          },\n        }\n      },\n\n      props: {\n        handleDOMEvents: {\n          drop: (view, event: Event) => {\n            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement\n            dropEvent = event as DragEvent\n\n            return false\n          },\n\n          paste: (_view, event: Event) => {\n            const html = (event as ClipboardEvent).clipboardData?.getData('text/html')\n\n            pasteEvent = event as ClipboardEvent\n\n            isPastedFromProseMirror = !!html?.includes('data-pm-slice')\n\n            return false\n          },\n        },\n      },\n\n      appendTransaction: (transactions, oldState, state) => {\n        const transaction = transactions[0]\n        const isPaste = transaction.getMeta('uiEvent') === 'paste' && !isPastedFromProseMirror\n        const isDrop = transaction.getMeta('uiEvent') === 'drop' && !isDroppedFromProseMirror\n\n        if (!isPaste && !isDrop) {\n          return\n        }\n\n        // stop if there is no changed range\n        const from = oldState.doc.content.findDiffStart(state.doc.content)\n        const to = oldState.doc.content.findDiffEnd(state.doc.content)\n\n        if (!isNumber(from) || !to || from === to.b) {\n          return\n        }\n\n        // build a chainable state\n        // so we can use a single transaction for all paste rules\n        const tr = state.tr\n        const chainableState = createChainableState({\n          state,\n          transaction: tr,\n        })\n\n        const handler = run({\n          editor,\n          state: chainableState,\n          from: Math.max(from - 1, 0),\n          to: to.b - 1,\n          rule,\n          pasteEvent,\n          dropEvent,\n        })\n\n        // stop if there are no changes\n        if (!handler || !tr.steps.length) {\n          return\n        }\n\n        dropEvent = new DragEvent('drop')\n        pasteEvent = new ClipboardEvent('paste')\n\n        return tr\n      },\n    })\n  })\n\n  return plugins\n}\n","export function findDuplicates(items: any[]): any[] {\n  const filtered = items.filter((el, index) => items.indexOf(el) !== index)\n\n  return [...new Set(filtered)]\n}\n","import { keymap } from '@tiptap/pm/keymap'\nimport { Node as ProsemirrorNode, Schema } from '@tiptap/pm/model'\nimport { Plugin } from '@tiptap/pm/state'\nimport { Decoration, EditorView } from '@tiptap/pm/view'\n\nimport { Editor } from './Editor.js'\nimport { getAttributesFromExtensions } from './helpers/getAttributesFromExtensions.js'\nimport { getExtensionField } from './helpers/getExtensionField.js'\nimport { getNodeType } from './helpers/getNodeType.js'\nimport { getRenderedAttributes } from './helpers/getRenderedAttributes.js'\nimport { getSchemaByResolvedExtensions } from './helpers/getSchemaByResolvedExtensions.js'\nimport { getSchemaTypeByName } from './helpers/getSchemaTypeByName.js'\nimport { isExtensionRulesEnabled } from './helpers/isExtensionRulesEnabled.js'\nimport { splitExtensions } from './helpers/splitExtensions.js'\nimport { Mark, NodeConfig } from './index.js'\nimport { inputRulesPlugin } from './InputRule.js'\nimport { pasteRulesPlugin } from './PasteRule.js'\nimport { AnyConfig, Extensions, RawCommands } from './types.js'\nimport { callOrReturn } from './utilities/callOrReturn.js'\nimport { findDuplicates } from './utilities/findDuplicates.js'\n\nexport class ExtensionManager {\n  editor: Editor\n\n  schema: Schema\n\n  extensions: Extensions\n\n  splittableMarks: string[] = []\n\n  constructor(extensions: Extensions, editor: Editor) {\n    this.editor = editor\n    this.extensions = ExtensionManager.resolve(extensions)\n    this.schema = getSchemaByResolvedExtensions(this.extensions, editor)\n\n    this.extensions.forEach(extension => {\n      // store extension storage in editor\n      this.editor.extensionStorage[extension.name] = extension.storage\n\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema),\n      }\n\n      if (extension.type === 'mark') {\n        const keepOnSplit = callOrReturn(getExtensionField(extension, 'keepOnSplit', context)) ?? true\n\n        if (keepOnSplit) {\n          this.splittableMarks.push(extension.name)\n        }\n      }\n\n      const onBeforeCreate = getExtensionField<AnyConfig['onBeforeCreate']>(\n        extension,\n        'onBeforeCreate',\n        context,\n      )\n\n      if (onBeforeCreate) {\n        this.editor.on('beforeCreate', onBeforeCreate)\n      }\n\n      const onCreate = getExtensionField<AnyConfig['onCreate']>(extension, 'onCreate', context)\n\n      if (onCreate) {\n        this.editor.on('create', onCreate)\n      }\n\n      const onUpdate = getExtensionField<AnyConfig['onUpdate']>(extension, 'onUpdate', context)\n\n      if (onUpdate) {\n        this.editor.on('update', onUpdate)\n      }\n\n      const onSelectionUpdate = getExtensionField<AnyConfig['onSelectionUpdate']>(\n        extension,\n        'onSelectionUpdate',\n        context,\n      )\n\n      if (onSelectionUpdate) {\n        this.editor.on('selectionUpdate', onSelectionUpdate)\n      }\n\n      const onTransaction = getExtensionField<AnyConfig['onTransaction']>(\n        extension,\n        'onTransaction',\n        context,\n      )\n\n      if (onTransaction) {\n        this.editor.on('transaction', onTransaction)\n      }\n\n      const onFocus = getExtensionField<AnyConfig['onFocus']>(extension, 'onFocus', context)\n\n      if (onFocus) {\n        this.editor.on('focus', onFocus)\n      }\n\n      const onBlur = getExtensionField<AnyConfig['onBlur']>(extension, 'onBlur', context)\n\n      if (onBlur) {\n        this.editor.on('blur', onBlur)\n      }\n\n      const onDestroy = getExtensionField<AnyConfig['onDestroy']>(extension, 'onDestroy', context)\n\n      if (onDestroy) {\n        this.editor.on('destroy', onDestroy)\n      }\n    })\n  }\n\n  static resolve(extensions: Extensions): Extensions {\n    const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions))\n    const duplicatedNames = findDuplicates(resolvedExtensions.map(extension => extension.name))\n\n    if (duplicatedNames.length) {\n      console.warn(\n        `[tiptap warn]: Duplicate extension names found: [${duplicatedNames\n          .map(item => `'${item}'`)\n          .join(', ')}]. This can lead to issues.`,\n      )\n    }\n\n    return resolvedExtensions\n  }\n\n  static flatten(extensions: Extensions): Extensions {\n    return (\n      extensions\n        .map(extension => {\n          const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n          }\n\n          const addExtensions = getExtensionField<AnyConfig['addExtensions']>(\n            extension,\n            'addExtensions',\n            context,\n          )\n\n          if (addExtensions) {\n            return [extension, ...this.flatten(addExtensions())]\n          }\n\n          return extension\n        })\n        // `Infinity` will break TypeScript so we set a number that is probably high enough\n        .flat(10)\n    )\n  }\n\n  static sort(extensions: Extensions): Extensions {\n    const defaultPriority = 100\n\n    return extensions.sort((a, b) => {\n      const priorityA = getExtensionField<AnyConfig['priority']>(a, 'priority') || defaultPriority\n      const priorityB = getExtensionField<AnyConfig['priority']>(b, 'priority') || defaultPriority\n\n      if (priorityA > priorityB) {\n        return -1\n      }\n\n      if (priorityA < priorityB) {\n        return 1\n      }\n\n      return 0\n    })\n  }\n\n  get commands(): RawCommands {\n    return this.extensions.reduce((commands, extension) => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema),\n      }\n\n      const addCommands = getExtensionField<AnyConfig['addCommands']>(\n        extension,\n        'addCommands',\n        context,\n      )\n\n      if (!addCommands) {\n        return commands\n      }\n\n      return {\n        ...commands,\n        ...addCommands(),\n      }\n    }, {} as RawCommands)\n  }\n\n  get plugins(): Plugin[] {\n    const { editor } = this\n\n    // With ProseMirror, first plugins within an array are executed first.\n    // In Tiptap, we provide the ability to override plugins,\n    // so it feels more natural to run plugins at the end of an array first.\n    // That’s why we have to reverse the `extensions` array and sort again\n    // based on the `priority` option.\n    const extensions = ExtensionManager.sort([...this.extensions].reverse())\n\n    const inputRules: any[] = []\n    const pasteRules: any[] = []\n\n    const allPlugins = extensions\n      .map(extension => {\n        const context = {\n          name: extension.name,\n          options: extension.options,\n          storage: extension.storage,\n          editor,\n          type: getSchemaTypeByName(extension.name, this.schema),\n        }\n\n        const plugins: Plugin[] = []\n\n        const addKeyboardShortcuts = getExtensionField<AnyConfig['addKeyboardShortcuts']>(\n          extension,\n          'addKeyboardShortcuts',\n          context,\n        )\n\n        let defaultBindings: Record<string, () => boolean> = {}\n\n        // bind exit handling\n        if (extension.type === 'mark' && extension.config.exitable) {\n          defaultBindings.ArrowRight = () => Mark.handleExit({ editor, mark: extension as Mark })\n        }\n\n        if (addKeyboardShortcuts) {\n          const bindings = Object.fromEntries(\n            Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {\n              return [shortcut, () => method({ editor })]\n            }),\n          )\n\n          defaultBindings = { ...defaultBindings, ...bindings }\n        }\n\n        const keyMapPlugin = keymap(defaultBindings)\n\n        plugins.push(keyMapPlugin)\n\n        const addInputRules = getExtensionField<AnyConfig['addInputRules']>(\n          extension,\n          'addInputRules',\n          context,\n        )\n\n        if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {\n          inputRules.push(...addInputRules())\n        }\n\n        const addPasteRules = getExtensionField<AnyConfig['addPasteRules']>(\n          extension,\n          'addPasteRules',\n          context,\n        )\n\n        if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {\n          pasteRules.push(...addPasteRules())\n        }\n\n        const addProseMirrorPlugins = getExtensionField<AnyConfig['addProseMirrorPlugins']>(\n          extension,\n          'addProseMirrorPlugins',\n          context,\n        )\n\n        if (addProseMirrorPlugins) {\n          const proseMirrorPlugins = addProseMirrorPlugins()\n\n          plugins.push(...proseMirrorPlugins)\n        }\n\n        return plugins\n      })\n      .flat()\n\n    return [\n      inputRulesPlugin({\n        editor,\n        rules: inputRules,\n      }),\n      ...pasteRulesPlugin({\n        editor,\n        rules: pasteRules,\n      }),\n      ...allPlugins,\n    ]\n  }\n\n  get attributes() {\n    return getAttributesFromExtensions(this.extensions)\n  }\n\n  get nodeViews() {\n    const { editor } = this\n    const { nodeExtensions } = splitExtensions(this.extensions)\n\n    return Object.fromEntries(\n      nodeExtensions\n        .filter(extension => !!getExtensionField(extension, 'addNodeView'))\n        .map(extension => {\n          const extensionAttributes = this.attributes.filter(\n            attribute => attribute.type === extension.name,\n          )\n          const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n            editor,\n            type: getNodeType(extension.name, this.schema),\n          }\n          const addNodeView = getExtensionField<NodeConfig['addNodeView']>(\n            extension,\n            'addNodeView',\n            context,\n          )\n\n          if (!addNodeView) {\n            return []\n          }\n\n          const nodeview = (\n            node: ProsemirrorNode,\n            view: EditorView,\n            getPos: (() => number) | boolean,\n            decorations: Decoration[],\n          ) => {\n            const HTMLAttributes = getRenderedAttributes(node, extensionAttributes)\n\n            return addNodeView()({\n              editor,\n              node,\n              getPos,\n              decorations,\n              HTMLAttributes,\n              extension,\n            })\n          }\n\n          return [extension.name, nodeview]\n        }),\n    )\n  }\n}\n","// see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts\n\nfunction getType(value: any): string {\n  return Object.prototype.toString.call(value).slice(8, -1)\n}\n\nexport function isPlainObject(value: any): value is Record<string, any> {\n  if (getType(value) !== 'Object') {\n    return false\n  }\n\n  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype\n}\n","import { isPlainObject } from './isPlainObject.js'\n\nexport function mergeDeep(target: Record<string, any>, source: Record<string, any>): Record<string, any> {\n  const output = { ...target }\n\n  if (isPlainObject(target) && isPlainObject(source)) {\n    Object.keys(source).forEach(key => {\n      if (isPlainObject(source[key])) {\n        if (!(key in target)) {\n          Object.assign(output, { [key]: source[key] })\n        } else {\n          output[key] = mergeDeep(target[key], source[key])\n        }\n      } else {\n        Object.assign(output, { [key]: source[key] })\n      }\n    })\n  }\n\n  return output\n}\n","import { Plugin, Transaction } from '@tiptap/pm/state'\n\nimport { Editor } from './Editor.js'\nimport { getExtensionField } from './helpers/getExtensionField.js'\nimport { ExtensionConfig } from './index.js'\nimport { InputRule } from './InputRule.js'\nimport { Mark } from './Mark.js'\nimport { Node } from './Node.js'\nimport { PasteRule } from './PasteRule.js'\nimport {\n  AnyConfig,\n  Extensions,\n  GlobalAttributes,\n  KeyboardShortcutCommand,\n  ParentConfig,\n  RawCommands,\n} from './types.js'\nimport { callOrReturn } from './utilities/callOrReturn.js'\nimport { mergeDeep } from './utilities/mergeDeep.js'\n\ndeclare module '@tiptap/core' {\n  interface ExtensionConfig<Options = any, Storage = any> {\n    [key: string]: any\n\n    /**\n     * Name\n     */\n    name: string\n\n    /**\n     * Priority\n     */\n    priority?: number\n\n    /**\n     * Default options\n     */\n    defaultOptions?: Options\n\n    /**\n     * Default Options\n     */\n    addOptions?: (this: {\n      name: string\n      parent: Exclude<ParentConfig<ExtensionConfig<Options, Storage>>['addOptions'], undefined>\n    }) => Options\n\n    /**\n     * Default Storage\n     */\n    addStorage?: (this: {\n      name: string\n      options: Options\n      parent: Exclude<ParentConfig<ExtensionConfig<Options, Storage>>['addStorage'], undefined>\n    }) => Storage\n\n    /**\n     * Global attributes\n     */\n    addGlobalAttributes?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addGlobalAttributes']\n    }) => GlobalAttributes | {}\n\n    /**\n     * Raw\n     */\n    addCommands?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addCommands']\n    }) => Partial<RawCommands>\n\n    /**\n     * Keyboard shortcuts\n     */\n    addKeyboardShortcuts?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addKeyboardShortcuts']\n    }) => {\n      [key: string]: KeyboardShortcutCommand\n    }\n\n    /**\n     * Input rules\n     */\n    addInputRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addInputRules']\n    }) => InputRule[]\n\n    /**\n     * Paste rules\n     */\n    addPasteRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addPasteRules']\n    }) => PasteRule[]\n\n    /**\n     * ProseMirror plugins\n     */\n    addProseMirrorPlugins?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addProseMirrorPlugins']\n    }) => Plugin[]\n\n    /**\n     * Extensions\n     */\n    addExtensions?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addExtensions']\n    }) => Extensions\n\n    /**\n     * Extend Node Schema\n     */\n    extendNodeSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<ExtensionConfig<Options, Storage>>['extendNodeSchema']\n          },\n          extension: Node,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * Extend Mark Schema\n     */\n    extendMarkSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<ExtensionConfig<Options, Storage>>['extendMarkSchema']\n          },\n          extension: Mark,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * The editor is not ready yet.\n     */\n    onBeforeCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          parent: ParentConfig<ExtensionConfig<Options, Storage>>['onBeforeCreate']\n        }) => void)\n      | null\n\n    /**\n     * The editor is ready.\n     */\n    onCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          parent: ParentConfig<ExtensionConfig<Options, Storage>>['onCreate']\n        }) => void)\n      | null\n\n    /**\n     * The content has changed.\n     */\n    onUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          parent: ParentConfig<ExtensionConfig<Options, Storage>>['onUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The selection has changed.\n     */\n    onSelectionUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          parent: ParentConfig<ExtensionConfig<Options, Storage>>['onSelectionUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The editor state has changed.\n     */\n    onTransaction?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            parent: ParentConfig<ExtensionConfig<Options, Storage>>['onTransaction']\n          },\n          props: {\n            transaction: Transaction\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is focused.\n     */\n    onFocus?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            parent: ParentConfig<ExtensionConfig<Options, Storage>>['onFocus']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor isn’t focused anymore.\n     */\n    onBlur?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            parent: ParentConfig<ExtensionConfig<Options, Storage>>['onBlur']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is destroyed.\n     */\n    onDestroy?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          parent: ParentConfig<ExtensionConfig<Options, Storage>>['onDestroy']\n        }) => void)\n      | null\n  }\n}\n\nexport class Extension<Options = any, Storage = any> {\n  type = 'extension'\n\n  name = 'extension'\n\n  parent: Extension | null = null\n\n  child: Extension | null = null\n\n  options: Options\n\n  storage: Storage\n\n  config: ExtensionConfig = {\n    name: this.name,\n    defaultOptions: {},\n  }\n\n  constructor(config: Partial<ExtensionConfig<Options, Storage>> = {}) {\n    this.config = {\n      ...this.config,\n      ...config,\n    }\n\n    this.name = this.config.name\n\n    if (config.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`,\n      )\n    }\n\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions\n\n    if (this.config.addOptions) {\n      this.options = callOrReturn(\n        getExtensionField<AnyConfig['addOptions']>(this, 'addOptions', {\n          name: this.name,\n        }),\n      )\n    }\n\n    this.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(this, 'addStorage', {\n        name: this.name,\n        options: this.options,\n      }),\n    ) || {}\n  }\n\n  static create<O = any, S = any>(config: Partial<ExtensionConfig<O, S>> = {}) {\n    return new Extension<O, S>(config)\n  }\n\n  configure(options: Partial<Options> = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend()\n\n    extension.options = mergeDeep(this.options as Record<string, any>, options) as Options\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n\n  extend<ExtendedOptions = Options, ExtendedStorage = Storage>(\n    extendedConfig: Partial<ExtensionConfig<ExtendedOptions, ExtendedStorage>> = {},\n  ) {\n    const extension = new Extension<ExtendedOptions, ExtendedStorage>(extendedConfig)\n\n    extension.parent = this\n\n    this.child = extension\n\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name\n\n    if (extendedConfig.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`,\n      )\n    }\n\n    extension.options = callOrReturn(\n      getExtensionField<AnyConfig['addOptions']>(extension, 'addOptions', {\n        name: extension.name,\n      }),\n    )\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { Range, TextSerializer } from '../types.js'\n\nexport function getTextBetween(\n  startNode: ProseMirrorNode,\n  range: Range,\n  options?: {\n    blockSeparator?: string\n    textSerializers?: Record<string, TextSerializer>\n  },\n): string {\n  const { from, to } = range\n  const { blockSeparator = '\\n\\n', textSerializers = {} } = options || {}\n  let text = ''\n  let separated = true\n\n  startNode.nodesBetween(from, to, (node, pos, parent, index) => {\n    const textSerializer = textSerializers?.[node.type.name]\n\n    if (textSerializer) {\n      if (node.isBlock && !separated) {\n        text += blockSeparator\n        separated = true\n      }\n\n      if (parent) {\n        text += textSerializer({\n          node,\n          pos,\n          parent,\n          index,\n          range,\n        })\n      }\n    } else if (node.isText) {\n      text += node?.text?.slice(Math.max(from, pos) - pos, to - pos) // eslint-disable-line\n      separated = false\n    } else if (node.isBlock && !separated) {\n      text += blockSeparator\n      separated = true\n    }\n  })\n\n  return text\n}\n","import { Schema } from '@tiptap/pm/model'\n\nimport { TextSerializer } from '../types.js'\n\nexport function getTextSerializersFromSchema(schema: Schema): Record<string, TextSerializer> {\n  return Object.fromEntries(\n    Object.entries(schema.nodes)\n      .filter(([, node]) => node.spec.toText)\n      .map(([name, node]) => [name, node.spec.toText]),\n  )\n}\n","import { Plugin, PluginKey } from '@tiptap/pm/state'\n\nimport { Extension } from '../Extension.js'\nimport { getTextBetween } from '../helpers/getTextBetween.js'\nimport { getTextSerializersFromSchema } from '../helpers/getTextSerializersFromSchema.js'\n\nexport const ClipboardTextSerializer = Extension.create({\n  name: 'clipboardTextSerializer',\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('clipboardTextSerializer'),\n        props: {\n          clipboardTextSerializer: () => {\n            const { editor } = this\n            const { state, schema } = editor\n            const { doc, selection } = state\n            const { ranges } = selection\n            const from = Math.min(...ranges.map(range => range.$from.pos))\n            const to = Math.max(...ranges.map(range => range.$to.pos))\n            const textSerializers = getTextSerializersFromSchema(schema)\n            const range = { from, to }\n\n            return getTextBetween(doc, range, {\n              textSerializers,\n            })\n          },\n        },\n      }),\n    ]\n  },\n})\n","import { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    blur: {\n      /**\n       * Removes focus from the editor.\n       */\n      blur: () => ReturnType,\n    }\n  }\n}\n\nexport const blur: RawCommands['blur'] = () => ({ editor, view }) => {\n  requestAnimationFrame(() => {\n    if (!editor.isDestroyed) {\n      (view.dom as HTMLElement).blur()\n\n      // Browsers should remove the caret on blur but safari does not.\n      // See: https://github.com/ueberdosis/tiptap/issues/2405\n      window?.getSelection()?.removeAllRanges()\n    }\n  })\n\n  return true\n}\n","import { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    clearContent: {\n      /**\n       * Clear the whole document.\n       */\n      clearContent: (emitUpdate?: boolean) => ReturnType,\n    }\n  }\n}\n\nexport const clearContent: RawCommands['clearContent'] = (emitUpdate = false) => ({ commands }) => {\n  return commands.setContent('', emitUpdate)\n}\n","import { liftTarget } from '@tiptap/pm/transform'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    clearNodes: {\n      /**\n       * Normalize nodes to a simple paragraph.\n       */\n      clearNodes: () => ReturnType,\n    }\n  }\n}\n\nexport const clearNodes: RawCommands['clearNodes'] = () => ({ state, tr, dispatch }) => {\n  const { selection } = tr\n  const { ranges } = selection\n\n  if (!dispatch) {\n    return true\n  }\n\n  ranges.forEach(({ $from, $to }) => {\n    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n      if (node.type.isText) {\n        return\n      }\n\n      const { doc, mapping } = tr\n      const $mappedFrom = doc.resolve(mapping.map(pos))\n      const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize))\n      const nodeRange = $mappedFrom.blockRange($mappedTo)\n\n      if (!nodeRange) {\n        return\n      }\n\n      const targetLiftDepth = liftTarget(nodeRange)\n\n      if (node.type.isTextblock) {\n        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index())\n\n        tr.setNodeMarkup(nodeRange.start, defaultType)\n      }\n\n      if (targetLiftDepth || targetLiftDepth === 0) {\n        tr.lift(nodeRange, targetLiftDepth)\n      }\n    })\n  })\n\n  return true\n}\n","import { Command, RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    command: {\n      /**\n       * Define a command inline.\n       */\n      command: (fn: (props: Parameters<Command>[0]) => boolean) => ReturnType,\n    }\n  }\n}\n\nexport const command: RawCommands['command'] = fn => props => {\n  return fn(props)\n}\n","import { createParagraphNear as originalCreateParagraphNear } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    createParagraphNear: {\n      /**\n       * Create a paragraph nearby.\n       */\n      createParagraphNear: () => ReturnType\n    }\n  }\n}\n\nexport const createParagraphNear: RawCommands['createParagraphNear'] = () => ({ state, dispatch }) => {\n  return originalCreateParagraphNear(state, dispatch)\n}\n","import { TextSelection } from '@tiptap/pm/state'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    cut: {\n      /**\n       * Cuts content from a range and inserts it at a given position.\n       */\n      cut: ({ from, to }: { from: number, to: number }, targetPos: number) => ReturnType,\n    }\n  }\n}\n\nexport const cut: RawCommands['cut'] = (originRange, targetPos) => ({ editor, tr }) => {\n  const { state } = editor\n\n  const contentSlice = state.doc.slice(originRange.from, originRange.to)\n\n  tr.deleteRange(originRange.from, originRange.to)\n  const newPos = tr.mapping.map(targetPos)\n\n  tr.insert(newPos, contentSlice.content)\n\n  tr.setSelection(new TextSelection(tr.doc.resolve(newPos - 1)))\n\n  return true\n}\n","import { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    deleteCurrentNode: {\n      /**\n       * Delete the node that currently has the selection anchor.\n       */\n      deleteCurrentNode: () => ReturnType,\n    }\n  }\n}\n\nexport const deleteCurrentNode: RawCommands['deleteCurrentNode'] = () => ({ tr, dispatch }) => {\n  const { selection } = tr\n  const currentNode = selection.$anchor.node()\n\n  // if there is content inside the current node, break out of this command\n  if (currentNode.content.size > 0) {\n    return false\n  }\n\n  const $pos = tr.selection.$anchor\n\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth)\n\n    if (node.type === currentNode.type) {\n      if (dispatch) {\n        const from = $pos.before(depth)\n        const to = $pos.after(depth)\n\n        tr.delete(from, to).scrollIntoView()\n      }\n\n      return true\n    }\n  }\n\n  return false\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    deleteNode: {\n      /**\n       * Delete a node.\n       */\n      deleteNode: (typeOrName: string | NodeType) => ReturnType,\n    }\n  }\n}\n\nexport const deleteNode: RawCommands['deleteNode'] = typeOrName => ({ tr, state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const $pos = tr.selection.$anchor\n\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth)\n\n    if (node.type === type) {\n      if (dispatch) {\n        const from = $pos.before(depth)\n        const to = $pos.after(depth)\n\n        tr.delete(from, to).scrollIntoView()\n      }\n\n      return true\n    }\n  }\n\n  return false\n}\n","import { Range, RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    deleteRange: {\n      /**\n       * Delete a given range.\n       */\n      deleteRange: (range: Range) => ReturnType,\n    }\n  }\n}\n\nexport const deleteRange: RawCommands['deleteRange'] = range => ({ tr, dispatch }) => {\n  const { from, to } = range\n\n  if (dispatch) {\n    tr.delete(from, to)\n  }\n\n  return true\n}\n","import { deleteSelection as originalDeleteSelection } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    deleteSelection: {\n      /**\n       * Delete the selection, if there is one.\n       */\n      deleteSelection: () => ReturnType\n    }\n  }\n}\n\nexport const deleteSelection: RawCommands['deleteSelection'] = () => ({ state, dispatch }) => {\n  return originalDeleteSelection(state, dispatch)\n}\n","import { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    enter: {\n      /**\n       * Trigger enter.\n       */\n      enter: () => ReturnType,\n    }\n  }\n}\n\nexport const enter: RawCommands['enter'] = () => ({ commands }) => {\n  return commands.keyboardShortcut('Enter')\n}\n","import { exitCode as originalExitCode } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    exitCode: {\n      /**\n       * Exit from a code block.\n       */\n      exitCode: () => ReturnType\n    }\n  }\n}\n\nexport const exitCode: RawCommands['exitCode'] = () => ({ state, dispatch }) => {\n  return originalExitCode(state, dispatch)\n}\n","import { isRegExp } from './isRegExp.js'\n\n/**\n * Check if object1 includes object2\n * @param object1 Object\n * @param object2 Object\n */\nexport function objectIncludes(\n  object1: Record<string, any>,\n  object2: Record<string, any>,\n  options: { strict: boolean } = { strict: true },\n): boolean {\n  const keys = Object.keys(object2)\n\n  if (!keys.length) {\n    return true\n  }\n\n  return keys.every(key => {\n    if (options.strict) {\n      return object2[key] === object1[key]\n    }\n\n    if (isRegExp(object2[key])) {\n      return object2[key].test(object1[key])\n    }\n\n    return object2[key] === object1[key]\n  })\n}\n","import { Mark as ProseMirrorMark, MarkType, ResolvedPos } from '@tiptap/pm/model'\n\nimport { Range } from '../types.js'\nimport { objectIncludes } from '../utilities/objectIncludes.js'\n\nfunction findMarkInSet(\n  marks: ProseMirrorMark[],\n  type: MarkType,\n  attributes: Record<string, any> = {},\n): ProseMirrorMark | undefined {\n  return marks.find(item => {\n    return item.type === type && objectIncludes(item.attrs, attributes)\n  })\n}\n\nfunction isMarkInSet(\n  marks: ProseMirrorMark[],\n  type: MarkType,\n  attributes: Record<string, any> = {},\n): boolean {\n  return !!findMarkInSet(marks, type, attributes)\n}\n\nexport function getMarkRange(\n  $pos: ResolvedPos,\n  type: MarkType,\n  attributes: Record<string, any> = {},\n): Range | void {\n  if (!$pos || !type) {\n    return\n  }\n\n  let start = $pos.parent.childAfter($pos.parentOffset)\n\n  if ($pos.parentOffset === start.offset && start.offset !== 0) {\n    start = $pos.parent.childBefore($pos.parentOffset)\n  }\n\n  if (!start.node) {\n    return\n  }\n\n  const mark = findMarkInSet([...start.node.marks], type, attributes)\n\n  if (!mark) {\n    return\n  }\n\n  let startIndex = start.index\n  let startPos = $pos.start() + start.offset\n  let endIndex = startIndex + 1\n  let endPos = startPos + start.node.nodeSize\n\n  findMarkInSet([...start.node.marks], type, attributes)\n\n  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {\n    startIndex -= 1\n    startPos -= $pos.parent.child(startIndex).nodeSize\n  }\n\n  while (\n    endIndex < $pos.parent.childCount\n    && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)\n  ) {\n    endPos += $pos.parent.child(endIndex).nodeSize\n    endIndex += 1\n  }\n\n  return {\n    from: startPos,\n    to: endPos,\n  }\n}\n","import { MarkType, Schema } from '@tiptap/pm/model'\n\nexport function getMarkType(nameOrType: string | MarkType, schema: Schema): MarkType {\n  if (typeof nameOrType === 'string') {\n    if (!schema.marks[nameOrType]) {\n      throw Error(\n        `There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`,\n      )\n    }\n\n    return schema.marks[nameOrType]\n  }\n\n  return nameOrType\n}\n","import { MarkType } from '@tiptap/pm/model'\nimport { TextSelection } from '@tiptap/pm/state'\n\nimport { getMarkRange } from '../helpers/getMarkRange.js'\nimport { getMarkType } from '../helpers/getMarkType.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    extendMarkRange: {\n      /**\n       * Extends the text selection to the current mark.\n       */\n      extendMarkRange: (\n        typeOrName: string | MarkType,\n        attributes?: Record<string, any>,\n      ) => ReturnType\n    }\n  }\n}\n\nexport const extendMarkRange: RawCommands['extendMarkRange'] = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  const type = getMarkType(typeOrName, state.schema)\n  const { doc, selection } = tr\n  const { $from, from, to } = selection\n\n  if (dispatch) {\n    const range = getMarkRange($from, type, attributes)\n\n    if (range && range.from <= from && range.to >= to) {\n      const newSelection = TextSelection.create(doc, range.from, range.to)\n\n      tr.setSelection(newSelection)\n    }\n  }\n\n  return true\n}\n","import { Command, CommandProps, RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    first: {\n      /**\n       * Runs one command after the other and stops at the first which returns true.\n       */\n      first: (commands: Command[] | ((props: CommandProps) => Command[])) => ReturnType,\n    }\n  }\n}\n\nexport const first: RawCommands['first'] = commands => props => {\n  const items = typeof commands === 'function'\n    ? commands(props)\n    : commands\n\n  for (let i = 0; i < items.length; i += 1) {\n    if (items[i](props)) {\n      return true\n    }\n  }\n\n  return false\n}\n","import { TextSelection } from '@tiptap/pm/state'\n\nexport function isTextSelection(value: unknown): value is TextSelection {\n  return value instanceof TextSelection\n}\n","export function minMax(value = 0, min = 0, max = 0): number {\n  return Math.min(Math.max(value, min), max)\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { Selection, TextSelection } from '@tiptap/pm/state'\n\nimport { FocusPosition } from '../types.js'\nimport { minMax } from '../utilities/minMax.js'\n\nexport function resolveFocusPosition(\n  doc: ProseMirrorNode,\n  position: FocusPosition = null,\n): Selection | null {\n  if (!position) {\n    return null\n  }\n\n  const selectionAtStart = Selection.atStart(doc)\n  const selectionAtEnd = Selection.atEnd(doc)\n\n  if (position === 'start' || position === true) {\n    return selectionAtStart\n  }\n\n  if (position === 'end') {\n    return selectionAtEnd\n  }\n\n  const minPos = selectionAtStart.from\n  const maxPos = selectionAtEnd.to\n\n  if (position === 'all') {\n    return TextSelection.create(\n      doc,\n      minMax(0, minPos, maxPos),\n      minMax(doc.content.size, minPos, maxPos),\n    )\n  }\n\n  return TextSelection.create(\n    doc,\n    minMax(position, minPos, maxPos),\n    minMax(position, minPos, maxPos),\n  )\n}\n","export function isiOS(): boolean {\n  return [\n    'iPad Simulator',\n    'iPhone Simulator',\n    'iPod Simulator',\n    'iPad',\n    'iPhone',\n    'iPod',\n  ].includes(navigator.platform)\n  // iPad on iOS 13 detection\n  || (navigator.userAgent.includes('Mac') && 'ontouchend' in document)\n}\n","import { isTextSelection } from '../helpers/isTextSelection.js'\nimport { resolveFocusPosition } from '../helpers/resolveFocusPosition.js'\nimport { FocusPosition, RawCommands } from '../types.js'\nimport { isiOS } from '../utilities/isiOS.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    focus: {\n      /**\n       * Focus the editor at the given position.\n       */\n      focus: (\n        position?: FocusPosition,\n        options?: {\n          scrollIntoView?: boolean,\n        },\n      ) => ReturnType,\n    }\n  }\n}\n\nexport const focus: RawCommands['focus'] = (position = null, options = {}) => ({\n  editor,\n  view,\n  tr,\n  dispatch,\n}) => {\n  options = {\n    scrollIntoView: true,\n    ...options,\n  }\n\n  const delayedFocus = () => {\n    // focus within `requestAnimationFrame` breaks focus on iOS\n    // so we have to call this\n    if (isiOS()) {\n      (view.dom as HTMLElement).focus()\n    }\n\n    // For React we have to focus asynchronously. Otherwise wild things happen.\n    // see: https://github.com/ueberdosis/tiptap/issues/1520\n    requestAnimationFrame(() => {\n      if (!editor.isDestroyed) {\n        view.focus()\n\n        if (options?.scrollIntoView) {\n          editor.commands.scrollIntoView()\n        }\n      }\n    })\n  }\n\n  if ((view.hasFocus() && position === null) || position === false) {\n    return true\n  }\n\n  // we don’t try to resolve a NodeSelection or CellSelection\n  if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\n    delayedFocus()\n    return true\n  }\n\n  // pass through tr.doc instead of editor.state.doc\n  // since transactions could change the editors state before this command has been run\n  const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection\n  const isSameSelection = editor.state.selection.eq(selection)\n\n  if (dispatch) {\n    if (!isSameSelection) {\n      tr.setSelection(selection)\n    }\n\n    // `tr.setSelection` resets the stored marks\n    // so we’ll restore them if the selection is the same as before\n    if (isSameSelection && tr.storedMarks) {\n      tr.setStoredMarks(tr.storedMarks)\n    }\n\n    delayedFocus()\n  }\n\n  return true\n}\n","import { CommandProps, RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    forEach: {\n      /**\n       * Loop through an array of items.\n       */\n      forEach: <T>(\n        items: T[],\n        fn: (\n          item: T,\n          props: CommandProps & {\n            index: number,\n          },\n        ) => boolean,\n      ) => ReturnType,\n    }\n  }\n}\n\nexport const forEach: RawCommands['forEach'] = (items, fn) => props => {\n  return items.every((item, index) => fn(item, { ...props, index }))\n}\n","import { ParseOptions } from '@tiptap/pm/model'\n\nimport { Content, RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    insertContent: {\n      /**\n       * Insert a node or string of HTML at the current position.\n       */\n      insertContent: (\n        value: Content,\n        options?: {\n          parseOptions?: ParseOptions\n          updateSelection?: boolean\n        },\n      ) => ReturnType\n    }\n  }\n}\n\nexport const insertContent: RawCommands['insertContent'] = (value, options) => ({ tr, commands }) => {\n  return commands.insertContentAt(\n    { from: tr.selection.from, to: tr.selection.to },\n    value,\n    options,\n  )\n}\n","export function elementFromString(value: string): HTMLElement {\n  // add a wrapper to preserve leading and trailing whitespace\n  const wrappedValue = `<body>${value}</body>`\n\n  return new window.DOMParser().parseFromString(wrappedValue, 'text/html').body\n}\n","import {\n  DOMParser,\n  Fragment,\n  Node as ProseMirrorNode,\n  ParseOptions,\n  Schema,\n} from '@tiptap/pm/model'\n\nimport { Content } from '../types.js'\nimport { elementFromString } from '../utilities/elementFromString.js'\n\nexport type CreateNodeFromContentOptions = {\n  slice?: boolean\n  parseOptions?: ParseOptions\n}\n\nexport function createNodeFromContent(\n  content: Content,\n  schema: Schema,\n  options?: CreateNodeFromContentOptions,\n): ProseMirrorNode | Fragment {\n  options = {\n    slice: true,\n    parseOptions: {},\n    ...options,\n  }\n\n  if (typeof content === 'object' && content !== null) {\n    try {\n      if (Array.isArray(content) && content.length > 0) {\n        return Fragment.fromArray(content.map(item => schema.nodeFromJSON(item)))\n      }\n\n      return schema.nodeFromJSON(content)\n    } catch (error) {\n      console.warn('[tiptap warn]: Invalid content.', 'Passed value:', content, 'Error:', error)\n\n      return createNodeFromContent('', schema, options)\n    }\n  }\n\n  if (typeof content === 'string') {\n    const parser = DOMParser.fromSchema(schema)\n\n    return options.slice\n      ? parser.parseSlice(elementFromString(content), options.parseOptions).content\n      : parser.parse(elementFromString(content), options.parseOptions)\n  }\n\n  return createNodeFromContent('', schema, options)\n}\n","import { Selection, Transaction } from '@tiptap/pm/state'\nimport { ReplaceAroundStep, ReplaceStep } from '@tiptap/pm/transform'\n\n// source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466\nexport function selectionToInsertionEnd(tr: Transaction, startLen: number, bias: number) {\n  const last = tr.steps.length - 1\n\n  if (last < startLen) {\n    return\n  }\n\n  const step = tr.steps[last]\n\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {\n    return\n  }\n\n  const map = tr.mapping.maps[last]\n  let end = 0\n\n  map.forEach((_from, _to, _newFrom, newTo) => {\n    if (end === 0) {\n      end = newTo\n    }\n  })\n\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias))\n}\n","import { Fragment, Node as ProseMirrorNode, ParseOptions } from '@tiptap/pm/model'\n\nimport { createNodeFromContent } from '../helpers/createNodeFromContent.js'\nimport { selectionToInsertionEnd } from '../helpers/selectionToInsertionEnd.js'\nimport { Content, Range, RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    insertContentAt: {\n      /**\n       * Insert a node or string of HTML at a specific position.\n       */\n      insertContentAt: (\n        position: number | Range,\n        value: Content,\n        options?: {\n          parseOptions?: ParseOptions\n          updateSelection?: boolean\n        },\n      ) => ReturnType\n    }\n  }\n}\n\nconst isFragment = (nodeOrFragment: ProseMirrorNode | Fragment): nodeOrFragment is Fragment => {\n  return nodeOrFragment.toString().startsWith('<')\n}\n\nexport const insertContentAt: RawCommands['insertContentAt'] = (position, value, options) => ({ tr, dispatch, editor }) => {\n  if (dispatch) {\n    options = {\n      parseOptions: {},\n      updateSelection: true,\n      ...options,\n    }\n\n    const content = createNodeFromContent(value, editor.schema, {\n      parseOptions: {\n        preserveWhitespace: 'full',\n        ...options.parseOptions,\n      },\n    })\n\n    // don’t dispatch an empty fragment because this can lead to strange errors\n    if (content.toString() === '<>') {\n      return true\n    }\n\n    let { from, to } = typeof position === 'number' ? { from: position, to: position } : { from: position.from, to: position.to }\n\n    let isOnlyTextContent = true\n    let isOnlyBlockContent = true\n    const nodes = isFragment(content) ? content : [content]\n\n    nodes.forEach(node => {\n      // check if added node is valid\n      node.check()\n\n      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false\n\n      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false\n    })\n\n    // check if we can replace the wrapping node by\n    // the newly inserted content\n    // example:\n    // replace an empty paragraph by an inserted image\n    // instead of inserting the image below the paragraph\n    if (from === to && isOnlyBlockContent) {\n      const { parent } = tr.doc.resolve(from)\n      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount\n\n      if (isEmptyTextBlock) {\n        from -= 1\n        to += 1\n      }\n    }\n\n    // if there is only plain text we have to use `insertText`\n    // because this will keep the current marks\n    if (isOnlyTextContent) {\n      // if value is string, we can use it directly\n      // otherwise if it is an array, we have to join it\n      if (Array.isArray(value)) {\n        tr.insertText(value.map(v => v.text || '').join(''), from, to)\n      } else if (typeof value === 'object' && !!value && !!value.text) {\n        tr.insertText(value.text, from, to)\n      } else {\n        tr.insertText(value as string, from, to)\n      }\n    } else {\n      tr.replaceWith(from, to, content)\n    }\n\n    // set cursor at end of inserted content\n    if (options.updateSelection) {\n      selectionToInsertionEnd(tr, tr.steps.length - 1, -1)\n    }\n  }\n\n  return true\n}\n","import {\n  joinBackward as originalJoinBackward,\n  joinDown as originalJoinDown,\n  joinForward as originalJoinForward,\n  joinUp as originalJoinUp,\n} from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    joinUp: {\n      /**\n       * Join two nodes Up.\n       */\n      joinUp: () => ReturnType\n    }\n    joinDown: {\n      /**\n       * Join two nodes Down.\n       */\n      joinDown: () => ReturnType\n    }\n    joinBackward: {\n      /**\n       * Join two nodes Backwards.\n       */\n      joinBackward: () => ReturnType\n    }\n    joinForward: {\n      /**\n       * Join two nodes Forwards.\n       */\n      joinForward: () => ReturnType\n    }\n  }\n}\n\nexport const joinUp: RawCommands['joinUp'] = () => ({ state, dispatch }) => {\n  return originalJoinUp(state, dispatch)\n}\n\nexport const joinDown: RawCommands['joinDown'] = () => ({ state, dispatch }) => {\n  return originalJoinDown(state, dispatch)\n}\n\nexport const joinBackward: RawCommands['joinBackward'] = () => ({ state, dispatch }) => {\n  return originalJoinBackward(state, dispatch)\n}\n\nexport const joinForward: RawCommands['joinForward'] = () => ({ state, dispatch }) => {\n  return originalJoinForward(state, dispatch)\n}\n","import { joinPoint } from '@tiptap/pm/transform'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    joinItemBackward: {\n      /**\n       * Join two nodes Forwards.\n       */\n      joinItemBackward: () => ReturnType\n    }\n  }\n}\n\nexport const joinItemBackward: RawCommands['joinItemBackward'] = () => ({\n  tr, state, dispatch,\n}) => {\n  try {\n    const point = joinPoint(state.doc, state.selection.$from.pos, -1)\n\n    if (point === null || point === undefined) {\n      return false\n    }\n\n    tr.join(point, 2)\n\n    if (dispatch) {\n      dispatch(tr)\n    }\n\n    return true\n  } catch {\n    return false\n  }\n}\n","import { joinPoint } from '@tiptap/pm/transform'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    joinItemForward: {\n      /**\n       * Join two nodes Forwards.\n       */\n      joinItemForward: () => ReturnType\n    }\n  }\n}\n\nexport const joinItemForward: RawCommands['joinItemForward'] = () => ({\n  state,\n  dispatch,\n  tr,\n}) => {\n  try {\n    const point = joinPoint(state.doc, state.selection.$from.pos, +1)\n\n    if (point === null || point === undefined) {\n      return false\n    }\n\n    tr.join(point, 2)\n\n    if (dispatch) {\n      dispatch(tr)\n    }\n\n    return true\n  } catch (e) {\n    return false\n  }\n}\n","export function isMacOS(): boolean {\n  return typeof navigator !== 'undefined'\n    ? /Mac/.test(navigator.platform)\n    : false\n}\n","import { RawCommands } from '../types.js'\nimport { isiOS } from '../utilities/isiOS.js'\nimport { isMacOS } from '../utilities/isMacOS.js'\n\nfunction normalizeKeyName(name: string) {\n  const parts = name.split(/-(?!$)/)\n  let result = parts[parts.length - 1]\n\n  if (result === 'Space') {\n    result = ' '\n  }\n\n  let alt\n  let ctrl\n  let shift\n  let meta\n\n  for (let i = 0; i < parts.length - 1; i += 1) {\n    const mod = parts[i]\n\n    if (/^(cmd|meta|m)$/i.test(mod)) {\n      meta = true\n    } else if (/^a(lt)?$/i.test(mod)) {\n      alt = true\n    } else if (/^(c|ctrl|control)$/i.test(mod)) {\n      ctrl = true\n    } else if (/^s(hift)?$/i.test(mod)) {\n      shift = true\n    } else if (/^mod$/i.test(mod)) {\n      if (isiOS() || isMacOS()) {\n        meta = true\n      } else {\n        ctrl = true\n      }\n    } else {\n      throw new Error(`Unrecognized modifier name: ${mod}`)\n    }\n  }\n\n  if (alt) {\n    result = `Alt-${result}`\n  }\n\n  if (ctrl) {\n    result = `Ctrl-${result}`\n  }\n\n  if (meta) {\n    result = `Meta-${result}`\n  }\n\n  if (shift) {\n    result = `Shift-${result}`\n  }\n\n  return result\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    keyboardShortcut: {\n      /**\n       * Trigger a keyboard shortcut.\n       */\n      keyboardShortcut: (name: string) => ReturnType,\n    }\n  }\n}\n\nexport const keyboardShortcut: RawCommands['keyboardShortcut'] = name => ({\n  editor,\n  view,\n  tr,\n  dispatch,\n}) => {\n  const keys = normalizeKeyName(name).split(/-(?!$)/)\n  const key = keys.find(item => !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(item))\n  const event = new KeyboardEvent('keydown', {\n    key: key === 'Space'\n      ? ' '\n      : key,\n    altKey: keys.includes('Alt'),\n    ctrlKey: keys.includes('Ctrl'),\n    metaKey: keys.includes('Meta'),\n    shiftKey: keys.includes('Shift'),\n    bubbles: true,\n    cancelable: true,\n  })\n\n  const capturedTransaction = editor.captureTransaction(() => {\n    view.someProp('handleKeyDown', f => f(view, event))\n  })\n\n  capturedTransaction?.steps.forEach(step => {\n    const newStep = step.map(tr.mapping)\n\n    if (newStep && dispatch) {\n      tr.maybeStep(newStep)\n    }\n  })\n\n  return true\n}\n","import { NodeType } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\nimport { NodeRange } from '../types.js'\nimport { objectIncludes } from '../utilities/objectIncludes.js'\nimport { getNodeType } from './getNodeType.js'\n\nexport function isNodeActive(\n  state: EditorState,\n  typeOrName: NodeType | string | null,\n  attributes: Record<string, any> = {},\n): boolean {\n  const { from, to, empty } = state.selection\n  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null\n\n  const nodeRanges: NodeRange[] = []\n\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isText) {\n      return\n    }\n\n    const relativeFrom = Math.max(from, pos)\n    const relativeTo = Math.min(to, pos + node.nodeSize)\n\n    nodeRanges.push({\n      node,\n      from: relativeFrom,\n      to: relativeTo,\n    })\n  })\n\n  const selectionRange = to - from\n  const matchedNodeRanges = nodeRanges\n    .filter(nodeRange => {\n      if (!type) {\n        return true\n      }\n\n      return type.name === nodeRange.node.type.name\n    })\n    .filter(nodeRange => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }))\n\n  if (empty) {\n    return !!matchedNodeRanges.length\n  }\n\n  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0)\n\n  return range >= selectionRange\n}\n","import { lift as originalLift } from '@tiptap/pm/commands'\nimport { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { isNodeActive } from '../helpers/isNodeActive.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    lift: {\n      /**\n       * Removes an existing wrap.\n       */\n      lift: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const lift: RawCommands['lift'] = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const isActive = isNodeActive(state, type, attributes)\n\n  if (!isActive) {\n    return false\n  }\n\n  return originalLift(state, dispatch)\n}\n","import { liftEmptyBlock as originalLiftEmptyBlock } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    liftEmptyBlock: {\n      /**\n       * Lift block if empty.\n       */\n      liftEmptyBlock: () => ReturnType,\n    }\n  }\n}\n\nexport const liftEmptyBlock: RawCommands['liftEmptyBlock'] = () => ({ state, dispatch }) => {\n  return originalLiftEmptyBlock(state, dispatch)\n}\n","import { NodeType } from '@tiptap/pm/model'\nimport { liftListItem as originalLiftListItem } from '@tiptap/pm/schema-list'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    liftListItem: {\n      /**\n       * Lift the list item into a wrapping list.\n       */\n      liftListItem: (typeOrName: string | NodeType) => ReturnType\n    }\n  }\n}\n\nexport const liftListItem: RawCommands['liftListItem'] = typeOrName => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalLiftListItem(type)(state, dispatch)\n}\n","import { newlineInCode as originalNewlineInCode } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    newlineInCode: {\n      /**\n       * Add a newline character in code.\n       */\n      newlineInCode: () => ReturnType\n    }\n  }\n}\n\nexport const newlineInCode: RawCommands['newlineInCode'] = () => ({ state, dispatch }) => {\n  return originalNewlineInCode(state, dispatch)\n}\n","import { Schema } from '@tiptap/pm/model'\n\nexport function getSchemaTypeNameByName(name: string, schema: Schema): 'node' | 'mark' | null {\n  if (schema.nodes[name]) {\n    return 'node'\n  }\n\n  if (schema.marks[name]) {\n    return 'mark'\n  }\n\n  return null\n}\n","/**\n * Remove a property or an array of properties from an object\n * @param obj Object\n * @param key Key to remove\n */\nexport function deleteProps(obj: Record<string, any>, propOrProps: string | string[]): Record<string, any> {\n  const props = typeof propOrProps === 'string'\n    ? [propOrProps]\n    : propOrProps\n\n  return Object\n    .keys(obj)\n    .reduce((newObj: Record<string, any>, prop) => {\n      if (!props.includes(prop)) {\n        newObj[prop] = obj[prop]\n      }\n\n      return newObj\n    }, {})\n}\n","import { MarkType, NodeType } from '@tiptap/pm/model'\n\nimport { getMarkType } from '../helpers/getMarkType.js'\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { getSchemaTypeNameByName } from '../helpers/getSchemaTypeNameByName.js'\nimport { RawCommands } from '../types.js'\nimport { deleteProps } from '../utilities/deleteProps.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    resetAttributes: {\n      /**\n       * Resets some node attributes to the default value.\n       */\n      resetAttributes: (\n        typeOrName: string | NodeType | MarkType,\n        attributes: string | string[],\n      ) => ReturnType\n    }\n  }\n}\n\nexport const resetAttributes: RawCommands['resetAttributes'] = (typeOrName, attributes) => ({ tr, state, dispatch }) => {\n  let nodeType: NodeType | null = null\n  let markType: MarkType | null = null\n\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === 'string' ? typeOrName : typeOrName.name,\n    state.schema,\n  )\n\n  if (!schemaType) {\n    return false\n  }\n\n  if (schemaType === 'node') {\n    nodeType = getNodeType(typeOrName as NodeType, state.schema)\n  }\n\n  if (schemaType === 'mark') {\n    markType = getMarkType(typeOrName as MarkType, state.schema)\n  }\n\n  if (dispatch) {\n    tr.selection.ranges.forEach(range => {\n      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes))\n        }\n\n        if (markType && node.marks.length) {\n          node.marks.forEach(mark => {\n            if (markType === mark.type) {\n              tr.addMark(\n                pos,\n                pos + node.nodeSize,\n                markType.create(deleteProps(mark.attrs, attributes)),\n              )\n            }\n          })\n        }\n      })\n    })\n  }\n\n  return true\n}\n","import { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    scrollIntoView: {\n      /**\n       * Scroll the selection into view.\n       */\n      scrollIntoView: () => ReturnType,\n    }\n  }\n}\n\nexport const scrollIntoView: RawCommands['scrollIntoView'] = () => ({ tr, dispatch }) => {\n  if (dispatch) {\n    tr.scrollIntoView()\n  }\n\n  return true\n}\n","import { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectAll: {\n      /**\n       * Select the whole document.\n       */\n      selectAll: () => ReturnType,\n    }\n  }\n}\n\nexport const selectAll: RawCommands['selectAll'] = () => ({ tr, commands }) => {\n  return commands.setTextSelection({\n    from: 0,\n    to: tr.doc.content.size,\n  })\n}\n","import { selectNodeBackward as originalSelectNodeBackward } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectNodeBackward: {\n      /**\n       * Select a node backward.\n       */\n      selectNodeBackward: () => ReturnType\n    }\n  }\n}\n\nexport const selectNodeBackward: RawCommands['selectNodeBackward'] = () => ({ state, dispatch }) => {\n  return originalSelectNodeBackward(state, dispatch)\n}\n","import { selectNodeForward as originalSelectNodeForward } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectNodeForward: {\n      /**\n       * Select a node forward.\n       */\n      selectNodeForward: () => ReturnType\n    }\n  }\n}\n\nexport const selectNodeForward: RawCommands['selectNodeForward'] = () => ({ state, dispatch }) => {\n  return originalSelectNodeForward(state, dispatch)\n}\n","import { selectParentNode as originalSelectParentNode } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectParentNode: {\n      /**\n       * Select the parent node.\n       */\n      selectParentNode: () => ReturnType\n    }\n  }\n}\n\nexport const selectParentNode: RawCommands['selectParentNode'] = () => ({ state, dispatch }) => {\n  return originalSelectParentNode(state, dispatch)\n}\n","// @ts-ignore\n// TODO: add types to @types/prosemirror-commands\nimport { selectTextblockEnd as originalSelectTextblockEnd } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectTextblockEnd: {\n      /**\n       * Moves the cursor to the end of current text block.\n       */\n      selectTextblockEnd: () => ReturnType\n    }\n  }\n}\n\nexport const selectTextblockEnd: RawCommands['selectTextblockEnd'] = () => ({ state, dispatch }) => {\n  return originalSelectTextblockEnd(state, dispatch)\n}\n","// @ts-ignore\n// TODO: add types to @types/prosemirror-commands\nimport { selectTextblockStart as originalSelectTextblockStart } from '@tiptap/pm/commands'\n\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectTextblockStart: {\n      /**\n       * Moves the cursor to the start of current text block.\n       */\n      selectTextblockStart: () => ReturnType\n    }\n  }\n}\n\nexport const selectTextblockStart: RawCommands['selectTextblockStart'] = () => ({ state, dispatch }) => {\n  return originalSelectTextblockStart(state, dispatch)\n}\n","import { Node as ProseMirrorNode, ParseOptions, Schema } from '@tiptap/pm/model'\n\nimport { Content } from '../types.js'\nimport { createNodeFromContent } from './createNodeFromContent.js'\n\nexport function createDocument(\n  content: Content,\n  schema: Schema,\n  parseOptions: ParseOptions = {},\n): ProseMirrorNode {\n  return createNodeFromContent(content, schema, { slice: false, parseOptions }) as ProseMirrorNode\n}\n","import { ParseOptions } from '@tiptap/pm/model'\n\nimport { createDocument } from '../helpers/createDocument.js'\nimport { Content, RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setContent: {\n      /**\n       * Replace the whole document with new content.\n       */\n      setContent: (\n        content: Content,\n        emitUpdate?: boolean,\n        parseOptions?: ParseOptions,\n      ) => ReturnType\n    }\n  }\n}\n\nexport const setContent: RawCommands['setContent'] = (content, emitUpdate = false, parseOptions = {}) => ({ tr, editor, dispatch }) => {\n  const { doc } = tr\n  const document = createDocument(content, editor.schema, parseOptions)\n\n  if (dispatch) {\n    tr.replaceWith(0, doc.content.size, document).setMeta('preventUpdate', !emitUpdate)\n  }\n\n  return true\n}\n","import { Mark, MarkType } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\nimport { getMarkType } from './getMarkType.js'\n\nexport function getMarkAttributes(\n  state: EditorState,\n  typeOrName: string | MarkType,\n): Record<string, any> {\n  const type = getMarkType(typeOrName, state.schema)\n  const { from, to, empty } = state.selection\n  const marks: Mark[] = []\n\n  if (empty) {\n    if (state.storedMarks) {\n      marks.push(...state.storedMarks)\n    }\n\n    marks.push(...state.selection.$head.marks())\n  } else {\n    state.doc.nodesBetween(from, to, node => {\n      marks.push(...node.marks)\n    })\n  }\n\n  const mark = marks.find(markItem => markItem.type.name === type.name)\n\n  if (!mark) {\n    return {}\n  }\n\n  return { ...mark.attrs }\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { Transaction } from '@tiptap/pm/state'\nimport { Transform } from '@tiptap/pm/transform'\n\n/**\n * Returns a new `Transform` based on all steps of the passed transactions.\n */\nexport function combineTransactionSteps(\n  oldDoc: ProseMirrorNode,\n  transactions: Transaction[],\n): Transform {\n  const transform = new Transform(oldDoc)\n\n  transactions.forEach(transaction => {\n    transaction.steps.forEach(step => {\n      transform.step(step)\n    })\n  })\n\n  return transform\n}\n","import { ContentMatch, NodeType } from '@tiptap/pm/model'\n\nexport function defaultBlockAt(match: ContentMatch): NodeType | null {\n  for (let i = 0; i < match.edgeCount; i += 1) {\n    const { type } = match.edge(i)\n\n    if (type.isTextblock && !type.hasRequiredAttrs()) {\n      return type\n    }\n  }\n\n  return null\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { NodeWithPos, Predicate } from '../types.js'\n\nexport function findChildren(node: ProseMirrorNode, predicate: Predicate): NodeWithPos[] {\n  const nodesWithPos: NodeWithPos[] = []\n\n  node.descendants((child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos,\n      })\n    }\n  })\n\n  return nodesWithPos\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { NodeWithPos, Predicate, Range } from '../types.js'\n\n/**\n * Same as `findChildren` but searches only within a `range`.\n */\nexport function findChildrenInRange(\n  node: ProseMirrorNode,\n  range: Range,\n  predicate: Predicate,\n): NodeWithPos[] {\n  const nodesWithPos: NodeWithPos[] = []\n\n  // if (range.from === range.to) {\n  //   const nodeAt = node.nodeAt(range.from)\n\n  //   if (nodeAt) {\n  //     nodesWithPos.push({\n  //       node: nodeAt,\n  //       pos: range.from,\n  //     })\n  //   }\n  // }\n\n  node.nodesBetween(range.from, range.to, (child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos,\n      })\n    }\n  })\n\n  return nodesWithPos\n}\n","import { Node as ProseMirrorNode, ResolvedPos } from '@tiptap/pm/model'\n\nimport { Predicate } from '../types.js'\n\nexport function findParentNodeClosestToPos(\n  $pos: ResolvedPos,\n  predicate: Predicate,\n):\n  | {\n      pos: number\n      start: number\n      depth: number\n      node: ProseMirrorNode\n    }\n  | undefined {\n  for (let i = $pos.depth; i > 0; i -= 1) {\n    const node = $pos.node(i)\n\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node,\n      }\n    }\n  }\n}\n","import { Selection } from '@tiptap/pm/state'\n\nimport { Predicate } from '../types.js'\nimport { findParentNodeClosestToPos } from './findParentNodeClosestToPos.js'\n\nexport function findParentNode(predicate: Predicate) {\n  return (selection: Selection) => findParentNodeClosestToPos(selection.$from, predicate)\n}\n","import { DOMSerializer, Fragment, Schema } from '@tiptap/pm/model'\n\nexport function getHTMLFromFragment(fragment: Fragment, schema: Schema): string {\n  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment)\n\n  const temporaryDocument = document.implementation.createHTMLDocument()\n  const container = temporaryDocument.createElement('div')\n\n  container.appendChild(documentFragment)\n\n  return container.innerHTML\n}\n","import { Schema } from '@tiptap/pm/model'\n\nimport { Editor } from '../Editor.js'\nimport { ExtensionManager } from '../ExtensionManager.js'\nimport { Extensions } from '../types.js'\nimport { getSchemaByResolvedExtensions } from './getSchemaByResolvedExtensions.js'\n\nexport function getSchema(extensions: Extensions, editor?: Editor): Schema {\n  const resolvedExtensions = ExtensionManager.resolve(extensions)\n\n  return getSchemaByResolvedExtensions(resolvedExtensions, editor)\n}\n","import { Node } from '@tiptap/pm/model'\n\nimport { Extensions, JSONContent } from '../types.js'\nimport { getHTMLFromFragment } from './getHTMLFromFragment.js'\nimport { getSchema } from './getSchema.js'\n\nexport function generateHTML(doc: JSONContent, extensions: Extensions): string {\n  const schema = getSchema(extensions)\n  const contentNode = Node.fromJSON(schema, doc)\n\n  return getHTMLFromFragment(contentNode.content, schema)\n}\n","import { DOMParser } from '@tiptap/pm/model'\n\nimport { Extensions } from '../types.js'\nimport { elementFromString } from '../utilities/elementFromString.js'\nimport { getSchema } from './getSchema.js'\n\nexport function generateJSON(html: string, extensions: Extensions): Record<string, any> {\n  const schema = getSchema(extensions)\n  const dom = elementFromString(html)\n\n  return DOMParser.fromSchema(schema).parse(dom).toJSON()\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { TextSerializer } from '../types.js'\nimport { getTextBetween } from './getTextBetween.js'\n\nexport function getText(\n  node: ProseMirrorNode,\n  options?: {\n    blockSeparator?: string\n    textSerializers?: Record<string, TextSerializer>\n  },\n) {\n  const range = {\n    from: 0,\n    to: node.content.size,\n  }\n\n  return getTextBetween(node, range, options)\n}\n","import { Node } from '@tiptap/pm/model'\n\nimport { Extensions, JSONContent, TextSerializer } from '../types.js'\nimport { getSchema } from './getSchema.js'\nimport { getText } from './getText.js'\nimport { getTextSerializersFromSchema } from './getTextSerializersFromSchema.js'\n\nexport function generateText(\n  doc: JSONContent,\n  extensions: Extensions,\n  options?: {\n    blockSeparator?: string\n    textSerializers?: Record<string, TextSerializer>\n  },\n): string {\n  const { blockSeparator = '\\n\\n', textSerializers = {} } = options || {}\n  const schema = getSchema(extensions)\n  const contentNode = Node.fromJSON(schema, doc)\n\n  return getText(contentNode, {\n    blockSeparator,\n    textSerializers: {\n      ...getTextSerializersFromSchema(schema),\n      ...textSerializers,\n    },\n  })\n}\n","import { Node, NodeType } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\nimport { getNodeType } from './getNodeType.js'\n\nexport function getNodeAttributes(\n  state: EditorState,\n  typeOrName: string | NodeType,\n): Record<string, any> {\n  const type = getNodeType(typeOrName, state.schema)\n  const { from, to } = state.selection\n  const nodes: Node[] = []\n\n  state.doc.nodesBetween(from, to, node => {\n    nodes.push(node)\n  })\n\n  const node = nodes.reverse().find(nodeItem => nodeItem.type.name === type.name)\n\n  if (!node) {\n    return {}\n  }\n\n  return { ...node.attrs }\n}\n","import { MarkType, NodeType } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\nimport { getMarkAttributes } from './getMarkAttributes.js'\nimport { getNodeAttributes } from './getNodeAttributes.js'\nimport { getSchemaTypeNameByName } from './getSchemaTypeNameByName.js'\n\nexport function getAttributes(\n  state: EditorState,\n  typeOrName: string | NodeType | MarkType,\n): Record<string, any> {\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === 'string' ? typeOrName : typeOrName.name,\n    state.schema,\n  )\n\n  if (schemaType === 'node') {\n    return getNodeAttributes(state, typeOrName as NodeType)\n  }\n\n  if (schemaType === 'mark') {\n    return getMarkAttributes(state, typeOrName as MarkType)\n  }\n\n  return {}\n}\n","/**\n * Removes duplicated values within an array.\n * Supports numbers, strings and objects.\n */\nexport function removeDuplicates<T>(array: T[], by = JSON.stringify): T[] {\n  const seen: Record<any, any> = {}\n\n  return array.filter(item => {\n    const key = by(item)\n\n    return Object.prototype.hasOwnProperty.call(seen, key)\n      ? false\n      : (seen[key] = true)\n  })\n}\n","import { Step, Transform } from '@tiptap/pm/transform'\n\nimport { Range } from '../types.js'\nimport { removeDuplicates } from '../utilities/removeDuplicates.js'\n\nexport type ChangedRange = {\n  oldRange: Range,\n  newRange: Range,\n}\n\n/**\n * Removes duplicated ranges and ranges that are\n * fully captured by other ranges.\n */\nfunction simplifyChangedRanges(changes: ChangedRange[]): ChangedRange[] {\n  const uniqueChanges = removeDuplicates(changes)\n\n  return uniqueChanges.length === 1\n    ? uniqueChanges\n    : uniqueChanges.filter((change, index) => {\n      const rest = uniqueChanges.filter((_, i) => i !== index)\n\n      return !rest.some(otherChange => {\n        return change.oldRange.from >= otherChange.oldRange.from\n          && change.oldRange.to <= otherChange.oldRange.to\n          && change.newRange.from >= otherChange.newRange.from\n          && change.newRange.to <= otherChange.newRange.to\n      })\n    })\n}\n\n/**\n * Returns a list of changed ranges\n * based on the first and last state of all steps.\n */\nexport function getChangedRanges(transform: Transform): ChangedRange[] {\n  const { mapping, steps } = transform\n  const changes: ChangedRange[] = []\n\n  mapping.maps.forEach((stepMap, index) => {\n    const ranges: Range[] = []\n\n    // This accounts for step changes where no range was actually altered\n    // e.g. when setting a mark, node attribute, etc.\n    // @ts-ignore\n    if (!stepMap.ranges.length) {\n      const { from, to } = steps[index] as Step & {\n        from?: number,\n        to?: number,\n      }\n\n      if (from === undefined || to === undefined) {\n        return\n      }\n\n      ranges.push({ from, to })\n    } else {\n      stepMap.forEach((from, to) => {\n        ranges.push({ from, to })\n      })\n    }\n\n    ranges.forEach(({ from, to }) => {\n      const newStart = mapping.slice(index).map(from, -1)\n      const newEnd = mapping.slice(index).map(to)\n      const oldStart = mapping.invert().map(newStart, -1)\n      const oldEnd = mapping.invert().map(newEnd)\n\n      changes.push({\n        oldRange: {\n          from: oldStart,\n          to: oldEnd,\n        },\n        newRange: {\n          from: newStart,\n          to: newEnd,\n        },\n      })\n    })\n  })\n\n  return simplifyChangedRanges(changes)\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { JSONContent } from '../types.js'\n\ninterface DebugJSONContent extends JSONContent {\n  from: number\n  to: number\n}\n\nexport function getDebugJSON(node: ProseMirrorNode, startOffset = 0): DebugJSONContent {\n  const isTopNode = node.type === node.type.schema.topNodeType\n  const increment = isTopNode ? 0 : 1\n  const from = startOffset\n  const to = from + node.nodeSize\n  const marks = node.marks.map(mark => {\n    const output: { type: string; attrs?: Record<string, any> } = {\n      type: mark.type.name,\n    }\n\n    if (Object.keys(mark.attrs).length) {\n      output.attrs = { ...mark.attrs }\n    }\n\n    return output\n  })\n  const attrs = { ...node.attrs }\n  const output: DebugJSONContent = {\n    type: node.type.name,\n    from,\n    to,\n  }\n\n  if (Object.keys(attrs).length) {\n    output.attrs = attrs\n  }\n\n  if (marks.length) {\n    output.marks = marks\n  }\n\n  if (node.content.childCount) {\n    output.content = []\n\n    node.forEach((child, offset) => {\n      output.content?.push(getDebugJSON(child, startOffset + offset + increment))\n    })\n  }\n\n  if (node.text) {\n    output.text = node.text\n  }\n\n  return output\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { MarkRange } from '../types.js'\nimport { getMarkRange } from './getMarkRange.js'\n\nexport function getMarksBetween(from: number, to: number, doc: ProseMirrorNode): MarkRange[] {\n  const marks: MarkRange[] = []\n\n  // get all inclusive marks on empty selection\n  if (from === to) {\n    doc\n      .resolve(from)\n      .marks()\n      .forEach(mark => {\n        const $pos = doc.resolve(from - 1)\n        const range = getMarkRange($pos, mark.type)\n\n        if (!range) {\n          return\n        }\n\n        marks.push({\n          mark,\n          ...range,\n        })\n      })\n  } else {\n    doc.nodesBetween(from, to, (node, pos) => {\n      marks.push(\n        ...node.marks.map(mark => ({\n          from: pos,\n          to: pos + node.nodeSize,\n          mark,\n        })),\n      )\n    })\n  }\n\n  return marks\n}\n","import { Node, NodeType } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\n/**\n * Finds the first node of a given type or name in the current selection.\n * @param state The editor state.\n * @param typeOrName The node type or name.\n * @param pos The position to start searching from.\n * @param maxDepth The maximum depth to search.\n * @returns The node and the depth as an array.\n */\nexport const getNodeAtPosition = (state: EditorState, typeOrName: string | NodeType, pos: number, maxDepth = 20) => {\n  const $pos = state.doc.resolve(pos)\n\n  let currentDepth = maxDepth\n  let node: Node | null = null\n\n  while (currentDepth > 0 && node === null) {\n    const currentNode = $pos.node(currentDepth)\n\n    if (currentNode?.type.name === typeOrName) {\n      node = currentNode\n    } else {\n      currentDepth -= 1\n    }\n  }\n\n  return [node, currentDepth] as [Node | null, number]\n}\n","import { ExtensionAttribute } from '../types.js'\n\nexport function getSplittedAttributes(\n  extensionAttributes: ExtensionAttribute[],\n  typeName: string,\n  attributes: Record<string, any>,\n): Record<string, any> {\n  return Object.fromEntries(Object\n    .entries(attributes)\n    .filter(([name]) => {\n      const extensionAttribute = extensionAttributes.find(item => {\n        return item.type === typeName && item.name === name\n      })\n\n      if (!extensionAttribute) {\n        return false\n      }\n\n      return extensionAttribute.attribute.keepOnSplit\n    }))\n}\n","import { MarkType } from '@tiptap/pm/model'\nimport { EditorState } from '@tiptap/pm/state'\n\nimport { MarkRange } from '../types.js'\nimport { objectIncludes } from '../utilities/objectIncludes.js'\nimport { getMarkType } from './getMarkType.js'\n\nexport function isMarkActive(\n  state: EditorState,\n  typeOrName: MarkType | string | null,\n  attributes: Record<string, any> = {},\n): boolean {\n  const { empty, ranges } = state.selection\n  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null\n\n  if (empty) {\n    return !!(state.storedMarks || state.selection.$from.marks())\n      .filter(mark => {\n        if (!type) {\n          return true\n        }\n\n        return type.name === mark.type.name\n      })\n      .find(mark => objectIncludes(mark.attrs, attributes, { strict: false }))\n  }\n\n  let selectionRange = 0\n  const markRanges: MarkRange[] = []\n\n  ranges.forEach(({ $from, $to }) => {\n    const from = $from.pos\n    const to = $to.pos\n\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (!node.isText && !node.marks.length) {\n        return\n      }\n\n      const relativeFrom = Math.max(from, pos)\n      const relativeTo = Math.min(to, pos + node.nodeSize)\n      const range = relativeTo - relativeFrom\n\n      selectionRange += range\n\n      markRanges.push(\n        ...node.marks.map(mark => ({\n          mark,\n          from: relativeFrom,\n          to: relativeTo,\n        })),\n      )\n    })\n  })\n\n  if (selectionRange === 0) {\n    return false\n  }\n\n  // calculate range of matched mark\n  const matchedRange = markRanges\n    .filter(markRange => {\n      if (!type) {\n        return true\n      }\n\n      return type.name === markRange.mark.type.name\n    })\n    .filter(markRange => objectIncludes(markRange.mark.attrs, attributes, { strict: false }))\n    .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0)\n\n  // calculate range of marks that excludes the searched mark\n  // for example `code` doesn’t allow any other marks\n  const excludedRange = markRanges\n    .filter(markRange => {\n      if (!type) {\n        return true\n      }\n\n      return markRange.mark.type !== type && markRange.mark.type.excludes(type)\n    })\n    .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0)\n\n  // we only include the result of `excludedRange`\n  // if there is a match at all\n  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange\n\n  return range >= selectionRange\n}\n","import { EditorState } from '@tiptap/pm/state'\n\nimport { getSchemaTypeNameByName } from './getSchemaTypeNameByName.js'\nimport { isMarkActive } from './isMarkActive.js'\nimport { isNodeActive } from './isNodeActive.js'\n\nexport function isActive(\n  state: EditorState,\n  name: string | null,\n  attributes: Record<string, any> = {},\n): boolean {\n  if (!name) {\n    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes)\n  }\n\n  const schemaType = getSchemaTypeNameByName(name, state.schema)\n\n  if (schemaType === 'node') {\n    return isNodeActive(state, name, attributes)\n  }\n\n  if (schemaType === 'mark') {\n    return isMarkActive(state, name, attributes)\n  }\n\n  return false\n}\n","import { EditorState } from '@tiptap/pm/state'\n\nimport { findParentNode } from './findParentNode.js'\n\nexport const isAtEndOfNode = (state: EditorState, nodeType?: string) => {\n  const { $from, $to, $anchor } = state.selection\n\n  if (nodeType) {\n    const parentNode = findParentNode(node => node.type.name === nodeType)(state.selection)\n\n    if (!parentNode) {\n      return false\n    }\n\n    const $parentPos = state.doc.resolve(parentNode.pos + 1)\n\n    if ($anchor.pos + 1 === $parentPos.end()) {\n      return true\n    }\n\n    return false\n  }\n\n  if ($to.parentOffset < $to.parent.nodeSize - 2 || $from.pos !== $to.pos) {\n    return false\n  }\n\n  return true\n}\n","import { EditorState } from '@tiptap/pm/state'\n\nexport const isAtStartOfNode = (state: EditorState) => {\n  const { $from, $to } = state.selection\n\n  if ($from.parentOffset > 0 || $from.pos !== $to.pos) {\n    return false\n  }\n\n  return true\n}\n","import { getExtensionField } from '../helpers/getExtensionField.js'\nimport { NodeConfig } from '../index.js'\nimport { Extensions } from '../types.js'\nimport { callOrReturn } from '../utilities/callOrReturn.js'\nimport { splitExtensions } from './splitExtensions.js'\n\nexport function isList(name: string, extensions: Extensions): boolean {\n  const { nodeExtensions } = splitExtensions(extensions)\n  const extension = nodeExtensions.find(item => item.name === name)\n\n  if (!extension) {\n    return false\n  }\n\n  const context = {\n    name: extension.name,\n    options: extension.options,\n    storage: extension.storage,\n  }\n  const group = callOrReturn(getExtensionField<NodeConfig['group']>(extension, 'group', context))\n\n  if (typeof group !== 'string') {\n    return false\n  }\n\n  return group.split(' ').includes('list')\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nexport function isNodeEmpty(node: ProseMirrorNode): boolean {\n  const defaultContent = node.type.createAndFill()?.toJSON()\n  const content = node.toJSON()\n\n  return JSON.stringify(defaultContent) === JSON.stringify(content)\n}\n","import { NodeSelection } from '@tiptap/pm/state'\n\nexport function isNodeSelection(value: unknown): value is NodeSelection {\n  return value instanceof NodeSelection\n}\n","import { EditorView } from '@tiptap/pm/view'\n\nimport { minMax } from '../utilities/minMax.js'\n\nexport function posToDOMRect(view: EditorView, from: number, to: number): DOMRect {\n  const minPos = 0\n  const maxPos = view.state.doc.content.size\n  const resolvedFrom = minMax(from, minPos, maxPos)\n  const resolvedEnd = minMax(to, minPos, maxPos)\n  const start = view.coordsAtPos(resolvedFrom)\n  const end = view.coordsAtPos(resolvedEnd, -1)\n  const top = Math.min(start.top, end.top)\n  const bottom = Math.max(start.bottom, end.bottom)\n  const left = Math.min(start.left, end.left)\n  const right = Math.max(start.right, end.right)\n  const width = right - left\n  const height = bottom - top\n  const x = left\n  const y = top\n  const data = {\n    top,\n    bottom,\n    left,\n    right,\n    width,\n    height,\n    x,\n    y,\n  }\n\n  return {\n    ...data,\n    toJSON: () => data,\n  }\n}\n","import { MarkType, ResolvedPos } from '@tiptap/pm/model'\nimport { EditorState, Transaction } from '@tiptap/pm/state'\n\nimport { getMarkAttributes } from '../helpers/getMarkAttributes.js'\nimport { getMarkType } from '../helpers/getMarkType.js'\nimport { isTextSelection } from '../helpers/index.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setMark: {\n      /**\n       * Add a mark with new attributes.\n       */\n      setMark: (typeOrName: string | MarkType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nfunction canSetMark(state: EditorState, tr: Transaction, newMarkType: MarkType) {\n  const { selection } = tr\n  let cursor: ResolvedPos | null = null\n\n  if (isTextSelection(selection)) {\n    cursor = selection.$cursor\n  }\n\n  if (cursor) {\n    const currentMarks = state.storedMarks ?? cursor.marks()\n\n    // There can be no current marks that exclude the new mark\n    return (\n      !!newMarkType.isInSet(currentMarks)\n      || !currentMarks.some(mark => mark.type.excludes(newMarkType))\n    )\n  }\n\n  const { ranges } = selection\n\n  return ranges.some(({ $from, $to }) => {\n    let someNodeSupportsMark = $from.depth === 0\n      ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType)\n      : false\n\n    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {\n      // If we already found a mark that we can enable, return false to bypass the remaining search\n      if (someNodeSupportsMark) {\n        return false\n      }\n\n      if (node.isInline) {\n        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType)\n        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks)\n          || !node.marks.some(otherMark => otherMark.type.excludes(newMarkType))\n\n        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType\n      }\n      return !someNodeSupportsMark\n    })\n\n    return someNodeSupportsMark\n  })\n}\nexport const setMark: RawCommands['setMark'] = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  const { selection } = tr\n  const { empty, ranges } = selection\n  const type = getMarkType(typeOrName, state.schema)\n\n  if (dispatch) {\n    if (empty) {\n      const oldAttributes = getMarkAttributes(state, type)\n\n      tr.addStoredMark(\n        type.create({\n          ...oldAttributes,\n          ...attributes,\n        }),\n      )\n    } else {\n      ranges.forEach(range => {\n        const from = range.$from.pos\n        const to = range.$to.pos\n\n        state.doc.nodesBetween(from, to, (node, pos) => {\n          const trimmedFrom = Math.max(pos, from)\n          const trimmedTo = Math.min(pos + node.nodeSize, to)\n          const someHasMark = node.marks.find(mark => mark.type === type)\n\n          // if there is already a mark of this type\n          // we know that we have to merge its attributes\n          // otherwise we add a fresh new mark\n          if (someHasMark) {\n            node.marks.forEach(mark => {\n              if (type === mark.type) {\n                tr.addMark(\n                  trimmedFrom,\n                  trimmedTo,\n                  type.create({\n                    ...mark.attrs,\n                    ...attributes,\n                  }),\n                )\n              }\n            })\n          } else {\n            tr.addMark(trimmedFrom, trimmedTo, type.create(attributes))\n          }\n        })\n      })\n    }\n  }\n\n  return canSetMark(state, tr, type)\n}\n","import { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setMeta: {\n      /**\n       * Store a metadata property in the current transaction.\n       */\n      setMeta: (key: string, value: any) => ReturnType,\n    }\n  }\n}\n\nexport const setMeta: RawCommands['setMeta'] = (key, value) => ({ tr }) => {\n  tr.setMeta(key, value)\n\n  return true\n}\n","import { setBlockType } from '@tiptap/pm/commands'\nimport { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setNode: {\n      /**\n       * Replace a given range with a node.\n       */\n      setNode: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const setNode: RawCommands['setNode'] = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  // TODO: use a fallback like insertContent?\n  if (!type.isTextblock) {\n    console.warn('[tiptap warn]: Currently \"setNode()\" only supports text block nodes.')\n\n    return false\n  }\n\n  return (\n    chain()\n    // try to convert node to default node if needed\n      .command(({ commands }) => {\n        const canSetBlock = setBlockType(type, attributes)(state)\n\n        if (canSetBlock) {\n          return true\n        }\n\n        return commands.clearNodes()\n      })\n      .command(({ state: updatedState }) => {\n        return setBlockType(type, attributes)(updatedState, dispatch)\n      })\n      .run()\n  )\n}\n","import { NodeSelection } from '@tiptap/pm/state'\n\nimport { RawCommands } from '../types.js'\nimport { minMax } from '../utilities/minMax.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setNodeSelection: {\n      /**\n       * Creates a NodeSelection.\n       */\n      setNodeSelection: (position: number) => ReturnType\n    }\n  }\n}\n\nexport const setNodeSelection: RawCommands['setNodeSelection'] = position => ({ tr, dispatch }) => {\n  if (dispatch) {\n    const { doc } = tr\n    const from = minMax(position, 0, doc.content.size)\n    const selection = NodeSelection.create(doc, from)\n\n    tr.setSelection(selection)\n  }\n\n  return true\n}\n","import { TextSelection } from '@tiptap/pm/state'\n\nimport { Range, RawCommands } from '../types.js'\nimport { minMax } from '../utilities/minMax.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setTextSelection: {\n      /**\n       * Creates a TextSelection.\n       */\n      setTextSelection: (position: number | Range) => ReturnType\n    }\n  }\n}\n\nexport const setTextSelection: RawCommands['setTextSelection'] = position => ({ tr, dispatch }) => {\n  if (dispatch) {\n    const { doc } = tr\n    const { from, to } = typeof position === 'number' ? { from: position, to: position } : position\n    const minPos = TextSelection.atStart(doc).from\n    const maxPos = TextSelection.atEnd(doc).to\n    const resolvedFrom = minMax(from, minPos, maxPos)\n    const resolvedEnd = minMax(to, minPos, maxPos)\n    const selection = TextSelection.create(doc, resolvedFrom, resolvedEnd)\n\n    tr.setSelection(selection)\n  }\n\n  return true\n}\n","import { NodeType } from '@tiptap/pm/model'\nimport { sinkListItem as originalSinkListItem } from '@tiptap/pm/schema-list'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    sinkListItem: {\n      /**\n       * Sink the list item down into an inner list.\n       */\n      sinkListItem: (typeOrName: string | NodeType) => ReturnType\n    }\n  }\n}\n\nexport const sinkListItem: RawCommands['sinkListItem'] = typeOrName => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalSinkListItem(type)(state, dispatch)\n}\n","import { EditorState, NodeSelection, TextSelection } from '@tiptap/pm/state'\nimport { canSplit } from '@tiptap/pm/transform'\n\nimport { defaultBlockAt } from '../helpers/defaultBlockAt.js'\nimport { getSplittedAttributes } from '../helpers/getSplittedAttributes.js'\nimport { RawCommands } from '../types.js'\n\nfunction ensureMarks(state: EditorState, splittableMarks?: string[]) {\n  const marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks())\n\n  if (marks) {\n    const filteredMarks = marks.filter(mark => splittableMarks?.includes(mark.type.name))\n\n    state.tr.ensureMarks(filteredMarks)\n  }\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    splitBlock: {\n      /**\n       * Forks a new node from an existing node.\n       */\n      splitBlock: (options?: { keepMarks?: boolean }) => ReturnType\n    }\n  }\n}\n\nexport const splitBlock: RawCommands['splitBlock'] = ({ keepMarks = true } = {}) => ({\n  tr, state, dispatch, editor,\n}) => {\n  const { selection, doc } = tr\n  const { $from, $to } = selection\n  const extensionAttributes = editor.extensionManager.attributes\n  const newAttributes = getSplittedAttributes(\n    extensionAttributes,\n    $from.node().type.name,\n    $from.node().attrs,\n  )\n\n  if (selection instanceof NodeSelection && selection.node.isBlock) {\n    if (!$from.parentOffset || !canSplit(doc, $from.pos)) {\n      return false\n    }\n\n    if (dispatch) {\n      if (keepMarks) {\n        ensureMarks(state, editor.extensionManager.splittableMarks)\n      }\n\n      tr.split($from.pos).scrollIntoView()\n    }\n\n    return true\n  }\n\n  if (!$from.parent.isBlock) {\n    return false\n  }\n\n  if (dispatch) {\n    const atEnd = $to.parentOffset === $to.parent.content.size\n\n    if (selection instanceof TextSelection) {\n      tr.deleteSelection()\n    }\n\n    const deflt = $from.depth === 0\n      ? undefined\n      : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)))\n\n    let types = atEnd && deflt\n      ? [\n        {\n          type: deflt,\n          attrs: newAttributes,\n        },\n      ]\n      : undefined\n\n    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types)\n\n    if (\n      !types\n        && !can\n        && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : undefined)\n    ) {\n      can = true\n      types = deflt\n        ? [\n          {\n            type: deflt,\n            attrs: newAttributes,\n          },\n        ]\n        : undefined\n    }\n\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types)\n\n      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {\n        const first = tr.mapping.map($from.before())\n        const $first = tr.doc.resolve(first)\n\n        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {\n          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt)\n        }\n      }\n    }\n\n    if (keepMarks) {\n      ensureMarks(state, editor.extensionManager.splittableMarks)\n    }\n\n    tr.scrollIntoView()\n  }\n\n  return true\n}\n","import {\n  Fragment, Node as ProseMirrorNode, NodeType, Slice,\n} from '@tiptap/pm/model'\nimport { TextSelection } from '@tiptap/pm/state'\nimport { canSplit } from '@tiptap/pm/transform'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { getSplittedAttributes } from '../helpers/getSplittedAttributes.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    splitListItem: {\n      /**\n       * Splits one list item into two list items.\n       */\n      splitListItem: (typeOrName: string | NodeType) => ReturnType\n    }\n  }\n}\n\nexport const splitListItem: RawCommands['splitListItem'] = typeOrName => ({\n  tr, state, dispatch, editor,\n}) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const { $from, $to } = state.selection\n\n  // @ts-ignore\n  // eslint-disable-next-line\n    const node: ProseMirrorNode = state.selection.node\n\n  if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) {\n    return false\n  }\n\n  const grandParent = $from.node(-1)\n\n  if (grandParent.type !== type) {\n    return false\n  }\n\n  const extensionAttributes = editor.extensionManager.attributes\n\n  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n    // In an empty block. If this is a nested list, the wrapping\n    // list item should be split. Otherwise, bail out and let next\n    // command handle lifting.\n    if (\n      $from.depth === 2\n        || $from.node(-3).type !== type\n        || $from.index(-2) !== $from.node(-2).childCount - 1\n    ) {\n      return false\n    }\n\n    if (dispatch) {\n      let wrap = Fragment.empty\n      // eslint-disable-next-line\n        const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3\n\n      // Build a fragment containing empty versions of the structure\n      // from the outer list item to the parent node of the cursor\n      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {\n        wrap = Fragment.from($from.node(d).copy(wrap))\n      }\n\n      // eslint-disable-next-line\n        const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3\n\n      // Add a second list item with an empty default start node\n      const newNextTypeAttributes = getSplittedAttributes(\n        extensionAttributes,\n        $from.node().type.name,\n        $from.node().attrs,\n      )\n      const nextType = type.contentMatch.defaultType?.createAndFill(newNextTypeAttributes) || undefined\n\n      wrap = wrap.append(Fragment.from(type.createAndFill(null, nextType) || undefined))\n\n      const start = $from.before($from.depth - (depthBefore - 1))\n\n      tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0))\n\n      let sel = -1\n\n      tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {\n        if (sel > -1) {\n          return false\n        }\n\n        if (n.isTextblock && n.content.size === 0) {\n          sel = pos + 1\n        }\n      })\n\n      if (sel > -1) {\n        tr.setSelection(TextSelection.near(tr.doc.resolve(sel)))\n      }\n\n      tr.scrollIntoView()\n    }\n\n    return true\n  }\n\n  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null\n\n  const newTypeAttributes = getSplittedAttributes(\n    extensionAttributes,\n    grandParent.type.name,\n    grandParent.attrs,\n  )\n  const newNextTypeAttributes = getSplittedAttributes(\n    extensionAttributes,\n    $from.node().type.name,\n    $from.node().attrs,\n  )\n\n  tr.delete($from.pos, $to.pos)\n\n  const types = nextType\n    ? [\n      { type, attrs: newTypeAttributes },\n      { type: nextType, attrs: newNextTypeAttributes },\n    ]\n    : [{ type, attrs: newTypeAttributes }]\n\n  if (!canSplit(tr.doc, $from.pos, 2)) {\n    return false\n  }\n\n  if (dispatch) {\n    const { selection, storedMarks } = state\n    const { splittableMarks } = editor.extensionManager\n    const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks())\n\n    tr.split($from.pos, 2, types).scrollIntoView()\n\n    if (!marks || !dispatch) {\n      return true\n    }\n\n    const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name))\n\n    tr.ensureMarks(filteredMarks)\n  }\n\n  return true\n}\n","import { NodeType } from '@tiptap/pm/model'\nimport { Transaction } from '@tiptap/pm/state'\nimport { canJoin } from '@tiptap/pm/transform'\n\nimport { findParentNode } from '../helpers/findParentNode.js'\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { isList } from '../helpers/isList.js'\nimport { RawCommands } from '../types.js'\n\nconst joinListBackwards = (tr: Transaction, listType: NodeType): boolean => {\n  const list = findParentNode(node => node.type === listType)(tr.selection)\n\n  if (!list) {\n    return true\n  }\n\n  const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth)\n\n  if (before === undefined) {\n    return true\n  }\n\n  const nodeBefore = tr.doc.nodeAt(before)\n  const canJoinBackwards = list.node.type === nodeBefore?.type && canJoin(tr.doc, list.pos)\n\n  if (!canJoinBackwards) {\n    return true\n  }\n\n  tr.join(list.pos)\n\n  return true\n}\n\nconst joinListForwards = (tr: Transaction, listType: NodeType): boolean => {\n  const list = findParentNode(node => node.type === listType)(tr.selection)\n\n  if (!list) {\n    return true\n  }\n\n  const after = tr.doc.resolve(list.start).after(list.depth)\n\n  if (after === undefined) {\n    return true\n  }\n\n  const nodeAfter = tr.doc.nodeAt(after)\n  const canJoinForwards = list.node.type === nodeAfter?.type && canJoin(tr.doc, after)\n\n  if (!canJoinForwards) {\n    return true\n  }\n\n  tr.join(after)\n\n  return true\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    toggleList: {\n      /**\n       * Toggle between different list types.\n       */\n      toggleList: (listTypeOrName: string | NodeType, itemTypeOrName: string | NodeType, keepMarks?: boolean, attributes?: Record<string, any>) => ReturnType;\n    }\n  }\n}\n\nexport const toggleList: RawCommands['toggleList'] = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({\n  editor, tr, state, dispatch, chain, commands, can,\n}) => {\n  const { extensions, splittableMarks } = editor.extensionManager\n  const listType = getNodeType(listTypeOrName, state.schema)\n  const itemType = getNodeType(itemTypeOrName, state.schema)\n  const { selection, storedMarks } = state\n  const { $from, $to } = selection\n  const range = $from.blockRange($to)\n\n  const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks())\n\n  if (!range) {\n    return false\n  }\n\n  const parentList = findParentNode(node => isList(node.type.name, extensions))(selection)\n\n  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n    // remove list\n    if (parentList.node.type === listType) {\n      return commands.liftListItem(itemType)\n    }\n\n    // change list type\n    if (\n      isList(parentList.node.type.name, extensions)\n        && listType.validContent(parentList.node.content)\n        && dispatch\n    ) {\n      return chain()\n        .command(() => {\n          tr.setNodeMarkup(parentList.pos, listType)\n\n          return true\n        })\n        .command(() => joinListBackwards(tr, listType))\n        .command(() => joinListForwards(tr, listType))\n        .run()\n    }\n  }\n  if (!keepMarks || !marks || !dispatch) {\n\n    return chain()\n      // try to convert node to default node if needed\n      .command(() => {\n        const canWrapInList = can().wrapInList(listType, attributes)\n\n        if (canWrapInList) {\n          return true\n        }\n\n        return commands.clearNodes()\n      })\n      .wrapInList(listType, attributes)\n      .command(() => joinListBackwards(tr, listType))\n      .command(() => joinListForwards(tr, listType))\n      .run()\n  }\n\n  return (\n    chain()\n    // try to convert node to default node if needed\n      .command(() => {\n        const canWrapInList = can().wrapInList(listType, attributes)\n\n        const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name))\n\n        tr.ensureMarks(filteredMarks)\n\n        if (canWrapInList) {\n          return true\n        }\n\n        return commands.clearNodes()\n      })\n      .wrapInList(listType, attributes)\n      .command(() => joinListBackwards(tr, listType))\n      .command(() => joinListForwards(tr, listType))\n      .run()\n  )\n}\n","import { MarkType } from '@tiptap/pm/model'\n\nimport { getMarkType } from '../helpers/getMarkType.js'\nimport { isMarkActive } from '../helpers/isMarkActive.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    toggleMark: {\n      /**\n       * Toggle a mark on and off.\n       */\n      toggleMark: (\n        typeOrName: string | MarkType,\n        attributes?: Record<string, any>,\n        options?: {\n          /**\n           * Removes the mark even across the current selection. Defaults to `false`.\n           */\n          extendEmptyMarkRange?: boolean\n        },\n      ) => ReturnType\n    }\n  }\n}\n\nexport const toggleMark: RawCommands['toggleMark'] = (typeOrName, attributes = {}, options = {}) => ({ state, commands }) => {\n  const { extendEmptyMarkRange = false } = options\n  const type = getMarkType(typeOrName, state.schema)\n  const isActive = isMarkActive(state, type, attributes)\n\n  if (isActive) {\n    return commands.unsetMark(type, { extendEmptyMarkRange })\n  }\n\n  return commands.setMark(type, attributes)\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { isNodeActive } from '../helpers/isNodeActive.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    toggleNode: {\n      /**\n       * Toggle a node with another node.\n       */\n      toggleNode: (\n        typeOrName: string | NodeType,\n        toggleTypeOrName: string | NodeType,\n        attributes?: Record<string, any>,\n      ) => ReturnType\n    }\n  }\n}\n\nexport const toggleNode: RawCommands['toggleNode'] = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const toggleType = getNodeType(toggleTypeOrName, state.schema)\n  const isActive = isNodeActive(state, type, attributes)\n\n  if (isActive) {\n    return commands.setNode(toggleType)\n  }\n\n  return commands.setNode(type, attributes)\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { isNodeActive } from '../helpers/isNodeActive.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    toggleWrap: {\n      /**\n       * Wraps nodes in another node, or removes an existing wrap.\n       */\n      toggleWrap: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const toggleWrap: RawCommands['toggleWrap'] = (typeOrName, attributes = {}) => ({ state, commands }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const isActive = isNodeActive(state, type, attributes)\n\n  if (isActive) {\n    return commands.lift(type)\n  }\n\n  return commands.wrapIn(type, attributes)\n}\n","import { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    undoInputRule: {\n      /**\n       * Undo an input rule.\n       */\n      undoInputRule: () => ReturnType,\n    }\n  }\n}\n\nexport const undoInputRule: RawCommands['undoInputRule'] = () => ({ state, dispatch }) => {\n  const plugins = state.plugins\n\n  for (let i = 0; i < plugins.length; i += 1) {\n    const plugin = plugins[i]\n    let undoable\n\n    // @ts-ignore\n    // eslint-disable-next-line\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        const tr = state.tr\n        const toUndo = undoable.transform\n\n        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {\n          tr.step(toUndo.steps[j].invert(toUndo.docs[j]))\n        }\n\n        if (undoable.text) {\n          const marks = tr.doc.resolve(undoable.from).marks()\n\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks))\n        } else {\n          tr.delete(undoable.from, undoable.to)\n        }\n      }\n\n      return true\n    }\n  }\n\n  return false\n}\n","import { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    unsetAllMarks: {\n      /**\n       * Remove all marks in the current selection.\n       */\n      unsetAllMarks: () => ReturnType,\n    }\n  }\n}\n\nexport const unsetAllMarks: RawCommands['unsetAllMarks'] = () => ({ tr, dispatch }) => {\n  const { selection } = tr\n  const { empty, ranges } = selection\n\n  if (empty) {\n    return true\n  }\n\n  if (dispatch) {\n    ranges.forEach(range => {\n      tr.removeMark(range.$from.pos, range.$to.pos)\n    })\n  }\n\n  return true\n}\n","import { MarkType } from '@tiptap/pm/model'\n\nimport { getMarkRange } from '../helpers/getMarkRange.js'\nimport { getMarkType } from '../helpers/getMarkType.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    unsetMark: {\n      /**\n       * Remove all marks in the current selection.\n       */\n      unsetMark: (\n        typeOrName: string | MarkType,\n        options?: {\n          /**\n           * Removes the mark even across the current selection. Defaults to `false`.\n           */\n          extendEmptyMarkRange?: boolean\n        },\n      ) => ReturnType\n    }\n  }\n}\n\nexport const unsetMark: RawCommands['unsetMark'] = (typeOrName, options = {}) => ({ tr, state, dispatch }) => {\n  const { extendEmptyMarkRange = false } = options\n  const { selection } = tr\n  const type = getMarkType(typeOrName, state.schema)\n  const { $from, empty, ranges } = selection\n\n  if (!dispatch) {\n    return true\n  }\n\n  if (empty && extendEmptyMarkRange) {\n    let { from, to } = selection\n    const attrs = $from.marks().find(mark => mark.type === type)?.attrs\n    const range = getMarkRange($from, type, attrs)\n\n    if (range) {\n      from = range.from\n      to = range.to\n    }\n\n    tr.removeMark(from, to, type)\n  } else {\n    ranges.forEach(range => {\n      tr.removeMark(range.$from.pos, range.$to.pos, type)\n    })\n  }\n\n  tr.removeStoredMark(type)\n\n  return true\n}\n","import { MarkType, NodeType } from '@tiptap/pm/model'\n\nimport { getMarkType } from '../helpers/getMarkType.js'\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { getSchemaTypeNameByName } from '../helpers/getSchemaTypeNameByName.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    updateAttributes: {\n      /**\n       * Update attributes of a node or mark.\n       */\n      updateAttributes: (\n        typeOrName: string | NodeType | MarkType,\n        attributes: Record<string, any>,\n      ) => ReturnType\n    }\n  }\n}\n\nexport const updateAttributes: RawCommands['updateAttributes'] = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  let nodeType: NodeType | null = null\n  let markType: MarkType | null = null\n\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === 'string' ? typeOrName : typeOrName.name,\n    state.schema,\n  )\n\n  if (!schemaType) {\n    return false\n  }\n\n  if (schemaType === 'node') {\n    nodeType = getNodeType(typeOrName as NodeType, state.schema)\n  }\n\n  if (schemaType === 'mark') {\n    markType = getMarkType(typeOrName as MarkType, state.schema)\n  }\n\n  if (dispatch) {\n    tr.selection.ranges.forEach(range => {\n      const from = range.$from.pos\n      const to = range.$to.pos\n\n      state.doc.nodesBetween(from, to, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, undefined, {\n            ...node.attrs,\n            ...attributes,\n          })\n        }\n\n        if (markType && node.marks.length) {\n          node.marks.forEach(mark => {\n            if (markType === mark.type) {\n              const trimmedFrom = Math.max(pos, from)\n              const trimmedTo = Math.min(pos + node.nodeSize, to)\n\n              tr.addMark(\n                trimmedFrom,\n                trimmedTo,\n                markType.create({\n                  ...mark.attrs,\n                  ...attributes,\n                }),\n              )\n            }\n          })\n        }\n      })\n    })\n  }\n\n  return true\n}\n","import { wrapIn as originalWrapIn } from '@tiptap/pm/commands'\nimport { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    wrapIn: {\n      /**\n       * Wraps nodes in another node.\n       */\n      wrapIn: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const wrapIn: RawCommands['wrapIn'] = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalWrapIn(type, attributes)(state, dispatch)\n}\n","import { NodeType } from '@tiptap/pm/model'\nimport { wrapInList as originalWrapInList } from '@tiptap/pm/schema-list'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    wrapInList: {\n      /**\n       * Wrap a node in a list.\n       */\n      wrapInList: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const wrapInList: RawCommands['wrapInList'] = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalWrapInList(type, attributes)(state, dispatch)\n}\n","import * as commands from '../commands/index.js'\nimport { Extension } from '../Extension.js'\n\nexport * from '../commands/index.js'\n\nexport const Commands = Extension.create({\n  name: 'commands',\n\n  addCommands() {\n    return {\n      ...commands,\n    }\n  },\n})\n","import { Plugin, PluginKey } from '@tiptap/pm/state'\n\nimport { Extension } from '../Extension.js'\n\nexport const Editable = Extension.create({\n  name: 'editable',\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('editable'),\n        props: {\n          editable: () => this.editor.options.editable,\n        },\n      }),\n    ]\n  },\n})\n","import { Plugin, PluginKey } from '@tiptap/pm/state'\n\nimport { Extension } from '../Extension.js'\n\nexport const FocusEvents = Extension.create({\n  name: 'focusEvents',\n\n  addProseMirrorPlugins() {\n    const { editor } = this\n\n    return [\n      new Plugin({\n        key: new PluginKey('focusEvents'),\n        props: {\n          handleDOMEvents: {\n            focus: (view, event: Event) => {\n              editor.isFocused = true\n\n              const transaction = editor.state.tr\n                .setMeta('focus', { event })\n                .setMeta('addToHistory', false)\n\n              view.dispatch(transaction)\n\n              return false\n            },\n            blur: (view, event: Event) => {\n              editor.isFocused = false\n\n              const transaction = editor.state.tr\n                .setMeta('blur', { event })\n                .setMeta('addToHistory', false)\n\n              view.dispatch(transaction)\n\n              return false\n            },\n          },\n        },\n      }),\n    ]\n  },\n})\n","import { Plugin, PluginKey, Selection } from '@tiptap/pm/state'\n\nimport { CommandManager } from '../CommandManager.js'\nimport { Extension } from '../Extension.js'\nimport { createChainableState } from '../helpers/createChainableState.js'\nimport { isiOS } from '../utilities/isiOS.js'\nimport { isMacOS } from '../utilities/isMacOS.js'\n\nexport const Keymap = Extension.create({\n  name: 'keymap',\n\n  addKeyboardShortcuts() {\n    const handleBackspace = () => this.editor.commands.first(({ commands }) => [\n      () => commands.undoInputRule(),\n\n      // maybe convert first text block node to default node\n      () => commands.command(({ tr }) => {\n        const { selection, doc } = tr\n        const { empty, $anchor } = selection\n        const { pos, parent } = $anchor\n        const $parentPos = $anchor.parent.isTextblock ? tr.doc.resolve(pos - 1) : $anchor\n        const parentIsIsolating = $parentPos.parent.type.spec.isolating\n\n        const parentPos = $anchor.pos - $anchor.parentOffset\n\n        const isAtStart = (parentIsIsolating && $parentPos.parent.childCount === 1)\n          ? parentPos === $anchor.pos\n          : Selection.atStart(doc).from === pos\n\n        if (!empty || !isAtStart || !parent.type.isTextblock || parent.textContent.length) {\n          return false\n        }\n\n        return commands.clearNodes()\n      }),\n\n      () => commands.deleteSelection(),\n      () => commands.joinBackward(),\n      () => commands.selectNodeBackward(),\n    ])\n\n    const handleDelete = () => this.editor.commands.first(({ commands }) => [\n      () => commands.deleteSelection(),\n      () => commands.deleteCurrentNode(),\n      () => commands.joinForward(),\n      () => commands.selectNodeForward(),\n    ])\n\n    const handleEnter = () => this.editor.commands.first(({ commands }) => [\n      () => commands.newlineInCode(),\n      () => commands.createParagraphNear(),\n      () => commands.liftEmptyBlock(),\n      () => commands.splitBlock(),\n    ])\n\n    const baseKeymap = {\n      Enter: handleEnter,\n      'Mod-Enter': () => this.editor.commands.exitCode(),\n      Backspace: handleBackspace,\n      'Mod-Backspace': handleBackspace,\n      'Shift-Backspace': handleBackspace,\n      Delete: handleDelete,\n      'Mod-Delete': handleDelete,\n      'Mod-a': () => this.editor.commands.selectAll(),\n    }\n\n    const pcKeymap = {\n      ...baseKeymap,\n    }\n\n    const macKeymap = {\n      ...baseKeymap,\n      'Ctrl-h': handleBackspace,\n      'Alt-Backspace': handleBackspace,\n      'Ctrl-d': handleDelete,\n      'Ctrl-Alt-Backspace': handleDelete,\n      'Alt-Delete': handleDelete,\n      'Alt-d': handleDelete,\n      'Ctrl-a': () => this.editor.commands.selectTextblockStart(),\n      'Ctrl-e': () => this.editor.commands.selectTextblockEnd(),\n    }\n\n    if (isiOS() || isMacOS()) {\n      return macKeymap\n    }\n\n    return pcKeymap\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      // With this plugin we check if the whole document was selected and deleted.\n      // In this case we will additionally call `clearNodes()` to convert e.g. a heading\n      // to a paragraph if necessary.\n      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well\n      // with many other commands.\n      new Plugin({\n        key: new PluginKey('clearDocument'),\n        appendTransaction: (transactions, oldState, newState) => {\n          const docChanges = transactions.some(transaction => transaction.docChanged)\n            && !oldState.doc.eq(newState.doc)\n\n          if (!docChanges) {\n            return\n          }\n\n          const { empty, from, to } = oldState.selection\n          const allFrom = Selection.atStart(oldState.doc).from\n          const allEnd = Selection.atEnd(oldState.doc).to\n          const allWasSelected = from === allFrom && to === allEnd\n\n          if (empty || !allWasSelected) {\n            return\n          }\n\n          const isEmpty = newState.doc.textBetween(0, newState.doc.content.size, ' ', ' ').length === 0\n\n          if (!isEmpty) {\n            return\n          }\n\n          const tr = newState.tr\n          const state = createChainableState({\n            state: newState,\n            transaction: tr,\n          })\n          const { commands } = new CommandManager({\n            editor: this.editor,\n            state,\n          })\n\n          commands.clearNodes()\n\n          if (!tr.steps.length) {\n            return\n          }\n\n          return tr\n        },\n      }),\n    ]\n  },\n})\n","import { Plugin, PluginKey } from '@tiptap/pm/state'\n\nimport { Extension } from '../Extension.js'\n\nexport const Tabindex = Extension.create({\n  name: 'tabindex',\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('tabindex'),\n        props: {\n          attributes: this.editor.isEditable ? { tabindex: '0' } : {},\n        },\n      }),\n    ]\n  },\n})\n","export const style = `.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: \"liga\" 0; /* the above doesn't seem to work in Edge */\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 1px !important;\n  height: 1px !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}`\n","export function createStyleTag(style: string, nonce?: string, suffix?: string): HTMLStyleElement {\n  const tiptapStyleTag = (<HTMLStyleElement>document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : ''}]`))\n\n  if (tiptapStyleTag !== null) {\n    return tiptapStyleTag\n  }\n\n  const styleNode = document.createElement('style')\n\n  if (nonce) {\n    styleNode.setAttribute('nonce', nonce)\n  }\n\n  styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : ''}`, '')\n  styleNode.innerHTML = style\n  document.getElementsByTagName('head')[0].appendChild(styleNode)\n\n  return styleNode\n}\n","import { MarkType, NodeType, Schema } from '@tiptap/pm/model'\nimport {\n  EditorState, Plugin, PluginKey, Transaction,\n} from '@tiptap/pm/state'\nimport { EditorView } from '@tiptap/pm/view'\n\nimport { CommandManager } from './CommandManager.js'\nimport { EventEmitter } from './EventEmitter.js'\nimport { ExtensionManager } from './ExtensionManager.js'\nimport * as extensions from './extensions/index.js'\nimport { createDocument } from './helpers/createDocument.js'\nimport { getAttributes } from './helpers/getAttributes.js'\nimport { getHTMLFromFragment } from './helpers/getHTMLFromFragment.js'\nimport { getText } from './helpers/getText.js'\nimport { getTextSerializersFromSchema } from './helpers/getTextSerializersFromSchema.js'\nimport { isActive } from './helpers/isActive.js'\nimport { isNodeEmpty } from './helpers/isNodeEmpty.js'\nimport { resolveFocusPosition } from './helpers/resolveFocusPosition.js'\nimport { style } from './style.js'\nimport {\n  CanCommands,\n  ChainedCommands,\n  EditorEvents,\n  EditorOptions,\n  JSONContent,\n  SingleCommands,\n  TextSerializer,\n} from './types.js'\nimport { createStyleTag } from './utilities/createStyleTag.js'\nimport { isFunction } from './utilities/isFunction.js'\n\nexport { extensions }\n\nexport interface HTMLElement {\n  editor?: Editor\n}\n\nexport class Editor extends EventEmitter<EditorEvents> {\n  private commandManager!: CommandManager\n\n  public extensionManager!: ExtensionManager\n\n  private css!: HTMLStyleElement\n\n  public schema!: Schema\n\n  public view!: EditorView\n\n  public isFocused = false\n\n  public extensionStorage: Record<string, any> = {}\n\n  public options: EditorOptions = {\n    element: document.createElement('div'),\n    content: '',\n    injectCSS: true,\n    injectNonce: undefined,\n    extensions: [],\n    autofocus: false,\n    editable: true,\n    editorProps: {},\n    parseOptions: {},\n    enableInputRules: true,\n    enablePasteRules: true,\n    enableCoreExtensions: true,\n    onBeforeCreate: () => null,\n    onCreate: () => null,\n    onUpdate: () => null,\n    onSelectionUpdate: () => null,\n    onTransaction: () => null,\n    onFocus: () => null,\n    onBlur: () => null,\n    onDestroy: () => null,\n  }\n\n  constructor(options: Partial<EditorOptions> = {}) {\n    super()\n    this.setOptions(options)\n    this.createExtensionManager()\n    this.createCommandManager()\n    this.createSchema()\n    this.on('beforeCreate', this.options.onBeforeCreate)\n    this.emit('beforeCreate', { editor: this })\n    this.createView()\n    this.injectCSS()\n    this.on('create', this.options.onCreate)\n    this.on('update', this.options.onUpdate)\n    this.on('selectionUpdate', this.options.onSelectionUpdate)\n    this.on('transaction', this.options.onTransaction)\n    this.on('focus', this.options.onFocus)\n    this.on('blur', this.options.onBlur)\n    this.on('destroy', this.options.onDestroy)\n\n    window.setTimeout(() => {\n      if (this.isDestroyed) {\n        return\n      }\n\n      this.commands.focus(this.options.autofocus)\n      this.emit('create', { editor: this })\n    }, 0)\n  }\n\n  /**\n   * Returns the editor storage.\n   */\n  public get storage(): Record<string, any> {\n    return this.extensionStorage\n  }\n\n  /**\n   * An object of all registered commands.\n   */\n  public get commands(): SingleCommands {\n    return this.commandManager.commands\n  }\n\n  /**\n   * Create a command chain to call multiple commands at once.\n   */\n  public chain(): ChainedCommands {\n    return this.commandManager.chain()\n  }\n\n  /**\n   * Check if a command or a command chain can be executed. Without executing it.\n   */\n  public can(): CanCommands {\n    return this.commandManager.can()\n  }\n\n  /**\n   * Inject CSS styles.\n   */\n  private injectCSS(): void {\n    if (this.options.injectCSS && document) {\n      this.css = createStyleTag(style, this.options.injectNonce)\n    }\n  }\n\n  /**\n   * Update editor options.\n   *\n   * @param options A list of options\n   */\n  public setOptions(options: Partial<EditorOptions> = {}): void {\n    this.options = {\n      ...this.options,\n      ...options,\n    }\n\n    if (!this.view || !this.state || this.isDestroyed) {\n      return\n    }\n\n    if (this.options.editorProps) {\n      this.view.setProps(this.options.editorProps)\n    }\n\n    this.view.updateState(this.state)\n  }\n\n  /**\n   * Update editable state of the editor.\n   */\n  public setEditable(editable: boolean, emitUpdate = true): void {\n    this.setOptions({ editable })\n\n    if (emitUpdate) {\n      this.emit('update', { editor: this, transaction: this.state.tr })\n    }\n  }\n\n  /**\n   * Returns whether the editor is editable.\n   */\n  public get isEditable(): boolean {\n    // since plugins are applied after creating the view\n    // `editable` is always `true` for one tick.\n    // that’s why we also have to check for `options.editable`\n    return this.options.editable && this.view && this.view.editable\n  }\n\n  /**\n   * Returns the editor state.\n   */\n  public get state(): EditorState {\n    return this.view.state\n  }\n\n  /**\n   * Register a ProseMirror plugin.\n   *\n   * @param plugin A ProseMirror plugin\n   * @param handlePlugins Control how to merge the plugin into the existing plugins.\n   */\n  public registerPlugin(\n    plugin: Plugin,\n    handlePlugins?: (newPlugin: Plugin, plugins: Plugin[]) => Plugin[],\n  ): void {\n    const plugins = isFunction(handlePlugins)\n      ? handlePlugins(plugin, [...this.state.plugins])\n      : [...this.state.plugins, plugin]\n\n    const state = this.state.reconfigure({ plugins })\n\n    this.view.updateState(state)\n  }\n\n  /**\n   * Unregister a ProseMirror plugin.\n   *\n   * @param nameOrPluginKey The plugins name\n   */\n  public unregisterPlugin(nameOrPluginKey: string | PluginKey): void {\n    if (this.isDestroyed) {\n      return\n    }\n\n    // @ts-ignore\n    const name = typeof nameOrPluginKey === 'string' ? `${nameOrPluginKey}$` : nameOrPluginKey.key\n\n    const state = this.state.reconfigure({\n      // @ts-ignore\n      plugins: this.state.plugins.filter(plugin => !plugin.key.startsWith(name)),\n    })\n\n    this.view.updateState(state)\n  }\n\n  /**\n   * Creates an extension manager.\n   */\n  private createExtensionManager(): void {\n    const coreExtensions = this.options.enableCoreExtensions ? Object.values(extensions) : []\n    const allExtensions = [...coreExtensions, ...this.options.extensions].filter(extension => {\n      return ['extension', 'node', 'mark'].includes(extension?.type)\n    })\n\n    this.extensionManager = new ExtensionManager(allExtensions, this)\n  }\n\n  /**\n   * Creates an command manager.\n   */\n  private createCommandManager(): void {\n    this.commandManager = new CommandManager({\n      editor: this,\n    })\n  }\n\n  /**\n   * Creates a ProseMirror schema.\n   */\n  private createSchema(): void {\n    this.schema = this.extensionManager.schema\n  }\n\n  /**\n   * Creates a ProseMirror view.\n   */\n  private createView(): void {\n    const doc = createDocument(this.options.content, this.schema, this.options.parseOptions)\n    const selection = resolveFocusPosition(doc, this.options.autofocus)\n\n    this.view = new EditorView(this.options.element, {\n      ...this.options.editorProps,\n      dispatchTransaction: this.dispatchTransaction.bind(this),\n      state: EditorState.create({\n        doc,\n        selection: selection || undefined,\n      }),\n    })\n\n    // `editor.view` is not yet available at this time.\n    // Therefore we will add all plugins and node views directly afterwards.\n    const newState = this.state.reconfigure({\n      plugins: this.extensionManager.plugins,\n    })\n\n    this.view.updateState(newState)\n\n    this.createNodeViews()\n    this.prependClass()\n\n    // Let’s store the editor instance in the DOM element.\n    // So we’ll have access to it for tests.\n    const dom = this.view.dom as HTMLElement\n\n    dom.editor = this\n  }\n\n  /**\n   * Creates all node views.\n   */\n  public createNodeViews(): void {\n    this.view.setProps({\n      nodeViews: this.extensionManager.nodeViews,\n    })\n  }\n\n  /**\n   * Prepend class name to element.\n   */\n  public prependClass(): void {\n    this.view.dom.className = `tiptap ${this.view.dom.className}`\n  }\n\n  public isCapturingTransaction = false\n\n  private capturedTransaction: Transaction | null = null\n\n  public captureTransaction(fn: Function) {\n    this.isCapturingTransaction = true\n    fn()\n    this.isCapturingTransaction = false\n\n    const tr = this.capturedTransaction\n\n    this.capturedTransaction = null\n\n    return tr\n  }\n\n  /**\n   * The callback over which to send transactions (state updates) produced by the view.\n   *\n   * @param transaction An editor state transaction\n   */\n  private dispatchTransaction(transaction: Transaction): void {\n    // if the editor / the view of the editor was destroyed\n    // the transaction should not be dispatched as there is no view anymore.\n    if (this.view.isDestroyed) {\n      return\n    }\n\n    if (this.isCapturingTransaction) {\n      if (!this.capturedTransaction) {\n        this.capturedTransaction = transaction\n\n        return\n      }\n\n      transaction.steps.forEach(step => this.capturedTransaction?.step(step))\n\n      return\n    }\n\n    const state = this.state.apply(transaction)\n    const selectionHasChanged = !this.state.selection.eq(state.selection)\n\n    this.view.updateState(state)\n    this.emit('transaction', {\n      editor: this,\n      transaction,\n    })\n\n    if (selectionHasChanged) {\n      this.emit('selectionUpdate', {\n        editor: this,\n        transaction,\n      })\n    }\n\n    const focus = transaction.getMeta('focus')\n    const blur = transaction.getMeta('blur')\n\n    if (focus) {\n      this.emit('focus', {\n        editor: this,\n        event: focus.event,\n        transaction,\n      })\n    }\n\n    if (blur) {\n      this.emit('blur', {\n        editor: this,\n        event: blur.event,\n        transaction,\n      })\n    }\n\n    if (!transaction.docChanged || transaction.getMeta('preventUpdate')) {\n      return\n    }\n\n    this.emit('update', {\n      editor: this,\n      transaction,\n    })\n  }\n\n  /**\n   * Get attributes of the currently selected node or mark.\n   */\n  public getAttributes(nameOrType: string | NodeType | MarkType): Record<string, any> {\n    return getAttributes(this.state, nameOrType)\n  }\n\n  /**\n   * Returns if the currently selected node or mark is active.\n   *\n   * @param name Name of the node or mark\n   * @param attributes Attributes of the node or mark\n   */\n  public isActive(name: string, attributes?: {}): boolean\n  public isActive(attributes: {}): boolean\n  public isActive(nameOrAttributes: string, attributesOrUndefined?: {}): boolean {\n    const name = typeof nameOrAttributes === 'string' ? nameOrAttributes : null\n\n    const attributes = typeof nameOrAttributes === 'string' ? attributesOrUndefined : nameOrAttributes\n\n    return isActive(this.state, name, attributes)\n  }\n\n  /**\n   * Get the document as JSON.\n   */\n  public getJSON(): JSONContent {\n    return this.state.doc.toJSON()\n  }\n\n  /**\n   * Get the document as HTML.\n   */\n  public getHTML(): string {\n    return getHTMLFromFragment(this.state.doc.content, this.schema)\n  }\n\n  /**\n   * Get the document as text.\n   */\n  public getText(options?: {\n    blockSeparator?: string\n    textSerializers?: Record<string, TextSerializer>\n  }): string {\n    const { blockSeparator = '\\n\\n', textSerializers = {} } = options || {}\n\n    return getText(this.state.doc, {\n      blockSeparator,\n      textSerializers: {\n        ...getTextSerializersFromSchema(this.schema),\n        ...textSerializers,\n      },\n    })\n  }\n\n  /**\n   * Check if there is no content.\n   */\n  public get isEmpty(): boolean {\n    return isNodeEmpty(this.state.doc)\n  }\n\n  /**\n   * Get the number of characters for the current document.\n   *\n   * @deprecated\n   */\n  public getCharacterCount(): number {\n    console.warn(\n      '[tiptap warn]: \"editor.getCharacterCount()\" is deprecated. Please use \"editor.storage.characterCount.characters()\" instead.',\n    )\n\n    return this.state.doc.content.size - 2\n  }\n\n  /**\n   * Destroy the editor.\n   */\n  public destroy(): void {\n    this.emit('destroy')\n\n    if (this.view) {\n      this.view.destroy()\n    }\n\n    this.removeAllListeners()\n  }\n\n  /**\n   * Check if the editor is already destroyed.\n   */\n  public get isDestroyed(): boolean {\n    // @ts-ignore\n    return !this.view?.docView\n  }\n}\n","import { MarkType } from '@tiptap/pm/model'\n\nimport { getMarksBetween } from '../helpers/getMarksBetween.js'\nimport { InputRule, InputRuleFinder } from '../InputRule.js'\nimport { ExtendedRegExpMatchArray } from '../types.js'\nimport { callOrReturn } from '../utilities/callOrReturn.js'\n\n/**\n * Build an input rule that adds a mark when the\n * matched text is typed into it.\n */\nexport function markInputRule(config: {\n  find: InputRuleFinder\n  type: MarkType\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n    | false\n    | null\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match)\n\n      if (attributes === false || attributes === null) {\n        return null\n      }\n\n      const { tr } = state\n      const captureGroup = match[match.length - 1]\n      const fullMatch = match[0]\n\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/)\n        const textStart = range.from + fullMatch.indexOf(captureGroup)\n        const textEnd = textStart + captureGroup.length\n\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc)\n          .filter(item => {\n            // @ts-ignore\n            const excluded = item.mark.type.excluded as MarkType[]\n\n            return excluded.find(type => type === config.type && type !== item.mark.type)\n          })\n          .filter(item => item.to > textStart)\n\n        if (excludedMarks.length) {\n          return null\n        }\n\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to)\n        }\n\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart)\n        }\n\n        const markEnd = range.from + startSpaces + captureGroup.length\n\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}))\n\n        tr.removeStoredMark(config.type)\n      }\n    },\n  })\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { InputRule, InputRuleFinder } from '../InputRule.js'\nimport { ExtendedRegExpMatchArray } from '../types.js'\nimport { callOrReturn } from '../utilities/callOrReturn.js'\n\n/**\n * Build an input rule that adds a node when the\n * matched text is typed into it.\n */\nexport function nodeInputRule(config: {\n  /**\n   * The regex to match.\n   */\n  find: InputRuleFinder\n\n  /**\n   * The node type to add.\n   */\n  type: NodeType\n\n  /**\n   * A function that returns the attributes for the node\n   * can also be an object of attributes\n   */\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n    | false\n    | null\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {}\n      const { tr } = state\n      const start = range.from\n      let end = range.to\n\n      const newNode = config.type.create(attributes)\n\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1])\n        let matchStart = start + offset\n\n        if (matchStart > end) {\n          matchStart = end\n        } else {\n          end = matchStart + match[1].length\n        }\n\n        // insert last typed character\n        const lastChar = match[0][match[0].length - 1]\n\n        tr.insertText(lastChar, start + match[0].length - 1)\n\n        // insert node from input rule\n        tr.replaceWith(matchStart, end, newNode)\n      } else if (match[0]) {\n        tr.insert(start - 1, config.type.create(attributes)).delete(\n          tr.mapping.map(start),\n          tr.mapping.map(end),\n        )\n      }\n\n      tr.scrollIntoView()\n    },\n  })\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { InputRule, InputRuleFinder } from '../InputRule.js'\nimport { ExtendedRegExpMatchArray } from '../types.js'\nimport { callOrReturn } from '../utilities/callOrReturn.js'\n\n/**\n * Build an input rule that changes the type of a textblock when the\n * matched text is typed into it. When using a regular expresion you’ll\n * probably want the regexp to start with `^`, so that the pattern can\n * only occur at the start of a textblock.\n */\nexport function textblockTypeInputRule(config: {\n  find: InputRuleFinder\n  type: NodeType\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n    | false\n    | null\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const $start = state.doc.resolve(range.from)\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {}\n\n      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {\n        return null\n      }\n\n      state.tr\n        .delete(range.from, range.to)\n        .setBlockType(range.from, range.from, config.type, attributes)\n    },\n  })\n}\n","import { InputRule, InputRuleFinder } from '../InputRule.js'\n\n/**\n * Build an input rule that replaces text when the\n * matched text is typed into it.\n */\nexport function textInputRule(config: {\n  find: InputRuleFinder,\n  replace: string,\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      let insert = config.replace\n      let start = range.from\n      const end = range.to\n\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1])\n\n        insert += match[0].slice(offset + match[1].length)\n        start += offset\n\n        const cutOff = start - end\n\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert\n          start = end\n        }\n      }\n\n      state.tr.insertText(insert, start, end)\n    },\n  })\n}\n","import { Node as ProseMirrorNode, NodeType } from '@tiptap/pm/model'\nimport { canJoin, findWrapping } from '@tiptap/pm/transform'\n\nimport { Editor } from '../Editor.js'\nimport { InputRule, InputRuleFinder } from '../InputRule.js'\nimport { ExtendedRegExpMatchArray } from '../types.js'\nimport { callOrReturn } from '../utilities/callOrReturn.js'\n\n/**\n * Build an input rule for automatically wrapping a textblock when a\n * given string is typed. When using a regular expresion you’ll\n * probably want the regexp to start with `^`, so that the pattern can\n * only occur at the start of a textblock.\n *\n * `type` is the type of node to wrap in.\n *\n * By default, if there’s a node with the same type above the newly\n * wrapped node, the rule will try to join those\n * two nodes. You can pass a join predicate, which takes a regular\n * expression match and the node before the wrapped node, and can\n * return a boolean to indicate whether a join should happen.\n */\nexport function wrappingInputRule(config: {\n  find: InputRuleFinder,\n  type: NodeType,\n  keepMarks?: boolean,\n  keepAttributes?: boolean,\n  editor?: Editor\n  getAttributes?:\n  | Record<string, any>\n  | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n  | false\n  | null\n  ,\n  joinPredicate?: (match: ExtendedRegExpMatchArray, node: ProseMirrorNode) => boolean,\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({\n      state, range, match, chain,\n    }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {}\n      const tr = state.tr.delete(range.from, range.to)\n      const $start = tr.doc.resolve(range.from)\n      const blockRange = $start.blockRange()\n      const wrapping = blockRange && findWrapping(blockRange, config.type, attributes)\n\n      if (!wrapping) {\n        return null\n      }\n\n      tr.wrap(blockRange, wrapping)\n\n      if (config.keepMarks && config.editor) {\n        const { selection, storedMarks } = state\n        const { splittableMarks } = config.editor.extensionManager\n        const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks())\n\n        if (marks) {\n          const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name))\n\n          tr.ensureMarks(filteredMarks)\n        }\n      }\n      if (config.keepAttributes) {\n        /** If the nodeType is `bulletList` or `orderedList` set the `nodeType` as `listItem` */\n        const nodeType = config.type.name === 'bulletList' || config.type.name === 'orderedList' ? 'listItem' : 'taskList'\n\n        chain().updateAttributes(nodeType, attributes).run()\n      }\n\n      const before = tr.doc.resolve(range.from - 1).nodeBefore\n\n      if (\n        before\n        && before.type === config.type\n        && canJoin(tr.doc, range.from - 1)\n        && (!config.joinPredicate || config.joinPredicate(match, before))\n      ) {\n        tr.join(range.from - 1)\n      }\n    },\n  })\n}\n","import {\n  DOMOutputSpec, Mark as ProseMirrorMark, MarkSpec, MarkType,\n} from '@tiptap/pm/model'\nimport { Plugin, Transaction } from '@tiptap/pm/state'\n\nimport { Editor } from './Editor.js'\nimport { getExtensionField } from './helpers/getExtensionField.js'\nimport { MarkConfig } from './index.js'\nimport { InputRule } from './InputRule.js'\nimport { Node } from './Node.js'\nimport { PasteRule } from './PasteRule.js'\nimport {\n  AnyConfig,\n  Attributes,\n  Extensions,\n  GlobalAttributes,\n  KeyboardShortcutCommand,\n  ParentConfig,\n  RawCommands,\n} from './types.js'\nimport { callOrReturn } from './utilities/callOrReturn.js'\nimport { mergeDeep } from './utilities/mergeDeep.js'\n\ndeclare module '@tiptap/core' {\n  export interface MarkConfig<Options = any, Storage = any> {\n    [key: string]: any\n\n    /**\n     * Name\n     */\n    name: string\n\n    /**\n     * Priority\n     */\n    priority?: number\n\n    /**\n     * Default options\n     */\n    defaultOptions?: Options\n\n    /**\n     * Default Options\n     */\n    addOptions?: (this: {\n      name: string\n      parent: Exclude<ParentConfig<MarkConfig<Options, Storage>>['addOptions'], undefined>\n    }) => Options\n\n    /**\n     * Default Storage\n     */\n    addStorage?: (this: {\n      name: string\n      options: Options\n      parent: Exclude<ParentConfig<MarkConfig<Options, Storage>>['addStorage'], undefined>\n    }) => Storage\n\n    /**\n     * Global attributes\n     */\n    addGlobalAttributes?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addGlobalAttributes']\n    }) => GlobalAttributes | {}\n\n    /**\n     * Raw\n     */\n    addCommands?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: MarkType\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addCommands']\n    }) => Partial<RawCommands>\n\n    /**\n     * Keyboard shortcuts\n     */\n    addKeyboardShortcuts?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: MarkType\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addKeyboardShortcuts']\n    }) => {\n      [key: string]: KeyboardShortcutCommand\n    }\n\n    /**\n     * Input rules\n     */\n    addInputRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: MarkType\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addInputRules']\n    }) => InputRule[]\n\n    /**\n     * Paste rules\n     */\n    addPasteRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: MarkType\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addPasteRules']\n    }) => PasteRule[]\n\n    /**\n     * ProseMirror plugins\n     */\n    addProseMirrorPlugins?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: MarkType\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addProseMirrorPlugins']\n    }) => Plugin[]\n\n    /**\n     * Extensions\n     */\n    addExtensions?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addExtensions']\n    }) => Extensions\n\n    /**\n     * Extend Node Schema\n     */\n    extendNodeSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<MarkConfig<Options, Storage>>['extendNodeSchema']\n          },\n          extension: Node,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * Extend Mark Schema\n     */\n    extendMarkSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<MarkConfig<Options, Storage>>['extendMarkSchema']\n          },\n          extension: Mark,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * The editor is not ready yet.\n     */\n    onBeforeCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: MarkType\n          parent: ParentConfig<MarkConfig<Options, Storage>>['onBeforeCreate']\n        }) => void)\n      | null\n\n    /**\n     * The editor is ready.\n     */\n    onCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: MarkType\n          parent: ParentConfig<MarkConfig<Options, Storage>>['onCreate']\n        }) => void)\n      | null\n\n    /**\n     * The content has changed.\n     */\n    onUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: MarkType\n          parent: ParentConfig<MarkConfig<Options, Storage>>['onUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The selection has changed.\n     */\n    onSelectionUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: MarkType\n          parent: ParentConfig<MarkConfig<Options, Storage>>['onSelectionUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The editor state has changed.\n     */\n    onTransaction?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: MarkType\n            parent: ParentConfig<MarkConfig<Options, Storage>>['onTransaction']\n          },\n          props: {\n            transaction: Transaction\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is focused.\n     */\n    onFocus?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: MarkType\n            parent: ParentConfig<MarkConfig<Options, Storage>>['onFocus']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor isn’t focused anymore.\n     */\n    onBlur?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: MarkType\n            parent: ParentConfig<MarkConfig<Options, Storage>>['onBlur']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is destroyed.\n     */\n    onDestroy?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: MarkType\n          parent: ParentConfig<MarkConfig<Options, Storage>>['onDestroy']\n        }) => void)\n      | null\n\n    /**\n     * Keep mark after split node\n     */\n    keepOnSplit?: boolean | (() => boolean)\n\n    /**\n     * Inclusive\n     */\n    inclusive?:\n      | MarkSpec['inclusive']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<MarkConfig<Options, Storage>>['inclusive']\n          editor?: Editor\n        }) => MarkSpec['inclusive'])\n\n    /**\n     * Excludes\n     */\n    excludes?:\n      | MarkSpec['excludes']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<MarkConfig<Options, Storage>>['excludes']\n          editor?: Editor\n        }) => MarkSpec['excludes'])\n\n    /**\n     * Marks this Mark as exitable\n     */\n    exitable?: boolean | (() => boolean)\n\n    /**\n     * Group\n     */\n    group?:\n      | MarkSpec['group']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<MarkConfig<Options, Storage>>['group']\n          editor?: Editor\n        }) => MarkSpec['group'])\n\n    /**\n     * Spanning\n     */\n    spanning?:\n      | MarkSpec['spanning']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<MarkConfig<Options, Storage>>['spanning']\n          editor?: Editor\n        }) => MarkSpec['spanning'])\n\n    /**\n     * Code\n     */\n    code?:\n      | boolean\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<MarkConfig<Options, Storage>>['code']\n          editor?: Editor\n        }) => boolean)\n\n    /**\n     * Parse HTML\n     */\n    parseHTML?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<MarkConfig<Options, Storage>>['parseHTML']\n      editor?: Editor\n    }) => MarkSpec['parseDOM']\n\n    /**\n     * Render HTML\n     */\n    renderHTML?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<MarkConfig<Options, Storage>>['renderHTML']\n            editor?: Editor\n          },\n          props: {\n            mark: ProseMirrorMark\n            HTMLAttributes: Record<string, any>\n          },\n        ) => DOMOutputSpec)\n      | null\n\n    /**\n     * Attributes\n     */\n    addAttributes?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addAttributes']\n      editor?: Editor\n    }) => Attributes | {}\n  }\n}\n\nexport class Mark<Options = any, Storage = any> {\n  type = 'mark'\n\n  name = 'mark'\n\n  parent: Mark | null = null\n\n  child: Mark | null = null\n\n  options: Options\n\n  storage: Storage\n\n  config: MarkConfig = {\n    name: this.name,\n    defaultOptions: {},\n  }\n\n  constructor(config: Partial<MarkConfig<Options, Storage>> = {}) {\n    this.config = {\n      ...this.config,\n      ...config,\n    }\n\n    this.name = this.config.name\n\n    if (config.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`,\n      )\n    }\n\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions\n\n    if (this.config.addOptions) {\n      this.options = callOrReturn(\n        getExtensionField<AnyConfig['addOptions']>(this, 'addOptions', {\n          name: this.name,\n        }),\n      )\n    }\n\n    this.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(this, 'addStorage', {\n        name: this.name,\n        options: this.options,\n      }),\n    ) || {}\n  }\n\n  static create<O = any, S = any>(config: Partial<MarkConfig<O, S>> = {}) {\n    return new Mark<O, S>(config)\n  }\n\n  configure(options: Partial<Options> = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend()\n\n    extension.options = mergeDeep(this.options as Record<string, any>, options) as Options\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n\n  extend<ExtendedOptions = Options, ExtendedStorage = Storage>(\n    extendedConfig: Partial<MarkConfig<ExtendedOptions, ExtendedStorage>> = {},\n  ) {\n    const extension = new Mark<ExtendedOptions, ExtendedStorage>(extendedConfig)\n\n    extension.parent = this\n\n    this.child = extension\n\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name\n\n    if (extendedConfig.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`,\n      )\n    }\n\n    extension.options = callOrReturn(\n      getExtensionField<AnyConfig['addOptions']>(extension, 'addOptions', {\n        name: extension.name,\n      }),\n    )\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n\n  static handleExit({ editor, mark }: { editor: Editor; mark: Mark }) {\n    const { tr } = editor.state\n    const currentPos = editor.state.selection.$from\n    const isAtEnd = currentPos.pos === currentPos.end()\n\n    if (isAtEnd) {\n      const currentMarks = currentPos.marks()\n      const isInMark = !!currentMarks.find(m => m?.type.name === mark.name)\n\n      if (!isInMark) {\n        return false\n      }\n\n      const removeMark = currentMarks.find(m => m?.type.name === mark.name)\n\n      if (removeMark) {\n        tr.removeStoredMark(removeMark)\n      }\n      tr.insertText(' ', currentPos.pos)\n\n      editor.view.dispatch(tr)\n\n      return true\n    }\n\n    return false\n  }\n}\n","import {\n  DOMOutputSpec, Node as ProseMirrorNode, NodeSpec, NodeType,\n} from '@tiptap/pm/model'\nimport { Plugin, Transaction } from '@tiptap/pm/state'\n\nimport { Editor } from './Editor.js'\nimport { getExtensionField } from './helpers/getExtensionField.js'\nimport { NodeConfig } from './index.js'\nimport { InputRule } from './InputRule.js'\nimport { PasteRule } from './PasteRule.js'\nimport {\n  AnyConfig,\n  Attributes,\n  Extensions,\n  GlobalAttributes,\n  KeyboardShortcutCommand,\n  NodeViewRenderer,\n  ParentConfig,\n  RawCommands,\n} from './types.js'\nimport { callOrReturn } from './utilities/callOrReturn.js'\nimport { mergeDeep } from './utilities/mergeDeep.js'\n\ndeclare module '@tiptap/core' {\n  interface NodeConfig<Options = any, Storage = any> {\n    [key: string]: any\n\n    /**\n     * Name\n     */\n    name: string\n\n    /**\n     * Priority\n     */\n    priority?: number\n\n    /**\n     * Default options\n     */\n    defaultOptions?: Options\n\n    /**\n     * Default Options\n     */\n    addOptions?: (this: {\n      name: string\n      parent: Exclude<ParentConfig<NodeConfig<Options, Storage>>['addOptions'], undefined>\n    }) => Options\n\n    /**\n     * Default Storage\n     */\n    addStorage?: (this: {\n      name: string\n      options: Options\n      parent: Exclude<ParentConfig<NodeConfig<Options, Storage>>['addStorage'], undefined>\n    }) => Storage\n\n    /**\n     * Global attributes\n     */\n    addGlobalAttributes?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addGlobalAttributes']\n    }) => GlobalAttributes | {}\n\n    /**\n     * Raw\n     */\n    addCommands?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: NodeType\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addCommands']\n    }) => Partial<RawCommands>\n\n    /**\n     * Keyboard shortcuts\n     */\n    addKeyboardShortcuts?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: NodeType\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addKeyboardShortcuts']\n    }) => {\n      [key: string]: KeyboardShortcutCommand\n    }\n\n    /**\n     * Input rules\n     */\n    addInputRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: NodeType\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addInputRules']\n    }) => InputRule[]\n\n    /**\n     * Paste rules\n     */\n    addPasteRules?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: NodeType\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addPasteRules']\n    }) => PasteRule[]\n\n    /**\n     * ProseMirror plugins\n     */\n    addProseMirrorPlugins?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      editor: Editor\n      type: NodeType\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addProseMirrorPlugins']\n    }) => Plugin[]\n\n    /**\n     * Extensions\n     */\n    addExtensions?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addExtensions']\n    }) => Extensions\n\n    /**\n     * Extend Node Schema\n     */\n    extendNodeSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<NodeConfig<Options, Storage>>['extendNodeSchema']\n          },\n          extension: Node,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * Extend Mark Schema\n     */\n    extendMarkSchema?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<NodeConfig<Options, Storage>>['extendMarkSchema']\n            editor?: Editor\n          },\n          extension: Node,\n        ) => Record<string, any>)\n      | null\n\n    /**\n     * The editor is not ready yet.\n     */\n    onBeforeCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['onBeforeCreate']\n        }) => void)\n      | null\n\n    /**\n     * The editor is ready.\n     */\n    onCreate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['onCreate']\n        }) => void)\n      | null\n\n    /**\n     * The content has changed.\n     */\n    onUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['onUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The selection has changed.\n     */\n    onSelectionUpdate?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['onSelectionUpdate']\n        }) => void)\n      | null\n\n    /**\n     * The editor state has changed.\n     */\n    onTransaction?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: NodeType\n            parent: ParentConfig<NodeConfig<Options, Storage>>['onTransaction']\n          },\n          props: {\n            transaction: Transaction\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is focused.\n     */\n    onFocus?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: NodeType\n            parent: ParentConfig<NodeConfig<Options, Storage>>['onFocus']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor isn’t focused anymore.\n     */\n    onBlur?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            editor: Editor\n            type: NodeType\n            parent: ParentConfig<NodeConfig<Options, Storage>>['onBlur']\n          },\n          props: {\n            event: FocusEvent\n          },\n        ) => void)\n      | null\n\n    /**\n     * The editor is destroyed.\n     */\n    onDestroy?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['onDestroy']\n        }) => void)\n      | null\n\n    /**\n     * Node View\n     */\n    addNodeView?:\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: NodeType\n          parent: ParentConfig<NodeConfig<Options, Storage>>['addNodeView']\n        }) => NodeViewRenderer)\n      | null\n\n    /**\n     * TopNode\n     */\n    topNode?: boolean\n\n    /**\n     * Content\n     */\n    content?:\n      | NodeSpec['content']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['content']\n          editor?: Editor\n        }) => NodeSpec['content'])\n\n    /**\n     * Marks\n     */\n    marks?:\n      | NodeSpec['marks']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['marks']\n          editor?: Editor\n        }) => NodeSpec['marks'])\n\n    /**\n     * Group\n     */\n    group?:\n      | NodeSpec['group']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['group']\n          editor?: Editor\n        }) => NodeSpec['group'])\n\n    /**\n     * Inline\n     */\n    inline?:\n      | NodeSpec['inline']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['inline']\n          editor?: Editor\n        }) => NodeSpec['inline'])\n\n    /**\n     * Atom\n     */\n    atom?:\n      | NodeSpec['atom']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['atom']\n          editor?: Editor\n        }) => NodeSpec['atom'])\n\n    /**\n     * Selectable\n     */\n    selectable?:\n      | NodeSpec['selectable']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['selectable']\n          editor?: Editor\n        }) => NodeSpec['selectable'])\n\n    /**\n     * Draggable\n     */\n    draggable?:\n      | NodeSpec['draggable']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['draggable']\n          editor?: Editor\n        }) => NodeSpec['draggable'])\n\n    /**\n     * Code\n     */\n    code?:\n      | NodeSpec['code']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['code']\n          editor?: Editor\n        }) => NodeSpec['code'])\n\n    /**\n     * Whitespace\n     */\n    whitespace?:\n      | NodeSpec['whitespace']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['whitespace']\n          editor?: Editor\n        }) => NodeSpec['whitespace'])\n\n    /**\n     * Defining\n     */\n    defining?:\n      | NodeSpec['defining']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['defining']\n          editor?: Editor\n        }) => NodeSpec['defining'])\n\n    /**\n     * Isolating\n     */\n    isolating?:\n      | NodeSpec['isolating']\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['isolating']\n          editor?: Editor\n        }) => NodeSpec['isolating'])\n\n    /**\n     * Parse HTML\n     */\n    parseHTML?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<NodeConfig<Options, Storage>>['parseHTML']\n      editor?: Editor\n    }) => NodeSpec['parseDOM']\n\n    /**\n     * Render HTML\n     */\n    renderHTML?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<NodeConfig<Options, Storage>>['renderHTML']\n            editor?: Editor\n          },\n          props: {\n            node: ProseMirrorNode\n            HTMLAttributes: Record<string, any>\n          },\n        ) => DOMOutputSpec)\n      | null\n\n    /**\n     * Render Text\n     */\n    renderText?:\n      | ((\n          this: {\n            name: string\n            options: Options\n            storage: Storage\n            parent: ParentConfig<NodeConfig<Options, Storage>>['renderText']\n            editor?: Editor\n          },\n          props: {\n            node: ProseMirrorNode\n            pos: number\n            parent: ProseMirrorNode\n            index: number\n          },\n        ) => string)\n      | null\n\n    /**\n     * Add Attributes\n     */\n    addAttributes?: (this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addAttributes']\n      editor?: Editor\n    }) => Attributes | {}\n  }\n}\n\nexport class Node<Options = any, Storage = any> {\n  type = 'node'\n\n  name = 'node'\n\n  parent: Node | null = null\n\n  child: Node | null = null\n\n  options: Options\n\n  storage: Storage\n\n  config: NodeConfig = {\n    name: this.name,\n    defaultOptions: {},\n  }\n\n  constructor(config: Partial<NodeConfig<Options, Storage>> = {}) {\n    this.config = {\n      ...this.config,\n      ...config,\n    }\n\n    this.name = this.config.name\n\n    if (config.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`,\n      )\n    }\n\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions\n\n    if (this.config.addOptions) {\n      this.options = callOrReturn(\n        getExtensionField<AnyConfig['addOptions']>(this, 'addOptions', {\n          name: this.name,\n        }),\n      )\n    }\n\n    this.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(this, 'addStorage', {\n        name: this.name,\n        options: this.options,\n      }),\n    ) || {}\n  }\n\n  static create<O = any, S = any>(config: Partial<NodeConfig<O, S>> = {}) {\n    return new Node<O, S>(config)\n  }\n\n  configure(options: Partial<Options> = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend()\n\n    extension.options = mergeDeep(this.options as Record<string, any>, options) as Options\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n\n  extend<ExtendedOptions = Options, ExtendedStorage = Storage>(\n    extendedConfig: Partial<NodeConfig<ExtendedOptions, ExtendedStorage>> = {},\n  ) {\n    const extension = new Node<ExtendedOptions, ExtendedStorage>(extendedConfig)\n\n    extension.parent = this\n\n    this.child = extension\n\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name\n\n    if (extendedConfig.defaultOptions) {\n      console.warn(\n        `[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`,\n      )\n    }\n\n    extension.options = callOrReturn(\n      getExtensionField<AnyConfig['addOptions']>(extension, 'addOptions', {\n        name: extension.name,\n      }),\n    )\n\n    extension.storage = callOrReturn(\n      getExtensionField<AnyConfig['addStorage']>(extension, 'addStorage', {\n        name: extension.name,\n        options: extension.options,\n      }),\n    )\n\n    return extension\n  }\n}\n","export function isAndroid(): boolean {\n  return navigator.platform === 'Android' || /android/i.test(navigator.userAgent)\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { NodeSelection } from '@tiptap/pm/state'\nimport { NodeView as ProseMirrorNodeView } from '@tiptap/pm/view'\n\nimport { Editor as CoreEditor } from './Editor.js'\nimport { Node } from './Node.js'\nimport { DecorationWithType, NodeViewRendererOptions, NodeViewRendererProps } from './types.js'\nimport { isAndroid } from './utilities/isAndroid.js'\nimport { isiOS } from './utilities/isiOS.js'\n\nexport class NodeView<\n  Component,\n  NodeEditor extends CoreEditor = CoreEditor,\n  Options extends NodeViewRendererOptions = NodeViewRendererOptions,\n> implements ProseMirrorNodeView {\n  component: Component\n\n  editor: NodeEditor\n\n  options: Options\n\n  extension: Node\n\n  node: ProseMirrorNode\n\n  decorations: DecorationWithType[]\n\n  getPos: any\n\n  isDragging = false\n\n  constructor(component: Component, props: NodeViewRendererProps, options?: Partial<Options>) {\n    this.component = component\n    this.editor = props.editor as NodeEditor\n    this.options = {\n      stopEvent: null,\n      ignoreMutation: null,\n      ...options,\n    } as Options\n    this.extension = props.extension\n    this.node = props.node\n    this.decorations = props.decorations as DecorationWithType[]\n    this.getPos = props.getPos\n    this.mount()\n  }\n\n  mount() {\n    // eslint-disable-next-line\n    return\n  }\n\n  get dom(): HTMLElement {\n    return this.editor.view.dom as HTMLElement\n  }\n\n  get contentDOM(): HTMLElement | null {\n    return null\n  }\n\n  onDragStart(event: DragEvent) {\n    const { view } = this.editor\n    const target = event.target as HTMLElement\n\n    // get the drag handle element\n    // `closest` is not available for text nodes so we may have to use its parent\n    const dragHandle = target.nodeType === 3\n      ? target.parentElement?.closest('[data-drag-handle]')\n      : target.closest('[data-drag-handle]')\n\n    if (!this.dom || this.contentDOM?.contains(target) || !dragHandle) {\n      return\n    }\n\n    let x = 0\n    let y = 0\n\n    // calculate offset for drag element if we use a different drag handle element\n    if (this.dom !== dragHandle) {\n      const domBox = this.dom.getBoundingClientRect()\n      const handleBox = dragHandle.getBoundingClientRect()\n\n      // In React, we have to go through nativeEvent to reach offsetX/offsetY.\n      const offsetX = event.offsetX ?? (event as any).nativeEvent?.offsetX\n      const offsetY = event.offsetY ?? (event as any).nativeEvent?.offsetY\n\n      x = handleBox.x - domBox.x + offsetX\n      y = handleBox.y - domBox.y + offsetY\n    }\n\n    event.dataTransfer?.setDragImage(this.dom, x, y)\n\n    // we need to tell ProseMirror that we want to move the whole node\n    // so we create a NodeSelection\n    const selection = NodeSelection.create(view.state.doc, this.getPos())\n    const transaction = view.state.tr.setSelection(selection)\n\n    view.dispatch(transaction)\n  }\n\n  stopEvent(event: Event) {\n    if (!this.dom) {\n      return false\n    }\n\n    if (typeof this.options.stopEvent === 'function') {\n      return this.options.stopEvent({ event })\n    }\n\n    const target = event.target as HTMLElement\n    const isInElement = this.dom.contains(target) && !this.contentDOM?.contains(target)\n\n    // any event from child nodes should be handled by ProseMirror\n    if (!isInElement) {\n      return false\n    }\n\n    const isDragEvent = event.type.startsWith('drag')\n    const isDropEvent = event.type === 'drop'\n    const isInput = ['INPUT', 'BUTTON', 'SELECT', 'TEXTAREA'].includes(target.tagName) || target.isContentEditable\n\n    // any input event within node views should be ignored by ProseMirror\n    if (isInput && !isDropEvent && !isDragEvent) {\n      return true\n    }\n\n    const { isEditable } = this.editor\n    const { isDragging } = this\n    const isDraggable = !!this.node.type.spec.draggable\n    const isSelectable = NodeSelection.isSelectable(this.node)\n    const isCopyEvent = event.type === 'copy'\n    const isPasteEvent = event.type === 'paste'\n    const isCutEvent = event.type === 'cut'\n    const isClickEvent = event.type === 'mousedown'\n\n    // ProseMirror tries to drag selectable nodes\n    // even if `draggable` is set to `false`\n    // this fix prevents that\n    if (!isDraggable && isSelectable && isDragEvent) {\n      event.preventDefault()\n    }\n\n    if (isDraggable && isDragEvent && !isDragging) {\n      event.preventDefault()\n      return false\n    }\n\n    // we have to store that dragging started\n    if (isDraggable && isEditable && !isDragging && isClickEvent) {\n      const dragHandle = target.closest('[data-drag-handle]')\n      const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle))\n\n      if (isValidDragHandle) {\n        this.isDragging = true\n\n        document.addEventListener(\n          'dragend',\n          () => {\n            this.isDragging = false\n          },\n          { once: true },\n        )\n\n        document.addEventListener(\n          'drop',\n          () => {\n            this.isDragging = false\n          },\n          { once: true },\n        )\n\n        document.addEventListener(\n          'mouseup',\n          () => {\n            this.isDragging = false\n          },\n          { once: true },\n        )\n      }\n    }\n\n    // these events are handled by prosemirror\n    if (\n      isDragging\n      || isDropEvent\n      || isCopyEvent\n      || isPasteEvent\n      || isCutEvent\n      || (isClickEvent && isSelectable)\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  ignoreMutation(mutation: MutationRecord | { type: 'selection'; target: Element }) {\n    if (!this.dom || !this.contentDOM) {\n      return true\n    }\n\n    if (typeof this.options.ignoreMutation === 'function') {\n      return this.options.ignoreMutation({ mutation })\n    }\n\n    // a leaf/atom node is like a black box for ProseMirror\n    // and should be fully handled by the node view\n    if (this.node.isLeaf || this.node.isAtom) {\n      return true\n    }\n\n    // ProseMirror should handle any selections\n    if (mutation.type === 'selection') {\n      return false\n    }\n\n    // try to prevent a bug on iOS and Android that will break node views on enter\n    // this is because ProseMirror can’t preventDispatch on enter\n    // this will lead to a re-render of the node view on enter\n    // see: https://github.com/ueberdosis/tiptap/issues/1214\n    // see: https://github.com/ueberdosis/tiptap/issues/2534\n    if (\n      this.dom.contains(mutation.target)\n      && mutation.type === 'childList'\n      && (isiOS() || isAndroid())\n      && this.editor.isFocused\n    ) {\n      const changedNodes = [\n        ...Array.from(mutation.addedNodes),\n        ...Array.from(mutation.removedNodes),\n      ] as HTMLElement[]\n\n      // we’ll check if every changed node is contentEditable\n      // to make sure it’s probably mutated by ProseMirror\n      if (changedNodes.every(node => node.isContentEditable)) {\n        return false\n      }\n    }\n\n    // we will allow mutation contentDOM with attributes\n    // so we can for example adding classes within our node view\n    if (this.contentDOM === mutation.target && mutation.type === 'attributes') {\n      return true\n    }\n\n    // ProseMirror should handle any changes within contentDOM\n    if (this.contentDOM.contains(mutation.target)) {\n      return false\n    }\n\n    return true\n  }\n\n  updateAttributes(attributes: {}) {\n    this.editor.commands.command(({ tr }) => {\n      const pos = this.getPos()\n\n      tr.setNodeMarkup(pos, undefined, {\n        ...this.node.attrs,\n        ...attributes,\n      })\n\n      return true\n    })\n  }\n\n  deleteNode(): void {\n    const from = this.getPos()\n    const to = from + this.node.nodeSize\n\n    this.editor.commands.deleteRange({ from, to })\n  }\n}\n","import { MarkType } from '@tiptap/pm/model'\n\nimport { getMarksBetween } from '../helpers/getMarksBetween.js'\nimport { PasteRule, PasteRuleFinder } from '../PasteRule.js'\nimport { ExtendedRegExpMatchArray } from '../types.js'\nimport { callOrReturn } from '../utilities/callOrReturn.js'\n\n/**\n * Build an paste rule that adds a mark when the\n * matched text is pasted into it.\n */\nexport function markPasteRule(config: {\n  find: PasteRuleFinder\n  type: MarkType\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray, event: ClipboardEvent) => Record<string, any>)\n    | false\n    | null\n}) {\n  return new PasteRule({\n    find: config.find,\n    handler: ({\n      state, range, match, pasteEvent,\n    }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match, pasteEvent)\n\n      if (attributes === false || attributes === null) {\n        return null\n      }\n\n      const { tr } = state\n      const captureGroup = match[match.length - 1]\n      const fullMatch = match[0]\n      let markEnd = range.to\n\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/)\n        const textStart = range.from + fullMatch.indexOf(captureGroup)\n        const textEnd = textStart + captureGroup.length\n\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc)\n          .filter(item => {\n            // @ts-ignore\n            const excluded = item.mark.type.excluded as MarkType[]\n\n            return excluded.find(type => type === config.type && type !== item.mark.type)\n          })\n          .filter(item => item.to > textStart)\n\n        if (excludedMarks.length) {\n          return null\n        }\n\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to)\n        }\n\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart)\n        }\n\n        markEnd = range.from + startSpaces + captureGroup.length\n\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}))\n\n        tr.removeStoredMark(config.type)\n      }\n    },\n  })\n}\n","// source: https://stackoverflow.com/a/6969486\nexport function escapeForRegEx(string: string): string {\n  return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n}\n","export function isString(value: any): value is string {\n  return typeof value === 'string'\n}\n","import { NodeType } from '@tiptap/pm/model'\n\nimport { PasteRule, PasteRuleFinder } from '../PasteRule.js'\nimport { ExtendedRegExpMatchArray } from '../types.js'\nimport { callOrReturn } from '../utilities/index.js'\n\n/**\n * Build an paste rule that adds a node when the\n * matched text is pasted into it.\n */\nexport function nodePasteRule(config: {\n  find: PasteRuleFinder\n  type: NodeType\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray, event: ClipboardEvent) => Record<string, any>)\n    | false\n    | null\n}) {\n  return new PasteRule({\n    find: config.find,\n    handler({\n      match, chain, range, pasteEvent,\n    }) {\n      const attributes = callOrReturn(config.getAttributes, undefined, match, pasteEvent)\n\n      if (attributes === false || attributes === null) {\n        return null\n      }\n\n      if (match.input) {\n        chain().deleteRange(range).insertContentAt(range.from, {\n          type: config.type.name,\n          attrs: attributes,\n        })\n      }\n    },\n  })\n}\n","import { PasteRule, PasteRuleFinder } from '../PasteRule.js'\n\n/**\n * Build an paste rule that replaces text when the\n * matched text is pasted into it.\n */\nexport function textPasteRule(config: {\n  find: PasteRuleFinder,\n  replace: string,\n}) {\n  return new PasteRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      let insert = config.replace\n      let start = range.from\n      const end = range.to\n\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1])\n\n        insert += match[0].slice(offset + match[1].length)\n        start += offset\n\n        const cutOff = start - end\n\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert\n          start = end\n        }\n      }\n\n      state.tr.insertText(insert, start, end)\n    },\n  })\n}\n","import { Transaction } from '@tiptap/pm/state'\n\nexport interface TrackerResult {\n  position: number\n  deleted: boolean\n}\n\nexport class Tracker {\n  transaction: Transaction\n\n  currentStep: number\n\n  constructor(transaction: Transaction) {\n    this.transaction = transaction\n    this.currentStep = this.transaction.steps.length\n  }\n\n  map(position: number): TrackerResult {\n    let deleted = false\n\n    const mappedPosition = this.transaction.steps\n      .slice(this.currentStep)\n      .reduce((newPosition, step) => {\n        const mapResult = step.getMap().mapResult(newPosition)\n\n        if (mapResult.deleted) {\n          deleted = true\n        }\n\n        return mapResult.pos\n      }, position)\n\n    return {\n      position: mappedPosition,\n      deleted,\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}